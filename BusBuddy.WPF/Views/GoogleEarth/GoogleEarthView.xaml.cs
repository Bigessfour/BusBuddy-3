using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Controls;
using BusBuddy.WPF.ViewModels.GoogleEarth;
using Serilog;
using Serilog.Context;
using Syncfusion.UI.Xaml.Maps; // Official SfMap API reference: https://help.syncfusion.com/cr/wpf/Syncfusion.UI.Xaml.Maps.html
using Microsoft.Extensions.DependencyInjection;
using BusBuddy.Core.Data;

namespace BusBuddy.WPF.Views.GoogleEarth
{
    /// <summary>
    /// Interaction logic for GoogleEarthView.xaml
    /// Google Earth integration for advanced geospatial mapping and route visualization
    /// Enhanced with debounced layer changes and optimized background processing
    /// </summary>
    public partial class GoogleEarthView : UserControl, IDisposable
    {
        private static readonly ILogger Logger = Log.ForContext<GoogleEarthView>();
    // Safe accessor for the SfMap control declared as x:Name="GeoMap" in XAML
    // Using a property avoids compile-time issues if the generated field isn't available to analyzers
    private SfMap? MapControl => this.FindName("GeoMap") as SfMap;

    // Debouncing for map layer changes — avoids rapid layer swaps causing redundant work
        private readonly Timer _layerChangeDebounceTimer;
        private string? _pendingLayerType;
        private readonly object _layerChangeLock = new object();
        private const int LayerChangeDebounceDelayMs = 500;
        private bool _disposed;

    private MapLayer? _currentLayer; // Tracks current map layer
    // Cache of MapLayer instances by type to reduce allocations and tile re-fetches
    private readonly Dictionary<string, MapLayer> _layerCache = new(StringComparer.OrdinalIgnoreCase);
    // District boundary overlay (ShapeFileLayer) managed separately from base imagery layer
    private ShapeFileLayer? _districtBoundaryLayer;
    private bool _districtBoundaryAdded;
    // Town boundary (Wiley town limits) overlay
    private ShapeFileLayer? _townBoundaryLayer;
    private bool _townBoundaryAdded;

    // Reference to the Syncfusion SfMap control is generated by XAML as a field named 'GeoMap'.
    // Use that generated field directly to avoid duplicate member conflicts.

    // Per Syncfusion KB 11928 — custom imagery layer for Google Maps tiles
        private sealed class GoogleImageryLayer : ImageryLayer
        {
            // Docs KB: https://www.syncfusion.com/kb/11928/how-to-show-google-map-in-wpf-map-sfmap
            protected override string GetUri(int x, int y, int scale)
            {
                // "lyrs" values: m=roadmap, s=satellite, y=hybrid, t=terrain (Google parameterization)
                // Default to hybrid (y) to show both roads and imagery
                var link = "http://mt1.google.com/vt/lyrs=y&x=" + x + "&y=" + y + "&z=" + scale;
                return link;
            }
        }

    // OpenStreetMap provider per Syncfusion docs: https://help.syncfusion.com/wpf/maps/map-providers#open-street-map
        private sealed class OpenStreetMapLayer : ImageryLayer
        {
            protected override string GetUri(int x, int y, int scale)
            {
                return $"http://tile.openstreetmap.org/{scale}/{x}/{y}.png";
            }
        }

        public GoogleEarthView()
        {
            using (LogContext.PushProperty("ViewInitialization", "GoogleEarthView"))
            using (LogContext.PushProperty("PerformanceOptimizations", "Enabled"))
            {
                InitializeComponent();

                // Ensure DataContext is available — resolve from DI container when possible
                try
                {
                    if (DataContext is null && BusBuddy.WPF.App.ServiceProvider is not null)
                    {
                        var vmFromDi = BusBuddy.WPF.App.ServiceProvider.GetService<GoogleEarthViewModel>();
                        if (vmFromDi is not null)
                        {
                            DataContext = vmFromDi;
                            Logger.Debug("GoogleEarthViewModel resolved from DI and set as DataContext");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Logger.Warning(ex, "Failed to resolve GoogleEarthViewModel from DI");
                }

                // Initialize debounce timer for layer changes (UI events funnel to delayed apply)
                _layerChangeDebounceTimer = new Timer(OnLayerChangeDebounceElapsed, null, Timeout.Infinite, Timeout.Infinite);

                // Subscribe to Unloaded event for cleanup
                this.Unloaded += GoogleEarthView_Unloaded;

                Logger.Information("Google Earth view initialized successfully with performance optimizations");
                Logger.Debug("Layer change debouncing configured with {DelayMs}ms delay", LayerChangeDebounceDelayMs);

                // Pre-warm layers to reduce first-switch latency
                PrewarmLayers();

                // Initialize map with default layer
                InitializeMapLayer("Hybrid");
                // Center to a reasonable default (world view) — see TryResetView
                TryResetView();

                // Kick off background health checks (DB connectivity, etc.)
                _ = Task.Run(CheckBackendConnectivityAsync);
            }
        }

    /// <summary>
    /// Handles map layer SelectionChanged from ComboBoxAdv with debouncing to prevent rapid API calls.
    /// Sender is expected to be Syncfusion ComboBoxAdv with ComboBoxItemAdv items.
    /// </summary>
        private void MapLayerComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var correlationId = Guid.NewGuid().ToString("N")[..8];

            using (LogContext.PushProperty("UserInteraction", "MapLayerChange"))
            using (LogContext.PushProperty("CorrelationId", correlationId))
            {
                try
                {
                    if (DataContext is not GoogleEarthViewModel viewModel)
                    {
                        Logger.Warning("ViewModel not available for layer change operation");
                        return;
                    }

                    // ComboBoxAdv from Syncfusion raises SelectionChanged; validate sender and selected item types
                    if (sender is not Syncfusion.Windows.Tools.Controls.ComboBoxAdv comboBox ||
                        comboBox.SelectedItem is not Syncfusion.Windows.Tools.Controls.ComboBoxItemAdv selectedItem)
                    {
                        Logger.Debug("No valid selection detected in layer combo box");
                        return;
                    }

                    var layerType = selectedItem.Content?.ToString();
                    if (string.IsNullOrEmpty(layerType))
                    {
                        Logger.Warning("Selected layer type is null or empty");
                        return;
                    }

                    Logger.Debug("Layer change request received: {LayerType} (will be debounced)", layerType);

                    // Store the pending layer type and restart the debounce timer
                    lock (_layerChangeLock)
                    {
                        _pendingLayerType = layerType;
                        _layerChangeDebounceTimer.Change(LayerChangeDebounceDelayMs, Timeout.Infinite);
                    }
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Failed to process layer change request: {ErrorMessage} (CorrelationId: {CorrelationId})",
                               ex.Message, correlationId);

                    // Could add user notification here if needed
                    // ShowUserFriendlyError("Failed to change map layer. Please try again.");
                }
            }
        }

    /// <summary>
    /// Applies pending layer change after debounce delay on a background thread, then marshals to UI thread.
    /// </summary>
        private async void OnLayerChangeDebounceElapsed(object? state)
        {
            string? layerTypeToApply;

            // Get the pending layer type safely
            lock (_layerChangeLock)
            {
                layerTypeToApply = _pendingLayerType;
                _pendingLayerType = null;
            }

            if (string.IsNullOrEmpty(layerTypeToApply))
            {
                return;
            }


            var correlationId = Guid.NewGuid().ToString("N")[..8];

            using (LogContext.PushProperty("BackgroundOperation", "DebouncedLayerChange"))
            using (LogContext.PushProperty("CorrelationId", correlationId))
            using (LogContext.PushProperty("LayerType", layerTypeToApply))
            {
                var stopwatch = System.Diagnostics.Stopwatch.StartNew();

                try
                {
                    Logger.Information("Executing debounced layer change to: {LayerType}", layerTypeToApply);

                    // Execute on UI thread — map layer updates must run on UI thread
                    await Dispatcher.InvokeAsync(() =>
                    {
                        using (LogContext.PushProperty("ThreadType", "UI"))
                        {
                            Logger.Debug("Applying geospatial layer change on UI thread");
                            InitializeMapLayer(layerTypeToApply!);
                        }
                    });

                    stopwatch.Stop();
                    Logger.Information("Layer change completed successfully in {ElapsedMs}ms", stopwatch.ElapsedMilliseconds);
                }
                catch (Exception ex)
                {
                    stopwatch.Stop();
                    Logger.Error(ex, "Failed to execute debounced layer change: {ErrorMessage} (Elapsed: {ElapsedMs}ms)",
                               ex.Message, stopwatch.ElapsedMilliseconds);
                }
            }
        }

    // Creates and applies a layer to SfMap per Syncfusion Maps docs
        private void InitializeMapLayer(string layerType)
        {
            try
            {
                using (LogContext.PushProperty("ApplyLayer", layerType))
                {
                    if (MapControl is null)
                    {
                        Logger.Warning("SfMap control not found in view");
                        return;
                    }

                    // Replace only the base imagery layer while preserving overlays like district boundary
                    RemoveBaseImageryLayer();
                    var newLayer = GetOrCreateLayer(layerType);

                    MapControl.Layers.Add(newLayer);
                    _currentLayer = newLayer;
                    Logger.Information("Applied map layer: {Layer}", layerType);

                    // Toggle OSM attribution visibility based on layer
                    ToggleOsmAttribution(string.Equals(layerType, "OpenStreetMap", StringComparison.OrdinalIgnoreCase));

                    // Re-apply overlays if toggled on
                    if (DataContext is GoogleEarthViewModel vm)
                    {
                        // Bind markers (students, school) to the active base layer
                        try
                        {
                            if (newLayer is ImageryLayer imagery)
                            {
                                imagery.Markers = vm.MapMarkers;
                                // Try to apply marker template if present in XAML resources
                                if (this.TryFindResource("StudentMarkerTemplate") is System.Windows.DataTemplate template)
                                {
                                    imagery.MarkerTemplate = template;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.Warning(ex, "Failed to bind markers to imagery layer");
                        }
                        if (vm.DistrictBoundaryVisible)
                        {
                            ApplyDistrictBoundaryVisibility(true);
                        }
                        if (vm.TownBoundaryVisible)
                        {
                            ApplyTownBoundaryVisibility(true);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Error(ex, "Failed to initialize map layer: {LayerType}", layerType);
            }
        }

        // Remove only the current base imagery layer from GeoMap.Layers
        private void RemoveBaseImageryLayer()
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }
                if (_currentLayer is not null && MapControl.Layers.Contains(_currentLayer))
                {
                    MapControl.Layers.Remove(_currentLayer);
                    _currentLayer = null;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to remove base imagery layer");
            }
        }

    // Returns a cached layer or creates and caches one for reuse; avoids repeated allocations and CA2000 concerns
        private MapLayer GetOrCreateLayer(string layerType)
        {
            if (_layerCache.TryGetValue(layerType, out var existing))
            {
                return existing;
            }

            MapLayer created;
            var key = layerType.ToLowerInvariant();

            switch (key)
            {
                case "satellite":
                    created = new DynamicGoogleImageryLayer("s");
                    break;
                case "terrain":
                    created = new DynamicGoogleImageryLayer("t");
                    break;
                case "roadmap":
                    created = new DynamicGoogleImageryLayer("m");
                    break;
                case "openstreetmap":
                    created = new OpenStreetMapLayer();
                    break;
                case "hybrid":
                default:
                    created = new DynamicGoogleImageryLayer("y");
                    break;
            }

            _layerCache[layerType] = created;
            return created;
        }

    // Pre-create commonly used layers to improve first-use responsiveness
    private void PrewarmLayers()
        {
            try
            {
                GetOrCreateLayer("Satellite");
                GetOrCreateLayer("Terrain");
                GetOrCreateLayer("Hybrid");
                GetOrCreateLayer("Roadmap");
                GetOrCreateLayer("OpenStreetMap");
                Logger.Debug("Pre-warmed map layers cache");
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Error while pre-warming map layers");
            }
        }

    // Shows or hides the OSM attribution overlay based on active provider
    private void ToggleOsmAttribution(bool visible)
        {
            try
            {
                var overlay = this.FindName("OsmAttribution") as System.Windows.Controls.Border;
                if (overlay is not null)
                {
                    overlay.Visibility = visible ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to toggle OSM attribution overlay");
            }
        }

    // Simple helpers for map view manipulation
        private void TryResetView()
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }
                // Optional: set initial view using Syncfusion-documented API (deferred until verified)
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to reset map view");
            }
        }

        // Basic backend connectivity check — verifies DbContext can connect if registered
        private async Task CheckBackendConnectivityAsync()
        {
            try
            {
                var sp = BusBuddy.WPF.App.ServiceProvider;
                if (sp is null)
                {
                    Logger.Debug("ServiceProvider not initialized — skipping backend connectivity check");
                    return;
                }

                using var scope = sp.CreateScope();
                var contextFactory = scope.ServiceProvider.GetService<IBusBuddyDbContextFactory>();
                if (contextFactory is null)
                {
                    Logger.Debug("IBusBuddyDbContextFactory not available — skipping DB connectivity check");
                    return;
                }

                using var context = contextFactory.CreateDbContext();
                var canConnect = await context.Database.CanConnectAsync();
                Logger.Information("Database connectivity check from GoogleEarthView: {CanConnect}", canConnect);
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Backend connectivity check failed");
            }
        }

    // Wrapper to allow dynamic Google imagery style per KB pattern while adhering to ImageryLayer API
        private sealed class DynamicGoogleImageryLayer : ImageryLayer
        {
            private readonly string _mode;
            public DynamicGoogleImageryLayer(string mode)
            {
                _mode = mode;
            }
            protected override string GetUri(int x, int y, int scale)
            {
                return $"http://mt1.google.com/vt/lyrs={_mode}&x={x}&y={y}&z={scale}";
            }
        }

    /// <summary>
    /// Handles DataContext changes to wire up ViewModel events — validates types and initializes background work.
    /// </summary>
        private void OnDataContextChanged(object sender, System.Windows.DependencyPropertyChangedEventArgs e)
        {
            var correlationId = Guid.NewGuid().ToString("N")[..8];

            using (LogContext.PushProperty("ViewModelBinding", "GoogleEarthViewModel"))
            using (LogContext.PushProperty("CorrelationId", correlationId))
            {
                try
                {
                    // Cleanup old ViewModel if needed
                    if (e.OldValue is GoogleEarthViewModel oldViewModel)
                    {
                        Logger.Debug("Cleaning up previous ViewModel binding");
                        // Add any cleanup logic here if needed
                    }

                    if (e.NewValue is GoogleEarthViewModel newViewModel)
                    {
                        Logger.Information("Google Earth view model connected successfully");

                        // Wire up any additional ViewModel events or initialize background operations
                        Task.Run(async () =>
                        {
                            using (LogContext.PushProperty("BackgroundOperation", "ViewModelInitialization"))
                            {
                                try
                                {
                                    Logger.Debug("Initializing background ViewModel operations");

                                    // Perform any heavy initialization operations here
                                    await Task.Delay(100); // Placeholder for actual initialization

                                    // Bind to overlay visibility changes
                                    Dispatcher.Invoke(() =>
                                    {
                                        ApplyDistrictBoundaryVisibility(newViewModel.DistrictBoundaryVisible);
                                        ApplyTownBoundaryVisibility(newViewModel.TownBoundaryVisible);
                                    });
                                    newViewModel.PropertyChanged += ViewModelOnPropertyChanged;

                                    Logger.Debug("Background ViewModel initialization completed");
                                }
                                catch (Exception ex)
                                {
                                    Logger.Error(ex, "Failed during background ViewModel initialization");
                                }
                            }
                        });
                    }
                    else if (e.NewValue != null)
                    {
                        Logger.Warning("DataContext is not of expected GoogleEarthViewModel type: {ActualType}",
                                     e.NewValue.GetType().Name);
                    }
                    else
                    {
                        Logger.Debug("DataContext set to null");
                    }
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Failed to handle DataContext change: {ErrorMessage}", ex.Message);
                }
            }
        }

        private void ViewModelOnPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (sender is not GoogleEarthViewModel vm)
            {
                return;
            }
            if (e.PropertyName == nameof(GoogleEarthViewModel.DistrictBoundaryVisible))
            {
                Dispatcher.Invoke(() => ApplyDistrictBoundaryVisibility(vm.DistrictBoundaryVisible));
            }
            else if (e.PropertyName == nameof(GoogleEarthViewModel.TownBoundaryVisible))
            {
                Dispatcher.Invoke(() => ApplyTownBoundaryVisibility(vm.TownBoundaryVisible));
            }
        }

        // Creates or removes the district boundary overlay ShapeFileLayer
        private void ApplyDistrictBoundaryVisibility(bool visible)
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }

                if (visible)
                {
                    if (_districtBoundaryLayer is null)
                    {
                        // Official API usage per docs: set Uri to embedded shapefile resource
                        _districtBoundaryLayer = new ShapeFileLayer
                        {
                            // Uri must point to an embedded resource e.g., "BusBuddy.WPF.Assets.Maps.WileyDistrict.WileyDistrict.shp"
                            // Add the .shp and matching .dbf to the project with Build Action = Resource
                            Uri = "BusBuddy.WPF.Assets.Maps.WileyDistrict.WileyDistrict.shp",
                            MapItemsVisibility = System.Windows.Visibility.Collapsed,
                            ShapeSettings = new ShapeSetting
                            {
                                ShapeFill = System.Windows.Media.Brushes.Transparent,
                                ShapeStroke = System.Windows.Media.Brushes.OrangeRed,
                                ShapeStrokeThickness = 2d
                            }
                        };
                    }

                    if (!_districtBoundaryAdded)
                    {
                        MapControl.Layers.Add(_districtBoundaryLayer);
                        _districtBoundaryAdded = true;
                        Logger.Information("District boundary overlay added to map");
                    }
                }
                else
                {
                    if (_districtBoundaryLayer is not null && _districtBoundaryAdded)
                    {
                        MapControl.Layers.Remove(_districtBoundaryLayer);
                        _districtBoundaryAdded = false;
                        Logger.Information("District boundary overlay removed from map");
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to apply district boundary visibility");
            }
        }

        // Creates or removes the town boundary overlay ShapeFileLayer (Wiley town limits)
        private void ApplyTownBoundaryVisibility(bool visible)
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }

                if (visible)
                {
                    if (_townBoundaryLayer is null)
                    {
                        _townBoundaryLayer = new ShapeFileLayer
                        {
                            // Expect the shapefile to be deployed to Assets\\Maps\\WileyTown\\WileyTown.shp
                            Uri = "Assets/Maps/WileyTown/WileyTown.shp",
                            MapItemsVisibility = System.Windows.Visibility.Collapsed,
                            ShapeSettings = new ShapeSetting
                            {
                                ShapeFill = System.Windows.Media.Brushes.Transparent,
                                ShapeStroke = System.Windows.Media.Brushes.DodgerBlue,
                                ShapeStrokeThickness = 2d
                            }
                        };
                    }

                    if (!_townBoundaryAdded)
                    {
                        MapControl.Layers.Add(_townBoundaryLayer);
                        _townBoundaryAdded = true;
                        Logger.Information("Town boundary overlay added to map");
                    }
                }
                else
                {
                    if (_townBoundaryLayer is not null && _townBoundaryAdded)
                    {
                        MapControl.Layers.Remove(_townBoundaryLayer);
                        _townBoundaryAdded = false;
                        Logger.Information("Town boundary overlay removed from map");
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to apply town boundary visibility");
            }
        }

    /// <summary>
    /// OnInitialized — subscribes to DataContextChanged and completes view initialization.
    /// </summary>
        protected override void OnInitialized(EventArgs e)
        {
            using (LogContext.PushProperty("ViewLifecycle", "Initialization"))
            {
                try
                {
                    base.OnInitialized(e);
                    DataContextChanged += OnDataContextChanged;

                    Logger.Debug("GoogleEarthView initialization completed successfully");
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Failed during GoogleEarthView initialization");
                    throw; // Re-throw to allow proper error handling upstream
                }
            }
        }

    /// <summary>
    /// Cleanup resources when the view is being disposed
    /// </summary>
        private void GoogleEarthView_Unloaded(object sender, System.Windows.RoutedEventArgs e)
        {
            using (LogContext.PushProperty("ViewLifecycle", "Unloaded"))
            {
                Logger.Debug("GoogleEarthView unloaded, disposing resources");
                Dispose();
            }
        }

    /// <summary>
    /// Dispose pattern implementation
    /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

    /// <summary>
    /// Protected dispose method
    /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
            {
                try
                {
                    _layerChangeDebounceTimer?.Dispose();
                    DataContextChanged -= OnDataContextChanged;
                    this.Unloaded -= GoogleEarthView_Unloaded;
                    try
                    {
                        // Clear map layers and dispose cached layers
                        if (MapControl is not null)
                        {
                            MapControl.Layers.Clear();
                        }
                        foreach (var layer in _layerCache.Values)
                        {
                            (layer as IDisposable)?.Dispose();
                        }
                        _layerCache.Clear();
                    }
                    catch (Exception ex)
                    {
                        Logger.Warning(ex, "Error while disposing cached map layers");
                    }
                    Logger.Debug("GoogleEarthView resources disposed successfully");
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Error during GoogleEarthView disposal");
                }
                finally
                {
                    _disposed = true;
                }
            }
        }
    }
}
