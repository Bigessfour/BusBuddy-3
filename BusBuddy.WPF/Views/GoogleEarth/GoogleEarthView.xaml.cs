using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Controls;
using BusBuddy.WPF.ViewModels.GoogleEarth;
using Serilog;
using Serilog.Context;
using Syncfusion.UI.Xaml.Maps; // Official SfMap API reference: https://help.syncfusion.com/cr/wpf/Syncfusion.UI.Xaml.Maps.html
using Microsoft.Extensions.DependencyInjection;
using BusBuddy.Core.Data;
using System.Windows; // For Point, Size
using System.Printing; // Microsoft printing APIs
using System.Windows.Media; // Visual tree for printing
using System.Windows.Documents; // FixedDocument for printing
using System.Windows.Markup; // IAddChild
using Syncfusion.SfSkinManager;
using System.Windows.Media.Imaging; // For RenderTargetBitmap
using System.IO; // For MemoryStream / PNG encoder

namespace BusBuddy.WPF.Views.GoogleEarth
{
    /// <summary>
    /// Interaction logic for GoogleEarthView.xaml
    /// Google Earth integration for advanced geospatial mapping and route visualization
    /// Enhanced with debounced layer changes and optimized background processing
    /// </summary>
    public partial class GoogleEarthView : UserControl, IDisposable
    {
        private static readonly ILogger Logger = Log.ForContext<GoogleEarthView>();
    // Safe accessor for the SfMap control declared as x:Name="GeoMap" in XAML
    // Using a property avoids compile-time issues if the generated field isn't available to analyzers
    private SfMap? MapControl => this.FindName("GeoMap") as SfMap;

    // Debouncing for map layer changes — avoids rapid layer swaps causing redundant work
        private readonly Timer _layerChangeDebounceTimer;
        private string? _pendingLayerType;
        private readonly object _layerChangeLock = new object();
        private const int LayerChangeDebounceDelayMs = 500;
        private bool _disposed;

    private MapLayer? _currentLayer; // Tracks current map layer
    // Cache of MapLayer instances by type to reduce allocations and tile re-fetches
    private readonly Dictionary<string, MapLayer> _layerCache = new(StringComparer.OrdinalIgnoreCase);
    // District boundary overlay (ShapeFileLayer) managed separately from base imagery layer
    private ShapeFileLayer? _districtBoundaryLayer;
    private bool _districtBoundaryAdded;
    // Town boundary (Wiley town limits) overlay
    private ShapeFileLayer? _townBoundaryLayer;
    private bool _townBoundaryAdded;

    // Sub-layer for drawing dynamic polylines on top of base imagery per Syncfusion docs (MapPolyline inside SubShapeFileLayer)
    private SubShapeFileLayer? _routeSubLayer;
    private MapPolyline? _routePolyline;

    // Reference to the Syncfusion SfMap control is generated by XAML as a field named 'GeoMap'.
    // Use that generated field directly to avoid duplicate member conflicts.

    // Per Syncfusion KB 11928 — custom imagery layer for Google Maps tiles
        private sealed class GoogleImageryLayer : ImageryLayer
        {
            // Docs KB: https://www.syncfusion.com/kb/11928/how-to-show-google-map-in-wpf-map-sfmap
            protected override string GetUri(int x, int y, int scale)
            {
                // "lyrs" values: m=roadmap, s=satellite, y=hybrid, t=terrain (Google parameterization)
                // Default to hybrid (y) to show both roads and imagery
                var link = "http://mt1.google.com/vt/lyrs=y&x=" + x + "&y=" + y + "&z=" + scale;
                return link;
            }
        }

    // OpenStreetMap provider per Syncfusion docs: https://help.syncfusion.com/wpf/maps/map-providers#open-street-map
        private sealed class OpenStreetMapLayer : ImageryLayer
        {
            protected override string GetUri(int x, int y, int scale)
            {
                return $"http://tile.openstreetmap.org/{scale}/{x}/{y}.png";
            }
        }

        public GoogleEarthView()
        {
            using (LogContext.PushProperty("ViewInitialization", "GoogleEarthView"))
            using (LogContext.PushProperty("PerformanceOptimizations", "Enabled"))
            {
                InitializeComponent();

                // Apply Syncfusion theme (FluentDark default, FluentLight fallback)
                ApplySyncfusionTheme();

                // Ensure DataContext is available — resolve from DI container when possible
                try
                {
                    if (DataContext is null && BusBuddy.WPF.App.ServiceProvider is not null)
                    {
                        var vmFromDi = BusBuddy.WPF.App.ServiceProvider.GetService<GoogleEarthViewModel>();
                        if (vmFromDi is not null)
                        {
                            DataContext = vmFromDi;
                            Logger.Debug("GoogleEarthViewModel resolved from DI and set as DataContext");
                        }
                    }
                }
                catch (Exception ex)
                {
                    Logger.Warning(ex, "Failed to resolve GoogleEarthViewModel from DI");
                }

                // Initialize debounce timer for layer changes (UI events funnel to delayed apply)
                _layerChangeDebounceTimer = new Timer(OnLayerChangeDebounceElapsed, null, Timeout.Infinite, Timeout.Infinite);

                // Subscribe to Unloaded event for cleanup
                this.Unloaded += GoogleEarthView_Unloaded;

                Logger.Information("Google Earth view initialized successfully with performance optimizations");
                Logger.Debug("Layer change debouncing configured with {DelayMs}ms delay", LayerChangeDebounceDelayMs);

                // Pre-warm layers to reduce first-switch latency
                PrewarmLayers();

                // Initialize map with default layer
                InitializeMapLayer("Hybrid");
                // Center to a reasonable default (world view) — see TryResetView
                TryResetView();

                // Kick off background health checks (DB connectivity, etc.)
                _ = Task.Run(CheckBackendConnectivityAsync);
            }
        }

        /// <summary>
        /// Ensure Syncfusion theme is applied consistently.
        /// Pattern mirrors FuelReconciliationDialog and follows Syncfusion SfSkinManager docs.
        /// </summary>
        private void ApplySyncfusionTheme()
        {
            SfSkinManager.ApplyThemeAsDefaultStyle = true;
            try
            {
                using var fluentDark = new Theme("FluentDark");
                SfSkinManager.SetTheme(this, fluentDark);
                Logger.Information("FluentDark theme applied to {ViewName}", GetType().Name);
            }
            catch
            {
                try
                {
                    using var fluentLight = new Theme("FluentLight");
                    SfSkinManager.SetTheme(this, fluentLight);
                    Logger.Information("Fallback to FluentLight theme for {ViewName}", GetType().Name);
                }
                catch
                {
                    // Continue without theme if both fail
                }
            }
        }

    // Unloaded/Dispose implemented later in file with full dispose pattern

    /// <summary>
    /// Handles map layer SelectionChanged from ComboBoxAdv with debouncing to prevent rapid API calls.
    /// Sender is expected to be Syncfusion ComboBoxAdv with ComboBoxItemAdv items.
    /// </summary>
        private void MapLayerComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            var correlationId = Guid.NewGuid().ToString("N")[..8];

            using (LogContext.PushProperty("UserInteraction", "MapLayerChange"))
            using (LogContext.PushProperty("CorrelationId", correlationId))
            {
                try
                {
                    if (DataContext is not GoogleEarthViewModel viewModel)
                    {
                        Logger.Warning("ViewModel not available for layer change operation");
                        return;
                    }

                    // ComboBoxAdv from Syncfusion raises SelectionChanged; validate sender and selected item types
                    if (sender is not Syncfusion.Windows.Tools.Controls.ComboBoxAdv comboBox ||
                        comboBox.SelectedItem is not Syncfusion.Windows.Tools.Controls.ComboBoxItemAdv selectedItem)
                    {
                        Logger.Debug("No valid selection detected in layer combo box");
                        return;
                    }

                    var layerType = selectedItem.Content?.ToString();
                    if (string.IsNullOrEmpty(layerType))
                    {
                        Logger.Warning("Selected layer type is null or empty");
                        return;
                    }

                    Logger.Debug("Layer change request received: {LayerType} (will be debounced)", layerType);

                    // Store the pending layer type and restart the debounce timer
                    lock (_layerChangeLock)
                    {
                        _pendingLayerType = layerType;
                        _layerChangeDebounceTimer.Change(LayerChangeDebounceDelayMs, Timeout.Infinite);
                    }
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Failed to process layer change request: {ErrorMessage} (CorrelationId: {CorrelationId})",
                               ex.Message, correlationId);

                    // Could add user notification here if needed
                    // ShowUserFriendlyError("Failed to change map layer. Please try again.");
                }
            }
        }

    /// <summary>
    /// Applies pending layer change after debounce delay on a background thread, then marshals to UI thread.
    /// </summary>
        private async void OnLayerChangeDebounceElapsed(object? state)
        {
            string? layerTypeToApply;

            // Get the pending layer type safely
            lock (_layerChangeLock)
            {
                layerTypeToApply = _pendingLayerType;
                _pendingLayerType = null;
            }

            if (string.IsNullOrEmpty(layerTypeToApply))
            {
                return;
            }


            var correlationId = Guid.NewGuid().ToString("N")[..8];

            using (LogContext.PushProperty("BackgroundOperation", "DebouncedLayerChange"))
            using (LogContext.PushProperty("CorrelationId", correlationId))
            using (LogContext.PushProperty("LayerType", layerTypeToApply))
            {
                var stopwatch = System.Diagnostics.Stopwatch.StartNew();

                try
                {
                    Logger.Information("Executing debounced layer change to: {LayerType}", layerTypeToApply);

                    // Execute on UI thread — map layer updates must run on UI thread
                    await Dispatcher.InvokeAsync(() =>
                    {
                        using (LogContext.PushProperty("ThreadType", "UI"))
                        {
                            Logger.Debug("Applying geospatial layer change on UI thread");
                            InitializeMapLayer(layerTypeToApply!);
                        }
                    });

                    stopwatch.Stop();
                    Logger.Information("Layer change completed successfully in {ElapsedMs}ms", stopwatch.ElapsedMilliseconds);
                }
                catch (Exception ex)
                {
                    stopwatch.Stop();
                    Logger.Error(ex, "Failed to execute debounced layer change: {ErrorMessage} (Elapsed: {ElapsedMs}ms)",
                               ex.Message, stopwatch.ElapsedMilliseconds);
                }
            }
        }

    // Creates and applies a layer to SfMap per Syncfusion Maps docs
        private void InitializeMapLayer(string layerType)
        {
            try
            {
                using (LogContext.PushProperty("ApplyLayer", layerType))
                {
                    if (MapControl is null)
                    {
                        Logger.Warning("SfMap control not found in view");
                        return;
                    }

                    // Replace only the base imagery layer while preserving overlays like district boundary
                    RemoveBaseImageryLayer();
                    var newLayer = GetOrCreateLayer(layerType);

                    MapControl.Layers.Add(newLayer);
                    _currentLayer = newLayer;
                    Logger.Information("Applied map layer: {Layer}", layerType);

                    // Toggle OSM attribution visibility based on layer
                    ToggleOsmAttribution(string.Equals(layerType, "OpenStreetMap", StringComparison.OrdinalIgnoreCase));

                    // Re-apply overlays if toggled on
                    if (DataContext is GoogleEarthViewModel vm)
                    {
                        // Bind markers (students, school) to the active base layer
                        try
                        {
                            if (newLayer is ImageryLayer imagery)
                            {
                                imagery.Markers = vm.MapMarkers;
                                // Try to apply marker template if present in XAML resources
                                if (this.TryFindResource("StudentMarkerTemplate") is System.Windows.DataTemplate template)
                                {
                                    imagery.MarkerTemplate = template;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            Logger.Warning(ex, "Failed to bind markers to imagery layer");
                        }
                        if (vm.DistrictBoundaryVisible)
                        {
                            ApplyDistrictBoundaryVisibility(true);
                        }
                        if (vm.TownBoundaryVisible)
                        {
                            ApplyTownBoundaryVisibility(true);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Error(ex, "Failed to initialize map layer: {LayerType}", layerType);
            }
        }

        // Remove only the current base imagery layer from GeoMap.Layers
        private void RemoveBaseImageryLayer()
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }
                if (_currentLayer is not null && MapControl.Layers.Contains(_currentLayer))
                {
                    MapControl.Layers.Remove(_currentLayer);
                    _currentLayer = null;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to remove base imagery layer");
            }
        }

    // Returns a cached layer or creates and caches one for reuse; avoids repeated allocations and CA2000 concerns
        private MapLayer GetOrCreateLayer(string layerType)
        {
            if (_layerCache.TryGetValue(layerType, out var existing))
            {
                return existing;
            }

            MapLayer created;
            var key = layerType.ToLowerInvariant();

            switch (key)
            {
                case "satellite":
                    created = new DynamicGoogleImageryLayer("s");
                    break;
                case "terrain":
                    created = new DynamicGoogleImageryLayer("t");
                    break;
                case "roadmap":
                    created = new DynamicGoogleImageryLayer("m");
                    break;
                case "openstreetmap":
                    created = new OpenStreetMapLayer();
                    break;
                case "hybrid":
                default:
                    created = new DynamicGoogleImageryLayer("y");
                    break;
            }

            _layerCache[layerType] = created;
            return created;
        }

    // Pre-create commonly used layers to improve first-use responsiveness
    private void PrewarmLayers()
        {
            try
            {
                GetOrCreateLayer("Satellite");
                GetOrCreateLayer("Terrain");
                GetOrCreateLayer("Hybrid");
                GetOrCreateLayer("Roadmap");
                GetOrCreateLayer("OpenStreetMap");
                Logger.Debug("Pre-warmed map layers cache");
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Error while pre-warming map layers");
            }
        }

    // Shows or hides the OSM attribution overlay based on active provider
    private void ToggleOsmAttribution(bool visible)
        {
            try
            {
                var overlay = this.FindName("OsmAttribution") as System.Windows.Controls.Border;
                if (overlay is not null)
                {
                    overlay.Visibility = visible ? System.Windows.Visibility.Visible : System.Windows.Visibility.Collapsed;
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to toggle OSM attribution overlay");
            }
        }

    // Simple helpers for map view manipulation
        private void TryResetView()
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }
                // Optional: set initial view using Syncfusion-documented API (deferred until verified)
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to reset map view");
            }
        }

        // Basic backend connectivity check — verifies DbContext can connect if registered
        private async Task CheckBackendConnectivityAsync()
        {
            try
            {
                var sp = BusBuddy.WPF.App.ServiceProvider;
                if (sp is null)
                {
                    Logger.Debug("ServiceProvider not initialized — skipping backend connectivity check");
                    return;
                }

                using var scope = sp.CreateScope();
                var contextFactory = scope.ServiceProvider.GetService<IBusBuddyDbContextFactory>();
                if (contextFactory is null)
                {
                    Logger.Debug("IBusBuddyDbContextFactory not available — skipping DB connectivity check");
                    return;
                }

                using var context = contextFactory.CreateDbContext();
                var canConnect = await context.Database.CanConnectAsync();
                Logger.Information("Database connectivity check from GoogleEarthView: {CanConnect}", canConnect);
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Backend connectivity check failed");
            }
        }

    // Wrapper to allow dynamic Google imagery style per KB pattern while adhering to ImageryLayer API
        private sealed class DynamicGoogleImageryLayer : ImageryLayer
        {
            private readonly string _mode;
            public DynamicGoogleImageryLayer(string mode)
            {
                _mode = mode;
            }
            protected override string GetUri(int x, int y, int scale)
            {
                return $"http://mt1.google.com/vt/lyrs={_mode}&x={x}&y={y}&z={scale}";
            }
        }

    /// <summary>
    /// Handles DataContext changes to wire up ViewModel events — validates types and initializes background work.
    /// </summary>
        private void OnDataContextChanged(object sender, System.Windows.DependencyPropertyChangedEventArgs e)
        {
            var correlationId = Guid.NewGuid().ToString("N")[..8];

            using (LogContext.PushProperty("ViewModelBinding", "GoogleEarthViewModel"))
            using (LogContext.PushProperty("CorrelationId", correlationId))
            {
                try
                {
                    // Cleanup old ViewModel if needed
                    if (e.OldValue is GoogleEarthViewModel oldViewModel)
                    {
                        Logger.Debug("Cleaning up previous ViewModel binding");
                        try
                        {
                            oldViewModel.PropertyChanged -= ViewModelOnPropertyChanged;
                            oldViewModel.RouteLineUpdated -= OnRouteLineUpdated;
                            oldViewModel.PrintRequested -= OnPrintRequested;
                        }
                        catch (Exception ex)
                        {
                            Logger.Warning(ex, "Error while detaching from previous ViewModel events");
                        }
                    }

                    if (e.NewValue is GoogleEarthViewModel newViewModel)
                    {
                        Logger.Information("Google Earth view model connected successfully");
                        newViewModel.ZoomInRequested += (_, _) => Dispatcher.Invoke(() => ApplyZoom(+1));
                        newViewModel.ZoomOutRequested += (_, _) => Dispatcher.Invoke(() => ApplyZoom(-1));
                        newViewModel.CenterRequested += (_, _) => Dispatcher.Invoke(CenterOnCurrentMarkers);
                        // Wire up any additional ViewModel events or initialize background operations
                        Task.Run(async () =>
                        {
                            using (LogContext.PushProperty("BackgroundOperation", "ViewModelInitialization"))
                            {
                                try
                                {
                                    Logger.Debug("Initializing background ViewModel operations");

                                    // Perform any heavy initialization operations here
                                    await Task.Delay(100); // Placeholder for actual initialization

                                    // Bind to overlay visibility changes
                                    Dispatcher.Invoke(() =>
                                    {
                                        ApplyDistrictBoundaryVisibility(newViewModel.DistrictBoundaryVisible);
                                        ApplyTownBoundaryVisibility(newViewModel.TownBoundaryVisible);
                                        // Subscribe to route line updates and print requests
                                        newViewModel.RouteLineUpdated += OnRouteLineUpdated;
                                        newViewModel.PrintRequested += OnPrintRequested;
                                    });
                                    newViewModel.PropertyChanged += ViewModelOnPropertyChanged;

                                    Logger.Debug("Background ViewModel initialization completed");
                                }
                                catch (Exception ex)
                                {
                                    Logger.Error(ex, "Failed during background ViewModel initialization");
                                }
                            }
                        });
                    }
                    else if (e.NewValue != null)
                    {
                        Logger.Warning("DataContext is not of expected GoogleEarthViewModel type: {ActualType}",
                                     e.NewValue.GetType().Name);
                    }
                    else
                    {
                        Logger.Debug("DataContext set to null");
                    }
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Failed to handle DataContext change: {ErrorMessage}", ex.Message);
                }
            }
        }

        private void OnRouteLineUpdated(object? sender, GoogleEarthViewModel.RouteLineEventArgs e)
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }

                // Ensure sub-layer and polyline exist
                if (_routeSubLayer is null)
                {
                    _routeSubLayer = new SubShapeFileLayer();
                    if (_currentLayer is ImageryLayer imagery)
                    {
                        imagery.SubShapeFileLayers.Add(_routeSubLayer);
                    }
                    else
                    {
                        // Fallback: add as top-level layer if imagery unavailable
                        MapControl.Layers.Add(_routeSubLayer);
                    }
                }
                if (_routePolyline is null)
                {
                    _routePolyline = new MapPolyline
                    {
                        Stroke = System.Windows.Media.Brushes.Gold,
                        StrokeThickness = 3
                    };
                    _routeSubLayer.MapElements.Add(_routePolyline);
                }

                // Replace points
                _routePolyline.Points = new System.Collections.ObjectModel.ObservableCollection<Point>(e.Points);
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed updating route polyline");
            }
        }

        private void OnPrintRequested(object? sender, EventArgs e)
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }

                if (MapControl is not System.Windows.FrameworkElement mapElement)
                {
                    return;
                }

                var printDlg = new System.Windows.Controls.PrintDialog();
                if (printDlg.ShowDialog() != true)
                {
                    return;
                }

                var doc = new FixedDocument();
                doc.DocumentPaginator.PageSize = new Size(printDlg.PrintableAreaWidth, printDlg.PrintableAreaHeight);

                var pageContent = new PageContent();
                var fixedPage = new FixedPage
                {
                    Width = printDlg.PrintableAreaWidth,
                    Height = printDlg.PrintableAreaHeight
                };

                var rect = new System.Windows.Shapes.Rectangle
                {
                    Width = fixedPage.Width,
                    Height = fixedPage.Height * 0.8,
                    Fill = new VisualBrush(mapElement)
                };
                FixedPage.SetLeft(rect, 0);
                FixedPage.SetTop(rect, 0);
                fixedPage.Children.Add(rect);

                var caption = new System.Windows.Controls.TextBlock
                {
                    Text = "Route map printout",
                    Margin = new Thickness(24, fixedPage.Height * 0.82, 24, 24),
                    FontSize = 16
                };
                fixedPage.Children.Add(caption);

                ((IAddChild)pageContent).AddChild(fixedPage);
                doc.Pages.Add(pageContent);

                printDlg.PrintDocument(doc.DocumentPaginator, "BusBuddy Route Map");

                // New: Use ViewModel snapshot helper for consistency
                if (DataContext is GoogleEarthViewModel vm)
                {
                    vm.CaptureMapSnapshot(mapElement);
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to print route map");
            }
        }

        /// <summary>
        /// Captures a PNG snapshot of the current map visual and stores it in the ViewModel's LatestMapSnapshotPng.
        /// Uses RenderTargetBitmap (Microsoft WPF imaging docs) and PngBitmapEncoder (official .NET imaging API).
        /// </summary>
        private void TryCaptureMapSnapshot()
        {
            try
            {
                if (MapControl is not FrameworkElement mapElement)
                {
                    return;
                }
                if (DataContext is not GoogleEarthViewModel vm)
                {
                    return;
                }

                var width = (int)Math.Ceiling(mapElement.ActualWidth);
                var height = (int)Math.Ceiling(mapElement.ActualHeight);
                if (width <= 0 || height <= 0)
                {
                    return;
                }

                // Render at 96 DPI (standard) — can be increased later for higher resolution
                var rtb = new RenderTargetBitmap(width, height, 96, 96, PixelFormats.Pbgra32);
                rtb.Render(mapElement);

                var encoder = new PngBitmapEncoder();
                encoder.Frames.Add(BitmapFrame.Create(rtb));
                using var ms = new MemoryStream();
                encoder.Save(ms);
                vm.LatestMapSnapshotPng = ms.ToArray();
                Logger.Information("Captured map snapshot PNG ({Bytes} bytes) for PDF embedding", vm.LatestMapSnapshotPng.Length);
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Map snapshot capture failed");
            }
        }

        private void ViewModelOnPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
        {
            if (sender is not GoogleEarthViewModel vm)
            {
                return;
            }
            if (e.PropertyName == nameof(GoogleEarthViewModel.DistrictBoundaryVisible))
            {
                Dispatcher.Invoke(() => ApplyDistrictBoundaryVisibility(vm.DistrictBoundaryVisible));
            }
            else if (e.PropertyName == nameof(GoogleEarthViewModel.TownBoundaryVisible))
            {
                Dispatcher.Invoke(() => ApplyTownBoundaryVisibility(vm.TownBoundaryVisible));
            }
        }

        // Creates or removes the district boundary overlay ShapeFileLayer
        private void ApplyDistrictBoundaryVisibility(bool visible)
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }

                if (visible)
                {
                    if (_districtBoundaryLayer is null)
                    {
                        // Use file-based Uri matching csproj CopyToOutputDirectory rules
                        var districtPath = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Assets", "Maps", "WileyDistrict", "WileyDistrict.shp");
                        if (!System.IO.File.Exists(districtPath))
                        {
                            Logger.Warning("District shapefile not found at {Path}. Place WileyDistrict.shp/.dbf/.shx under Assets/Maps/WileyDistrict.", districtPath);
                        }
                        _districtBoundaryLayer = new ShapeFileLayer
                        {
                            Uri = "Assets/Maps/WileyDistrict/WileyDistrict.shp",
                            MapItemsVisibility = System.Windows.Visibility.Collapsed,
                            ShapeSettings = new ShapeSetting
                            {
                                ShapeFill = System.Windows.Media.Brushes.Transparent,
                                ShapeStroke = System.Windows.Media.Brushes.OrangeRed,
                                ShapeStrokeThickness = 2d
                            }
                        };
                    }

                    if (!_districtBoundaryAdded)
                    {
                        MapControl.Layers.Add(_districtBoundaryLayer);
                        _districtBoundaryAdded = true;
                        Logger.Information("District boundary overlay added to map");
                    }
                }
                else
                {
                    if (_districtBoundaryLayer is not null && _districtBoundaryAdded)
                    {
                        MapControl.Layers.Remove(_districtBoundaryLayer);
                        _districtBoundaryAdded = false;
                        Logger.Information("District boundary overlay removed from map");
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to apply district boundary visibility");
            }
        }

        // Creates or removes the town boundary overlay ShapeFileLayer (Wiley town limits)
        private void ApplyTownBoundaryVisibility(bool visible)
        {
            try
            {
                if (MapControl is null)
                {
                    return;
                }

                if (visible)
                {
                    if (_townBoundaryLayer is null)
                    {
                        var townPath = System.IO.Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Assets", "Maps", "WileyTown", "WileyTown.shp");
                        if (!System.IO.File.Exists(townPath))
                        {
                            Logger.Warning("Town shapefile not found at {Path}. Place WileyTown.shp/.dbf/.shx under Assets/Maps/WileyTown.", townPath);
                        }
                        _townBoundaryLayer = new ShapeFileLayer
                        {
                            Uri = "Assets/Maps/WileyTown/WileyTown.shp",
                            MapItemsVisibility = System.Windows.Visibility.Collapsed,
                            ShapeSettings = new ShapeSetting
                            {
                                ShapeFill = System.Windows.Media.Brushes.Transparent,
                                ShapeStroke = System.Windows.Media.Brushes.DodgerBlue,
                                ShapeStrokeThickness = 2d
                            }
                        };
                    }

                    if (!_townBoundaryAdded)
                    {
                        MapControl.Layers.Add(_townBoundaryLayer);
                        _townBoundaryAdded = true;
                        Logger.Information("Town boundary overlay added to map");
                    }
                }
                else
                {
                    if (_townBoundaryLayer is not null && _townBoundaryAdded)
                    {
                        MapControl.Layers.Remove(_townBoundaryLayer);
                        _townBoundaryAdded = false;
                        Logger.Information("Town boundary overlay removed from map");
                    }
                }
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "Failed to apply town boundary visibility");
            }
        }

    /// <summary>
    /// OnInitialized — subscribes to DataContextChanged and completes view initialization.
    /// </summary>
        protected override void OnInitialized(EventArgs e)
        {
            using (LogContext.PushProperty("ViewLifecycle", "Initialization"))
            {
                try
                {
                    base.OnInitialized(e);
                    DataContextChanged += OnDataContextChanged;

                    Logger.Debug("GoogleEarthView initialization completed successfully");
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Failed during GoogleEarthView initialization");
                    throw; // Re-throw to allow proper error handling upstream
                }
            }
        }

    /// <summary>
    /// Cleanup resources when the view is being disposed
    /// </summary>
        private void GoogleEarthView_Unloaded(object sender, System.Windows.RoutedEventArgs e)
        {
            using (LogContext.PushProperty("ViewLifecycle", "Unloaded"))
            {
                Logger.Debug("GoogleEarthView unloaded, disposing resources");
                Dispose();
            }
        }

    /// <summary>
    /// Dispose pattern implementation
    /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

    /// <summary>
    /// Protected dispose method
    /// </summary>
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed && disposing)
            {
                try
                {
                    _layerChangeDebounceTimer?.Dispose();
                    DataContextChanged -= OnDataContextChanged;
                    this.Unloaded -= GoogleEarthView_Unloaded;
                    try
                    {
                        // Dispose Syncfusion skin resources
                        SfSkinManager.Dispose(this);
                    }
                    catch (Exception ex)
                    {
                        Logger.Warning(ex, "Failed to dispose SfSkinManager resources for {ViewName}", GetType().Name);
                    }
                    try
                    {
                        // Clear map layers and dispose cached layers
                        if (MapControl is not null)
                        {
                            MapControl.Layers.Clear();
                        }
                        foreach (var layer in _layerCache.Values)
                        {
                            (layer as IDisposable)?.Dispose();
                        }
                        _layerCache.Clear();
                    }
                    catch (Exception ex)
                    {
                        Logger.Warning(ex, "Error while disposing cached map layers");
                    }
                    Logger.Debug("GoogleEarthView resources disposed successfully");
                }
                catch (Exception ex)
                {
                    Logger.Error(ex, "Error during GoogleEarthView disposal");
                }
                finally
                {
                    _disposed = true;
                }
            }
        }

        private void ApplyZoom(int delta)
        {
            try
            {
                if (MapControl is null) return;
                var current = MapControl.ZoomLevel; // documented property on SfMap
                var target = current + delta;
                if (target < 1) target = 1;
                if (target > 18) target = 18; // practical upper bound for tile providers
                MapControl.ZoomLevel = target;
                Logger.Debug("Map zoom changed from {Old} to {New}", current, target);
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "ApplyZoom failed");
            }
        }

        private void CenterOnCurrentMarkers()
        {
            try
            {
                if (MapControl is null) return;
                if (DataContext is not GoogleEarthViewModel vm) return;
                if (vm.MapMarkers.Count == 0) return;
                double minLat = double.MaxValue, maxLat = double.MinValue, minLon = double.MaxValue, maxLon = double.MinValue;
                foreach (var mk in vm.MapMarkers)
                {
                    if (mk.Latitude < minLat) minLat = mk.Latitude;
                    if (mk.Latitude > maxLat) maxLat = mk.Latitude;
                    if (mk.Longitude < minLon) minLon = mk.Longitude;
                    if (mk.Longitude > maxLon) maxLon = mk.Longitude;
                }
                var centerLat = (minLat + maxLat) / 2d;
                var centerLon = (minLon + maxLon) / 2d;
                // TODO: Implement centering logic using supported SfMap API (e.g., setting GeoCoordinate/Viewport once verified in docs)
                Logger.Debug("Computed centroid for potential centering {Lat},{Lon} (API pending)", centerLat, centerLon);
            }
            catch (Exception ex)
            {
                Logger.Warning(ex, "CenterOnCurrentMarkers failed");
            }
        }
    }
}
