RepoRoot: C:\Users\biges\Desktop\BusBuddy
PowerShell: 7.5.2
Report directory: C:\Users\biges\Desktop\BusBuddy\Documentation\Reports
Invoking profile loader: C:\Users\biges\Desktop\BusBuddy\PowerShell\Profiles\Import-BusBuddyModule.ps1
Generated transient Mantra ID: 56a6993a
BusBuddy module initialized (bb-* commands available).
Verifying expected bb* aliases.
Missing aliases: bbMvpCheck, bbAntiRegression, bbXamlValidate, bbRefresh, bbTestWatch, bbTestReport
Verifying BusBuddy modules present in session.
Loaded: BusBuddy v2.0.0
Alias targets detected:
  bbCommands -> Get-BusBuddyCommand
  bbDevSession -> Start-BusBuddyDevSession
  bbRun -> Invoke-BusBuddyRun
  bbBuild -> Invoke-BusBuddyBuild
  bbTest -> Invoke-BusBuddyTest
  bbHealth -> Invoke-BusBuddyHealthCheck
Running ScriptAnalyzer (PSAvoidEmptyCatchBlock, PSUseShouldProcess, PSAvoidUsingWriteHost).
Analyzer findings - EmptyCatch:0 ShouldProcess:0 Write-Host:302
Full analyzer report: C:\Users\biges\Desktop\BusBuddy\Documentation\Reports\PSScriptAnalyzerReport-Diag.txt
Logging conflict scan written to: C:\Users\biges\Desktop\BusBuddy\Documentation\Reports\LoggingConflicts-Diag.txt
Summary:
[33;1mWARNING: Resulting JSON is truncated as serialization has exceeded the set depth of 5.[0m
{
  "ModulesLoaded": "BusBuddy",
  "AnalyzerReport": true,
  "LoggingPath": "C:\\Users\\biges\\Desktop\\BusBuddy\\Documentation\\Reports\\LoggingConflicts-Diag.txt",
  "RepoRoot": "C:\\Users\\biges\\Desktop\\BusBuddy",
  "AnalyzerPath": "C:\\Users\\biges\\Desktop\\BusBuddy\\Documentation\\Reports\\PSScriptAnalyzerReport-Diag.txt",
  "LoggingConflicts": {
    "Microsoft.Extensions.Logging": {
      "OccurrenceCount": 0,
      "Files": null
    },
    "Microsoft.ApplicationInsights": {
      "OccurrenceCount": 0,
      "Files": null
    },
    "ApplicationInsights": {
      "OccurrenceCount": 0,
      "Files": null
    },
    "Serilog": {
      "OccurrenceCount": 33,
      "Files": [
        "C:\\Users\\biges\\Desktop\\BusBuddy\\BusBuddy.Tests\\WileyTests.cs",
        "C:\\Users\\biges\\Desktop\\BusBuddy\\BusBuddy.WPF\\App.xaml.cs",
        "C:\\Users\\biges\\Desktop\\BusBuddy\\Examples\\RouteAssignmentExample.cs",
        "C:\\Users\\biges\\Desktop\\BusBuddy\\TestDataSeeding\\Program.cs"
      ]
    }
  },
  "LoggingReport": true,
  "AliasTargets": [
    {
      "Definition": "Get-BusBuddyCommand",
      "Name": "bbCommands",
      "Options": "None",
      "Module": {
        "LogPipelineExecutionDetails": false,
        "Name": "BusBuddy",
        "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
        "ImplementingAssembly": null,
        "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
        "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
        "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
        "HelpInfoUri": null,
        "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
        "PrivateData": {
          "PSData": {
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "Tags": "BusBuddy Development WPF DotNet"
          }
        },
        "ExperimentalFeatures": [],
        "Tags": [
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet",
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet"
        ],
        "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
        "IconUri": null,
        "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
        "ReleaseNotes": "Streamlined core module for reliable development workflow",
        "RepositorySourceLocation": null,
        "Version": {
          "Major": 2,
          "Minor": 0,
          "Build": 0,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ModuleType": 0,
        "Author": "Bus Buddy Development Team",
        "AccessMode": 0,
        "ClrVersion": null,
        "CompanyName": "BusBuddy Team",
        "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
        "DotNetFrameworkVersion": null,
        "ExportedFunctions": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          }
        },
        "Prefix": "",
        "ExportedCmdlets": {},
        "ExportedCommands": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "FileList": [
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1"
        ],
        "CompatiblePSEditions": [
          "Core"
        ],
        "ModuleList": [],
        "NestedModules": [
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.BuildOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "# Enhanced Build Commands with No Truncation\n# Part of BusBuddy PowerShell Module\n\n#region Enhanced Build Functions\n\nfunction Get-BusBuddyBuildOutput {\n    <#\n    .SYNOPSIS\n        Get complete build output without truncation\n\n    .DESCRIPTION\n        Captures full dotnet build output to both console and file, preventing truncation issues\n\n    .PARAMETER ProjectPath\n        Path to solution or project file\n\n    .PARAMETER Configuration\n        Build configuration (Debug/Release)\n\n    .PARAMETER SaveToFile\n        Save complete output to timestamped file\n\n    .EXAMPLE\n        Get-BusBuddyBuildOutput -SaveToFile\n    #>\n    [CmdletBinding()]\n    param(\n        [string]$ProjectPath = \"BusBuddy.sln\",\n        [string]$Configuration = \"Debug\",\n        [switch]$SaveToFile,\n        [switch]$ErrorsOnly\n    )\n\n    $timestamp = Get-Date -Format \"yyyyMMdd-HHmmss\"\n    $outputFile = \"logs\\build-output-$timestamp.log\"\n\n    # Ensure logs directory exists\n    if (-not (Test-Path \"logs\")) {\n        New-Item -ItemType Directory -Path \"logs\" -Force | Out-Null\n    }\n\n    Write-Host \"??? Building $ProjectPath...\" -ForegroundColor Cyan\n    Write-Host \"?? Configuration: $Configuration\" -ForegroundColor Gray\n\n    if ($SaveToFile) {\n        Write-Host \"?? Full output will be saved to: $outputFile\" -ForegroundColor Yellow\n    }\n\n    # Configure environment for maximum output\n    $env:DOTNET_CLI_UI_LANGUAGE = \"en-US\"\n    $env:DOTNET_NOLOGO = \"false\"  # We want full output\n\n    try {\n        # Capture all output streams with detailed verbosity\n        $verbosity = if ($ErrorsOnly) { \"quiet\" } else { \"detailed\" }\n\n        $startTime = Get-Date\n\n        # Use Start-Process for complete output capture\n        $processInfo = @{\n            FilePath = \"dotnet\"\n            ArgumentList = @(\"build\", $ProjectPath, \"--configuration\", $Configuration, \"--verbosity\", $verbosity, \"--no-restore\")\n            RedirectStandardOutput = $true\n            RedirectStandardError = $true\n            UseShellExecute = $false\n            CreateNoWindow = $true\n        }\n\n        $process = Start-Process @processInfo -PassThru\n\n        # Read output in real-time\n        $stdout = $process.StandardOutput.ReadToEnd()\n        $stderr = $process.StandardError.ReadToEnd()\n\n        $process.WaitForExit()\n        $exitCode = $process.ExitCode\n\n        $endTime = Get-Date\n        $duration = $endTime - $startTime\n\n        # Combine all output\n        $fullOutput = @\"\n=== BUSBUDDY BUILD LOG ===\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\nProject: $ProjectPath\nConfiguration: $Configuration\nDuration: $($duration.TotalSeconds) seconds\nExit Code: $exitCode\n\n=== STANDARD OUTPUT ===\n$stdout\n\n=== STANDARD ERROR ===\n$stderr\n\n=== BUILD SUMMARY ===\n\"@\n\n        # Save to file if requested\n        if ($SaveToFile) {\n            $fullOutput | Out-File -FilePath $outputFile -Encoding UTF8 -Width 500\n            Write-Host \"? Complete build log saved to: $outputFile\" -ForegroundColor Green\n        }\n\n        # Parse and display errors prominently\n        $errorLines = ($stdout + $stderr) -split \"`n\" | Where-Object { $_ -match \"error|Error|ERROR|\\s+CS\\d+|\\s+MSB\\d+\" }\n\n        if ($errorLines) {\n            Write-Host \"`n? BUILD ERRORS FOUND:\" -ForegroundColor Red\n            Write-Host \"=\" * 50 -ForegroundColor Red\n            $errorLines | ForEach-Object {\n                Write-Host $_ -ForegroundColor Red\n            }\n            Write-Host \"=\" * 50 -ForegroundColor Red\n\n            if ($SaveToFile) {\n                Write-Host \"?? Full details in: $outputFile\" -ForegroundColor Yellow\n            }\n        } else {\n            Write-Host \"? No errors found!\" -ForegroundColor Green\n        }\n\n        # Display summary\n        Write-Host \"`n?? BUILD SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"   Duration: $($duration.TotalSeconds) seconds\" -ForegroundColor Gray\n        Write-Host \"   Exit Code: $exitCode\" -ForegroundColor $(if ($exitCode -eq 0) { \"Green\" } else { \"Red\" })\n\n        if ($exitCode -eq 0) {\n            Write-Host \"   Status: SUCCESS ?\" -ForegroundColor Green\n        } else {\n            Write-Host \"   Status: FAILED ?\" -ForegroundColor Red\n        }\n\n        return @{\n            ExitCode = $exitCode\n            Duration = $duration\n            ErrorLines = $errorLines\n            OutputFile = if ($SaveToFile) { $outputFile } else { $null }\n            FullOutput = $fullOutput\n        }\n\n    } catch {\n        Write-Error \"Failed to execute build: $($_.Exception.Message)\"\n        return $null\n    }\n}\n\nfunction Start-BusBuddyBuildFull {\n    <#\n    .SYNOPSIS\n        Enhanced bb-build with complete output capture\n    #>\n    Get-BusBuddyBuildOutput -SaveToFile\n}\n\nfunction Get-BusBuddyBuildErrors {\n    <#\n    .SYNOPSIS\n        Get only build errors without full output\n    #>\n    Get-BusBuddyBuildOutput -ErrorsOnly\n}\n\nfunction Show-BusBuddyBuildLog {\n    <#\n    .SYNOPSIS\n        Show the most recent build log\n    #>\n    $latestLog = Get-ChildItem \"logs\\build-output-*.log\" | Sort-Object LastWriteTime -Descending | Select-Object -First 1\n\n    if ($latestLog) {\n        Write-Host \"?? Most recent build log: $($latestLog.Name)\" -ForegroundColor Cyan\n        Write-Host \"?? Created: $($latestLog.LastWriteTime)\" -ForegroundColor Gray\n        Write-Host \"\"\n        Get-Content $latestLog.FullName\n    } else {\n        Write-Host \"No build logs found. Run Start-BusBuddyBuildFull first.\" -ForegroundColor Yellow\n    }\n}\n\n#endregion\n\n# Export functions\nExport-ModuleMember -Function Get-BusBuddyBuildOutput, Start-BusBuddyBuildFull, Get-BusBuddyBuildErrors, Show-BusBuddyBuildLog\n",
            "Description": "Enhanced build output capture for BusBuddy - eliminates truncated terminal output",
            "Guid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Build Output Capture NoTruncation BusBuddy Build Output Capture NoTruncation",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": "v1.0.0 - Initial release\n- Complete build output capture without truncation\n- Automatic error parsing and highlighting\n- Timestamped log file generation\n- Enhanced terminal buffer configuration",
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Project",
            "Copyright": "(c) 2025 BusBuddy Project. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.BuildOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\nSet-StrictMode -Version 3.0\r\n\r\n# Avoid auto-executing on import - provide wrapper to run the script when requested\r\n$moduleRoot = Split-Path -Parent $PSScriptRoot\r\n$workspaceRoot = Split-Path -Parent (Split-Path -Parent $moduleRoot)\r\n$enhancedTestPath = Join-Path $workspaceRoot 'PowerShell\\Scripts\\Enhanced-Test-Output.ps1'\r\n\r\nfunction Invoke-BusBuddyEnhancedTestOutput {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromRemainingArguments = $true)]\r\n        [object[]] $Args\r\n    )\r\n    if (-not (Test-Path -LiteralPath $enhancedTestPath)) {\r\n        Write-Error \"Enhanced-Test-Output.ps1 not found at: $enhancedTestPath\"\r\n        return\r\n    }\r\n    & $enhancedTestPath @Args\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyEnhancedTestOutput\r\n",
            "Description": "",
            "Guid": "7c6a0d9e-1f2a-4b9e-b5a2-1c5f5d5b8a1c",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy",
            "Copyright": "(c) BusBuddy",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.TestOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.ThemeValidation",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation\\BusBuddy.ThemeValidation.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.ThemeValidation Module\r\n# Validates Syncfusion theme/style consistency across WPF XAML files.\r\n# Docs reference: https://help.syncfusion.com/wpf/themes/overview\r\n\r\nfunction Test-BusBuddyThemeConsistency {\r\n    <#\r\n    .SYNOPSIS\r\n        Scan XAML views for inline Syncfusion control styling violations.\r\n    .DESCRIPTION\r\n        Looks for Syncfusion controls (SfDataGrid, ButtonAdv, DockingManager etc.)\r\n        with inline size/margin/brush properties that should be centralized in resource dictionaries.\r\n    .OUTPUTS\r\n        Hashtable with Issues (string[]) and Status (Success|Failed)\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views'\r\n    )\r\n    $issues = New-Object System.Collections.Generic.List[string]\r\n    if (-not (Test-Path $ViewsPath)) {\r\n        Write-Warning \"Views path not found: $ViewsPath\"\r\n        return @{ Issues = @('Views path missing'); Status = 'Failed' }\r\n    }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    $mergedDictionaries = @{}\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $mergeMatches = [regex]::Matches($content,'<ResourceDictionary\\s+Source=\"([^\"]+)\"')\r\n        foreach ($m in $mergeMatches) { $mergedDictionaries[$m.Groups[1].Value] = $true }\r\n        # Detect inline width/height/margin on Syncfusion ButtonAdv or SfButton / SfDataGrid\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)[^>]*(Width|Height|Margin)=') {\r\n            $issues.Add(\"Inline layout property on Syncfusion button in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:SfDataGrid[^>]*(RowHeight|HeaderRowHeight|Background|BorderBrush)=') {\r\n            $issues.Add(\"Inline SfDataGrid visual property in $($file.Name)\")\r\n        }\r\n        # Missing namespace check (should declare syncfusion namespace where controls appear)\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'xmlns:syncfusion=') {\r\n            $issues.Add(\"Missing syncfusion xmlns in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'FluentDark' -and $content -notmatch 'FluentLight') {\r\n            $issues.Add(\"Potential missing theme reference (FluentDark/FluentLight) in $($file.Name)\")\r\n        }\r\n    }\r\n    if (-not ($mergedDictionaries.Keys | Where-Object { $_ -match 'Themes' })) {\r\n        $issues.Add('No merged resource dictionaries referencing Themes folder detected')\r\n    }\r\n    $status = if ($issues.Count -gt 0) { 'Failed' } else { 'Success' }\r\n    return @{ Issues = $issues.ToArray(); Status = $status; FileCount = $xamlFiles.Count; MergedDictionaries = $mergedDictionaries.Keys }\r\n}\r\n\r\nfunction Invoke-BusBuddyThemeRemediation {\r\n    <#\r\n    .SYNOPSIS\r\n        Attempt automatic remediation of common inline styling issues.\r\n    .DESCRIPTION\r\n        Replaces common inline size/margin attributes on Syncfusion buttons with Style reference.\r\n        Only performs safe textual substitutions; more advanced refactoring deferred post-MVP.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views',\r\n        [string]$ButtonStyleKey = 'SyncfusionPrimaryButtonStyle'\r\n    )\r\n    if (-not (Test-Path $ViewsPath)) { Write-Warning \"Views path not found: $ViewsPath\"; return }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $original = $content\r\n        $modified = $false\r\n        # Replace inline width/height/margin on buttons with style if not already styled\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)' -and $content -notmatch 'Style=\"{StaticResource') {\r\n            $content = [regex]::Replace($content,'(<syncfusion:(?:ButtonAdv|SfButton)[^>]*)(Width|Height|Margin)=\"[^\"]+\"','${1}')\r\n            if ($content -ne $original) { $modified = $true }\r\n            if ($modified) {\r\n                $content = [regex]::Replace($content,'<syncfusion:(ButtonAdv|SfButton)([^>]*)>','<syncfusion:$1$2 Style=\"{StaticResource ' + $ButtonStyleKey + '}\">')\r\n            }\r\n        }\r\n        if ($modified -and $PSCmdlet.ShouldProcess($file.FullName,'Apply style remediation')) {\r\n            $content | Set-Content $file.FullName -Encoding UTF8\r\n            Write-Information \"Remediated: $($file.Name)\" -InformationAction Continue\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyThemeConsistency,Invoke-BusBuddyThemeRemediation\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.AzureSqlHealth",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth\\BusBuddy.AzureSqlHealth.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.AzureSqlHealth Module\r\n# References: https://learn.microsoft.com/azure/azure-sql/database/connectivity-architecture\r\n\r\nfunction Test-BusBuddyAzureSql {\r\n    <#\r\n    .SYNOPSIS\r\n        Test connectivity to Azure SQL (fallback to LocalDB on failure).\r\n    .OUTPUTS\r\n        Bool indicating Azure SQL connectivity success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) {\r\n        Write-Warning \"Azure settings file not found: $SettingsPath\"\r\n        return $false\r\n    }\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 2\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n    $lastError = $null\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n            $connString = $json.ConnectionStrings.DefaultConnection\r\n            if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n            $query = 'SELECT TOP 1 name FROM sys.databases'\r\n            $result = Invoke-Sqlcmd -ConnectionString $connString -Query $query -ErrorAction Stop\r\n            $stopwatch.Stop()\r\n            Write-Information \"? Azure SQL reachable (attempt $attempts) latency=$([math]::Round($stopwatch.Elapsed.TotalMilliseconds,0))ms Databases: $($result.name -join ',')\" -InformationAction Continue\r\n            return $true\r\n        } catch {\r\n            $lastError = $_.Exception.Message\r\n            Write-Warning \"Attempt $attempts failed: $lastError\"\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds *= 2 }\r\n        }\r\n    }\r\n    $stopwatch.Stop()\r\n    Write-Warning \"?? Azure SQL test failed after $attempts attempts: $lastError\"\r\n    return $false\r\n}\r\n\r\nfunction Test-BusBuddyAzureSqlNative {\r\n    <#\r\n    .SYNOPSIS\r\n        Test Azure SQL connectivity using System.Data.SqlClient directly (no sqlcmd dependency).\r\n    .DESCRIPTION\r\n        Reads connection string from appsettings.azure.json (ConnectionStrings.DefaultConnection) and attempts to open a connection\r\n        and run a lightweight query. Implements simple retry with exponential backoff.\r\n        Docs: https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.open\r\n    .OUTPUTS\r\n        Bool indicating success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) { Write-Warning \"Azure settings file not found: $SettingsPath\"; return $false }\r\n    try {\r\n        $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n        $connString = $json.ConnectionStrings.DefaultConnection\r\n        if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n    } catch {\r\n        Write-Warning \"Failed to parse ${SettingsPath}: $($_.Exception.Message)\"; return $false\r\n    }\r\n\r\n    # Expand ${ENV_VAR} placeholders if present in connection string\r\n    # Pattern sourced from standard PowerShell regex usage - see Microsoft Docs: about_Regular_Expressions\r\n    $expandEnv = {\r\n        param([string]$s)\r\n        if ([string]::IsNullOrWhiteSpace($s)) { return $s }\r\n        return [regex]::Replace($s, '\\$\\{([A-Za-z0-9_]+)\\}', {\r\n            param($m)\r\n            $name = $m.Groups[1].Value\r\n            $val  = [Environment]::GetEnvironmentVariable($name)\r\n            if (-not $val) { $m.Value } else { $val }\r\n        })\r\n    }\r\n    $original = $connString\r\n    $connString = & $expandEnv $connString\r\n    if ($connString -match '\\$\\{') {\r\n        Write-Information \"?? One or more environment placeholders are unresolved in connection string (file=${SettingsPath}). Set required variables in the environment before running tests.\" -InformationAction Continue\r\n    }\r\n\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 1\r\n    $sw = [System.Diagnostics.Stopwatch]::StartNew()\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $conn = [System.Data.SqlClient.SqlConnection]::new($connString)\r\n            $conn.Open()\r\n            try {\r\n                $cmd = $conn.CreateCommand()\r\n                $cmd.CommandText = 'SELECT DB_NAME()'\r\n                $db = $cmd.ExecuteScalar()\r\n                $sw.Stop()\r\n                Write-Information (\"? Azure SQL (native) reachable on attempt {0} - DB: {1}, latency={2}ms\" -f $attempts, $db, [math]::Round($sw.Elapsed.TotalMilliseconds,0)) -InformationAction Continue\r\n                return $true\r\n            } finally {\r\n                $conn.Dispose()\r\n            }\r\n        } catch {\r\n            Write-Warning (\"Native attempt {0} failed: {1}\" -f $attempts, $_.Exception.Message)\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds = [Math]::Min($delaySeconds * 2, 8) }\r\n        }\r\n    }\r\n    $sw.Stop()\r\n    Write-Warning \"?? Azure SQL (native) test failed after $attempts attempts.\"\r\n    return $false\r\n}\r\n\r\nfunction Get-BusBuddySqlStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Provide detailed Azure SQL / LocalDB status summary.\r\n    .OUTPUTS\r\n        Hashtable with status fields.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$AzureSettingsPath = 'appsettings.azure.json',\r\n        [string]$LocalSettingsPath = 'appsettings.json'\r\n    )\r\n    $status = [ordered]@{}\r\n    $status.Timestamp = Get-Date\r\n    $status.AzureSettingsPresent = Test-Path $AzureSettingsPath\r\n    $status.LocalSettingsPresent = Test-Path $LocalSettingsPath\r\n    $status.AzureReachable = $false\r\n    $status.LocalDbReachable = $false\r\n\r\n    if ($status.AzureSettingsPresent) {\r\n        $status.AzureReachable = Test-BusBuddyAzureSql -SettingsPath $AzureSettingsPath\r\n    }\r\n    # LocalDB quick probe via sqlcmd if installed\r\n    try {\r\n        $localJson = if (Test-Path $LocalSettingsPath) { Get-Content $LocalSettingsPath -Raw | ConvertFrom-Json } else { $null }\r\n        $localConn = $localJson.ConnectionStrings.DefaultConnection\r\n        if ($localConn -and $localConn -match 'localdb') {\r\n            try {\r\n                Invoke-Sqlcmd -ConnectionString $localConn -Query 'SELECT 1' -ErrorAction Stop | Out-Null\r\n                $status.LocalDbReachable = $true\r\n            } catch {\r\n                $status.LocalDbReachable = $false\r\n            }\r\n        }\r\n    } catch {\r\n        $status.LocalDbReachable = $false\r\n    }\r\n\r\n    $status.PrimaryDataSource = if ($status.AzureReachable) { 'Azure' } elseif ($status.LocalDbReachable) { 'LocalDB' } else { 'Unknown' }\r\n    return $status\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyAzureSql,Test-BusBuddyAzureSqlNative,Get-BusBuddySqlStatus\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestWatcher",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher\\BusBuddy.TestWatcher.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.TestWatcher Module\r\n# Provides debounced file change watching to trigger targeted test runs.\r\n\r\nfunction Start-BusBuddyTestWatchAdvanced {\r\n    <#\r\n    .SYNOPSIS\r\n        Start debounced test watch loop for a specific test suite.\r\n    .DESCRIPTION\r\n        Watches for changes to .cs and .xaml files under repo root and re-runs Get-BusBuddyTestOutput.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite = 'Unit',\r\n        [int]$DebounceSeconds = 2,\r\n        [switch]$RetryOnFailure,\r\n        [int]$MaxRetries = 2,\r\n        [int]$RetryDelaySeconds = 2\r\n    )\r\n    if ($script:BusBuddyTestWatchHandle) { Write-Warning 'Test watch already running.'; return }\r\n    $root = Get-Location\r\n    Write-Information \"?? Watching $root for changes (suite=$TestSuite, debounce=${DebounceSeconds}s)\" -InformationAction Continue\r\n    $watcher = New-Object System.IO.FileSystemWatcher -Property @{ Path = $root; Filter = '*.*'; IncludeSubdirectories = $true; EnableRaisingEvents = $true }\r\n    $script:BusBuddyTestWatchLastRun = Get-Date 0\r\n    $script:BusBuddyTestWatchIgnored = 0\r\n    $script:BusBuddyTestWatchTriggered = 0\r\n    $script:BusBuddyTestWatchFailures = 0\r\n    $script:BusBuddyTestWatchRetries = 0\r\n    # Correlation ID for this watcher session\r\n    $script:BusBuddyTestWatchCorrelation = [guid]::NewGuid().ToString()\r\n    $action = {\r\n        $full = $Event.SourceEventArgs.FullPath\r\n        $ext = [IO.Path]::GetExtension($full)\r\n        if ($ext -notin '.cs','.xaml') {\r\n            Write-Verbose (\"Ignoring change due to unsupported extension: {0}\" -f $ext)\r\n            return\r\n        }\r\n        # Ignore build/test artifacts to avoid infinite loops (bin/obj/TestResults/.git/.vs)\r\n        if ($full -match \"(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\\") {\r\n            $script:BusBuddyTestWatchIgnored++\r\n            Write-Verbose (\"Ignoring change in excluded path: {0}\" -f $full)\r\n            return\r\n        }\r\n        $now = Get-Date\r\n        $elapsed = ($now - $script:BusBuddyTestWatchLastRun).TotalSeconds\r\n        if ($elapsed -lt $using:DebounceSeconds) {\r\n            $remaining = [math]::Max([int]([math]::Ceiling($using:DebounceSeconds - $elapsed)), 0)\r\n            Write-Verbose (\"Debounce active - event suppressed. Time remaining: {0}s\" -f $remaining)\r\n            return\r\n        }\r\n        $script:BusBuddyTestWatchLastRun = $now\r\n        $script:BusBuddyTestWatchTriggered++\r\n        Write-Information \"?? [$script:BusBuddyTestWatchCorrelation] Change detected: $($Event.SourceEventArgs.Name) -> running $using:TestSuite tests (trigger #$script:BusBuddyTestWatchTriggered, ignored so far=$script:BusBuddyTestWatchIgnored)\" -InformationAction Continue\r\n        try {\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n        } catch {\r\n            $script:BusBuddyTestWatchFailures++\r\n            Write-Warning \"[$script:BusBuddyTestWatchCorrelation] Test watch run failed (#$script:BusBuddyTestWatchFailures): $($_.Exception.Message)\"\r\n            if ($using:RetryOnFailure) {\r\n                $attempt = 0\r\n                $delay = [int]$using:RetryDelaySeconds\r\n                while ($attempt -lt [int]$using:MaxRetries) {\r\n                    $attempt++\r\n                    $script:BusBuddyTestWatchRetries++\r\n                    Write-Information (\"?? [$script:BusBuddyTestWatchCorrelation] Retry trigger #{0} (attempt {1}/{2}) after failure - waiting {3}s...\" -f $script:BusBuddyTestWatchRetries, $attempt, [int]$using:MaxRetries, $delay) -InformationAction Continue\r\n                    Start-Sleep -Seconds $delay\r\n                    try {\r\n                        Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n                        Write-Information \"? [$script:BusBuddyTestWatchCorrelation] Retry succeeded on attempt $attempt\" -InformationAction Continue\r\n                        break\r\n                    } catch {\r\n                        Write-Warning (\"[$script:BusBuddyTestWatchCorrelation] Retry attempt {0} failed: {1}\" -f $attempt, $_.Exception.Message)\r\n                        $delay = [math]::Min($delay * 2, 30)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $handler = Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action\r\n    $script:BusBuddyTestWatchHandle = @{ Watcher = $watcher; Handler = $handler }\r\n    Write-Information \"Press Ctrl+C or run Stop-BusBuddyTestWatchAdvanced to stop. CorrelationId=$script:BusBuddyTestWatchCorrelation\" -InformationAction Continue\r\n}\r\n\r\nfunction Stop-BusBuddyTestWatchAdvanced {\r\n    [CmdletBinding()] param()\r\n    if (-not $script:BusBuddyTestWatchHandle) { Write-Warning 'No active test watch.'; return }\r\n    try {\r\n        $script:BusBuddyTestWatchHandle.Handler | Unregister-Event -ErrorAction SilentlyContinue\r\n        $script:BusBuddyTestWatchHandle.Watcher.EnableRaisingEvents = $false\r\n        $script:BusBuddyTestWatchHandle.Watcher.Dispose()\r\n        Write-Information '?? Test watch stopped.' -InformationAction Continue\r\n    } finally { Remove-Variable BusBuddyTestWatchHandle -Scope Script -ErrorAction SilentlyContinue }\r\n}\r\n\r\nExport-ModuleMember -Function Start-BusBuddyTestWatchAdvanced,Stop-BusBuddyTestWatchAdvanced\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.Cleanup",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup\\BusBuddy.Cleanup.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.Cleanup Module\r\n# Implements repository hygiene and artifact cleanup per project guidelines.\r\n\r\nfunction Invoke-BusBuddyCleanup {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove build artifacts and old log files.\r\n    .DESCRIPTION\r\n        Deletes bin/, obj/, TestResults/, and logs older than a retention window (default 7 days).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$LogRetentionDays = 7,\r\n        [switch]$IncludeNodeModules\r\n    )\r\n    $paths = @('bin','obj','TestResults')\r\n    if ($IncludeNodeModules) { $paths += 'node_modules' }\r\n    foreach ($p in $paths) {\r\n        Get-ChildItem -Recurse -Directory -Filter $p -ErrorAction SilentlyContinue | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove directory')) {\r\n                try { Remove-Item $_.FullName -Recurse -Force -ErrorAction Stop; Write-Information \"??? Removed $($_.FullName)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove $($_.FullName): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    if (Test-Path logs) {\r\n        $threshold = (Get-Date).AddDays(-$LogRetentionDays)\r\n        Get-ChildItem logs -File -Include *.log -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold } | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove old log')) {\r\n                try { Remove-Item $_.FullName -Force; Write-Information \"?? Removed old log $($_.Name)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove log $($_.Name): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Identify candidate unused .cs/.xaml files not referenced in solution or project includes.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([string[]])]\r\n    param(\r\n        [string]$Root = '.'\r\n    )\r\n    $solution = Get-ChildItem -Path $Root -Filter *.sln -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1\r\n    if (-not $solution) { Write-Warning 'Solution file not found.'; return @() }\r\n    $solutionText = Get-Content $solution.FullName -Raw\r\n    $candidates = Get-ChildItem $Root -Recurse -Include *.cs,*.xaml -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'bin\\\\|obj\\\\|TestResults\\\\|\\.git' }\r\n    $unused = @()\r\n    foreach ($f in $candidates) {\r\n        if ($solutionText -notmatch [regex]::Escape($f.Name)) { $unused += $f.FullName }\r\n    }\r\n    return $unused\r\n}\r\n\r\nfunction Remove-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove unused files interactively (WhatIf supported).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Medium')]\r\n    param(\r\n        [string]$Root='.'\r\n    )\r\n    $unused = Get-BusBuddyUnusedFiles -Root $Root\r\n    if (-not $unused -or $unused.Count -eq 0) { Write-Information 'No unused files detected.' -InformationAction Continue; return }\r\n    foreach ($file in $unused) {\r\n        if ($PSCmdlet.ShouldProcess($file,'Remove unused file')) {\r\n            try { Remove-Item $file -Force; Write-Information \"Removed unused file $file\" -InformationAction Continue } catch { $warn = 'Failed to remove ' + $file + ' -> ' + $_.Exception.Message; Write-Warning $warn }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyCleanup,Get-BusBuddyUnusedFiles,Remove-BusBuddyUnusedFiles\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          }
        ],
        "PowerShellHostName": null,
        "PowerShellHostVersion": null,
        "PowerShellVersion": {
          "Major": 7,
          "Minor": 5,
          "Build": -1,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ProcessorArchitecture": 0,
        "Scripts": [],
        "RequiredAssemblies": [],
        "RequiredModules": [],
        "RootModule": "BusBuddy.psm1",
        "ExportedVariables": {},
        "ExportedAliases": {
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "ExportedDscResources": [],
        "SessionState": {
          "Drive": {
            "Current": "C"
          },
          "Provider": {},
          "Path": {
            "CurrentLocation": "C:\\Users\\biges\\Desktop\\BusBuddy",
            "CurrentFileSystemLocation": "C:\\Users\\biges\\Desktop\\BusBuddy"
          },
          "PSVariable": {},
          "LanguageMode": 0,
          "UseFullLanguageModeInDebugger": false,
          "Scripts": [
            "*"
          ],
          "Applications": [
            "*"
          ],
          "Module": {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
            "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
            "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Development WPF DotNet BusBuddy Development WPF DotNet",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "RepositorySourceLocation": null,
            "Version": "2.0.0",
            "ModuleType": 0,
            "Author": "Bus Buddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Team",
            "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1",
            "CompatiblePSEditions": "Core",
            "ModuleList": "",
            "NestedModules": "BusBuddy.BuildOutput BusBuddy.TestOutput BusBuddy.ThemeValidation BusBuddy.AzureSqlHealth BusBuddy.TestWatcher BusBuddy.Cleanup",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          "InvokeProvider": {
            "Item": "System.Management.Automation.ItemCmdletProviderIntrinsics",
            "ChildItem": "System.Management.Automation.ChildItemCmdletProviderIntrinsics",
            "Content": "System.Management.Automation.ContentCmdletProviderIntrinsics",
            "Property": "System.Management.Automation.PropertyCmdletProviderIntrinsics",
            "SecurityDescriptor": "System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics"
          },
          "InvokeCommand": {
            "HasErrors": null,
            "CommandNotFoundAction": null,
            "PreCommandLookupAction": null,
            "PostCommandLookupAction": null,
            "LocationChangedAction": null
          }
        },
        "OnRemove": null,
        "ExportedFormatFiles": [],
        "ExportedTypeFiles": []
      }
    },
    {
      "Definition": "Start-BusBuddyDevSession",
      "Name": "bbDevSession",
      "Options": "None",
      "Module": {
        "LogPipelineExecutionDetails": false,
        "Name": "BusBuddy",
        "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
        "ImplementingAssembly": null,
        "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
        "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
        "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
        "HelpInfoUri": null,
        "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
        "PrivateData": {
          "PSData": {
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "Tags": "BusBuddy Development WPF DotNet"
          }
        },
        "ExperimentalFeatures": [],
        "Tags": [
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet",
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet"
        ],
        "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
        "IconUri": null,
        "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
        "ReleaseNotes": "Streamlined core module for reliable development workflow",
        "RepositorySourceLocation": null,
        "Version": {
          "Major": 2,
          "Minor": 0,
          "Build": 0,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ModuleType": 0,
        "Author": "Bus Buddy Development Team",
        "AccessMode": 0,
        "ClrVersion": null,
        "CompanyName": "BusBuddy Team",
        "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
        "DotNetFrameworkVersion": null,
        "ExportedFunctions": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          }
        },
        "Prefix": "",
        "ExportedCmdlets": {},
        "ExportedCommands": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "FileList": [
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1"
        ],
        "CompatiblePSEditions": [
          "Core"
        ],
        "ModuleList": [],
        "NestedModules": [
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.BuildOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "# Enhanced Build Commands with No Truncation\n# Part of BusBuddy PowerShell Module\n\n#region Enhanced Build Functions\n\nfunction Get-BusBuddyBuildOutput {\n    <#\n    .SYNOPSIS\n        Get complete build output without truncation\n\n    .DESCRIPTION\n        Captures full dotnet build output to both console and file, preventing truncation issues\n\n    .PARAMETER ProjectPath\n        Path to solution or project file\n\n    .PARAMETER Configuration\n        Build configuration (Debug/Release)\n\n    .PARAMETER SaveToFile\n        Save complete output to timestamped file\n\n    .EXAMPLE\n        Get-BusBuddyBuildOutput -SaveToFile\n    #>\n    [CmdletBinding()]\n    param(\n        [string]$ProjectPath = \"BusBuddy.sln\",\n        [string]$Configuration = \"Debug\",\n        [switch]$SaveToFile,\n        [switch]$ErrorsOnly\n    )\n\n    $timestamp = Get-Date -Format \"yyyyMMdd-HHmmss\"\n    $outputFile = \"logs\\build-output-$timestamp.log\"\n\n    # Ensure logs directory exists\n    if (-not (Test-Path \"logs\")) {\n        New-Item -ItemType Directory -Path \"logs\" -Force | Out-Null\n    }\n\n    Write-Host \"??? Building $ProjectPath...\" -ForegroundColor Cyan\n    Write-Host \"?? Configuration: $Configuration\" -ForegroundColor Gray\n\n    if ($SaveToFile) {\n        Write-Host \"?? Full output will be saved to: $outputFile\" -ForegroundColor Yellow\n    }\n\n    # Configure environment for maximum output\n    $env:DOTNET_CLI_UI_LANGUAGE = \"en-US\"\n    $env:DOTNET_NOLOGO = \"false\"  # We want full output\n\n    try {\n        # Capture all output streams with detailed verbosity\n        $verbosity = if ($ErrorsOnly) { \"quiet\" } else { \"detailed\" }\n\n        $startTime = Get-Date\n\n        # Use Start-Process for complete output capture\n        $processInfo = @{\n            FilePath = \"dotnet\"\n            ArgumentList = @(\"build\", $ProjectPath, \"--configuration\", $Configuration, \"--verbosity\", $verbosity, \"--no-restore\")\n            RedirectStandardOutput = $true\n            RedirectStandardError = $true\n            UseShellExecute = $false\n            CreateNoWindow = $true\n        }\n\n        $process = Start-Process @processInfo -PassThru\n\n        # Read output in real-time\n        $stdout = $process.StandardOutput.ReadToEnd()\n        $stderr = $process.StandardError.ReadToEnd()\n\n        $process.WaitForExit()\n        $exitCode = $process.ExitCode\n\n        $endTime = Get-Date\n        $duration = $endTime - $startTime\n\n        # Combine all output\n        $fullOutput = @\"\n=== BUSBUDDY BUILD LOG ===\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\nProject: $ProjectPath\nConfiguration: $Configuration\nDuration: $($duration.TotalSeconds) seconds\nExit Code: $exitCode\n\n=== STANDARD OUTPUT ===\n$stdout\n\n=== STANDARD ERROR ===\n$stderr\n\n=== BUILD SUMMARY ===\n\"@\n\n        # Save to file if requested\n        if ($SaveToFile) {\n            $fullOutput | Out-File -FilePath $outputFile -Encoding UTF8 -Width 500\n            Write-Host \"? Complete build log saved to: $outputFile\" -ForegroundColor Green\n        }\n\n        # Parse and display errors prominently\n        $errorLines = ($stdout + $stderr) -split \"`n\" | Where-Object { $_ -match \"error|Error|ERROR|\\s+CS\\d+|\\s+MSB\\d+\" }\n\n        if ($errorLines) {\n            Write-Host \"`n? BUILD ERRORS FOUND:\" -ForegroundColor Red\n            Write-Host \"=\" * 50 -ForegroundColor Red\n            $errorLines | ForEach-Object {\n                Write-Host $_ -ForegroundColor Red\n            }\n            Write-Host \"=\" * 50 -ForegroundColor Red\n\n            if ($SaveToFile) {\n                Write-Host \"?? Full details in: $outputFile\" -ForegroundColor Yellow\n            }\n        } else {\n            Write-Host \"? No errors found!\" -ForegroundColor Green\n        }\n\n        # Display summary\n        Write-Host \"`n?? BUILD SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"   Duration: $($duration.TotalSeconds) seconds\" -ForegroundColor Gray\n        Write-Host \"   Exit Code: $exitCode\" -ForegroundColor $(if ($exitCode -eq 0) { \"Green\" } else { \"Red\" })\n\n        if ($exitCode -eq 0) {\n            Write-Host \"   Status: SUCCESS ?\" -ForegroundColor Green\n        } else {\n            Write-Host \"   Status: FAILED ?\" -ForegroundColor Red\n        }\n\n        return @{\n            ExitCode = $exitCode\n            Duration = $duration\n            ErrorLines = $errorLines\n            OutputFile = if ($SaveToFile) { $outputFile } else { $null }\n            FullOutput = $fullOutput\n        }\n\n    } catch {\n        Write-Error \"Failed to execute build: $($_.Exception.Message)\"\n        return $null\n    }\n}\n\nfunction Start-BusBuddyBuildFull {\n    <#\n    .SYNOPSIS\n        Enhanced bb-build with complete output capture\n    #>\n    Get-BusBuddyBuildOutput -SaveToFile\n}\n\nfunction Get-BusBuddyBuildErrors {\n    <#\n    .SYNOPSIS\n        Get only build errors without full output\n    #>\n    Get-BusBuddyBuildOutput -ErrorsOnly\n}\n\nfunction Show-BusBuddyBuildLog {\n    <#\n    .SYNOPSIS\n        Show the most recent build log\n    #>\n    $latestLog = Get-ChildItem \"logs\\build-output-*.log\" | Sort-Object LastWriteTime -Descending | Select-Object -First 1\n\n    if ($latestLog) {\n        Write-Host \"?? Most recent build log: $($latestLog.Name)\" -ForegroundColor Cyan\n        Write-Host \"?? Created: $($latestLog.LastWriteTime)\" -ForegroundColor Gray\n        Write-Host \"\"\n        Get-Content $latestLog.FullName\n    } else {\n        Write-Host \"No build logs found. Run Start-BusBuddyBuildFull first.\" -ForegroundColor Yellow\n    }\n}\n\n#endregion\n\n# Export functions\nExport-ModuleMember -Function Get-BusBuddyBuildOutput, Start-BusBuddyBuildFull, Get-BusBuddyBuildErrors, Show-BusBuddyBuildLog\n",
            "Description": "Enhanced build output capture for BusBuddy - eliminates truncated terminal output",
            "Guid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Build Output Capture NoTruncation BusBuddy Build Output Capture NoTruncation",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": "v1.0.0 - Initial release\n- Complete build output capture without truncation\n- Automatic error parsing and highlighting\n- Timestamped log file generation\n- Enhanced terminal buffer configuration",
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Project",
            "Copyright": "(c) 2025 BusBuddy Project. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.BuildOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\nSet-StrictMode -Version 3.0\r\n\r\n# Avoid auto-executing on import - provide wrapper to run the script when requested\r\n$moduleRoot = Split-Path -Parent $PSScriptRoot\r\n$workspaceRoot = Split-Path -Parent (Split-Path -Parent $moduleRoot)\r\n$enhancedTestPath = Join-Path $workspaceRoot 'PowerShell\\Scripts\\Enhanced-Test-Output.ps1'\r\n\r\nfunction Invoke-BusBuddyEnhancedTestOutput {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromRemainingArguments = $true)]\r\n        [object[]] $Args\r\n    )\r\n    if (-not (Test-Path -LiteralPath $enhancedTestPath)) {\r\n        Write-Error \"Enhanced-Test-Output.ps1 not found at: $enhancedTestPath\"\r\n        return\r\n    }\r\n    & $enhancedTestPath @Args\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyEnhancedTestOutput\r\n",
            "Description": "",
            "Guid": "7c6a0d9e-1f2a-4b9e-b5a2-1c5f5d5b8a1c",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy",
            "Copyright": "(c) BusBuddy",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.TestOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.ThemeValidation",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation\\BusBuddy.ThemeValidation.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.ThemeValidation Module\r\n# Validates Syncfusion theme/style consistency across WPF XAML files.\r\n# Docs reference: https://help.syncfusion.com/wpf/themes/overview\r\n\r\nfunction Test-BusBuddyThemeConsistency {\r\n    <#\r\n    .SYNOPSIS\r\n        Scan XAML views for inline Syncfusion control styling violations.\r\n    .DESCRIPTION\r\n        Looks for Syncfusion controls (SfDataGrid, ButtonAdv, DockingManager etc.)\r\n        with inline size/margin/brush properties that should be centralized in resource dictionaries.\r\n    .OUTPUTS\r\n        Hashtable with Issues (string[]) and Status (Success|Failed)\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views'\r\n    )\r\n    $issues = New-Object System.Collections.Generic.List[string]\r\n    if (-not (Test-Path $ViewsPath)) {\r\n        Write-Warning \"Views path not found: $ViewsPath\"\r\n        return @{ Issues = @('Views path missing'); Status = 'Failed' }\r\n    }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    $mergedDictionaries = @{}\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $mergeMatches = [regex]::Matches($content,'<ResourceDictionary\\s+Source=\"([^\"]+)\"')\r\n        foreach ($m in $mergeMatches) { $mergedDictionaries[$m.Groups[1].Value] = $true }\r\n        # Detect inline width/height/margin on Syncfusion ButtonAdv or SfButton / SfDataGrid\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)[^>]*(Width|Height|Margin)=') {\r\n            $issues.Add(\"Inline layout property on Syncfusion button in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:SfDataGrid[^>]*(RowHeight|HeaderRowHeight|Background|BorderBrush)=') {\r\n            $issues.Add(\"Inline SfDataGrid visual property in $($file.Name)\")\r\n        }\r\n        # Missing namespace check (should declare syncfusion namespace where controls appear)\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'xmlns:syncfusion=') {\r\n            $issues.Add(\"Missing syncfusion xmlns in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'FluentDark' -and $content -notmatch 'FluentLight') {\r\n            $issues.Add(\"Potential missing theme reference (FluentDark/FluentLight) in $($file.Name)\")\r\n        }\r\n    }\r\n    if (-not ($mergedDictionaries.Keys | Where-Object { $_ -match 'Themes' })) {\r\n        $issues.Add('No merged resource dictionaries referencing Themes folder detected')\r\n    }\r\n    $status = if ($issues.Count -gt 0) { 'Failed' } else { 'Success' }\r\n    return @{ Issues = $issues.ToArray(); Status = $status; FileCount = $xamlFiles.Count; MergedDictionaries = $mergedDictionaries.Keys }\r\n}\r\n\r\nfunction Invoke-BusBuddyThemeRemediation {\r\n    <#\r\n    .SYNOPSIS\r\n        Attempt automatic remediation of common inline styling issues.\r\n    .DESCRIPTION\r\n        Replaces common inline size/margin attributes on Syncfusion buttons with Style reference.\r\n        Only performs safe textual substitutions; more advanced refactoring deferred post-MVP.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views',\r\n        [string]$ButtonStyleKey = 'SyncfusionPrimaryButtonStyle'\r\n    )\r\n    if (-not (Test-Path $ViewsPath)) { Write-Warning \"Views path not found: $ViewsPath\"; return }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $original = $content\r\n        $modified = $false\r\n        # Replace inline width/height/margin on buttons with style if not already styled\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)' -and $content -notmatch 'Style=\"{StaticResource') {\r\n            $content = [regex]::Replace($content,'(<syncfusion:(?:ButtonAdv|SfButton)[^>]*)(Width|Height|Margin)=\"[^\"]+\"','${1}')\r\n            if ($content -ne $original) { $modified = $true }\r\n            if ($modified) {\r\n                $content = [regex]::Replace($content,'<syncfusion:(ButtonAdv|SfButton)([^>]*)>','<syncfusion:$1$2 Style=\"{StaticResource ' + $ButtonStyleKey + '}\">')\r\n            }\r\n        }\r\n        if ($modified -and $PSCmdlet.ShouldProcess($file.FullName,'Apply style remediation')) {\r\n            $content | Set-Content $file.FullName -Encoding UTF8\r\n            Write-Information \"Remediated: $($file.Name)\" -InformationAction Continue\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyThemeConsistency,Invoke-BusBuddyThemeRemediation\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.AzureSqlHealth",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth\\BusBuddy.AzureSqlHealth.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.AzureSqlHealth Module\r\n# References: https://learn.microsoft.com/azure/azure-sql/database/connectivity-architecture\r\n\r\nfunction Test-BusBuddyAzureSql {\r\n    <#\r\n    .SYNOPSIS\r\n        Test connectivity to Azure SQL (fallback to LocalDB on failure).\r\n    .OUTPUTS\r\n        Bool indicating Azure SQL connectivity success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) {\r\n        Write-Warning \"Azure settings file not found: $SettingsPath\"\r\n        return $false\r\n    }\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 2\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n    $lastError = $null\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n            $connString = $json.ConnectionStrings.DefaultConnection\r\n            if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n            $query = 'SELECT TOP 1 name FROM sys.databases'\r\n            $result = Invoke-Sqlcmd -ConnectionString $connString -Query $query -ErrorAction Stop\r\n            $stopwatch.Stop()\r\n            Write-Information \"? Azure SQL reachable (attempt $attempts) latency=$([math]::Round($stopwatch.Elapsed.TotalMilliseconds,0))ms Databases: $($result.name -join ',')\" -InformationAction Continue\r\n            return $true\r\n        } catch {\r\n            $lastError = $_.Exception.Message\r\n            Write-Warning \"Attempt $attempts failed: $lastError\"\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds *= 2 }\r\n        }\r\n    }\r\n    $stopwatch.Stop()\r\n    Write-Warning \"?? Azure SQL test failed after $attempts attempts: $lastError\"\r\n    return $false\r\n}\r\n\r\nfunction Test-BusBuddyAzureSqlNative {\r\n    <#\r\n    .SYNOPSIS\r\n        Test Azure SQL connectivity using System.Data.SqlClient directly (no sqlcmd dependency).\r\n    .DESCRIPTION\r\n        Reads connection string from appsettings.azure.json (ConnectionStrings.DefaultConnection) and attempts to open a connection\r\n        and run a lightweight query. Implements simple retry with exponential backoff.\r\n        Docs: https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.open\r\n    .OUTPUTS\r\n        Bool indicating success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) { Write-Warning \"Azure settings file not found: $SettingsPath\"; return $false }\r\n    try {\r\n        $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n        $connString = $json.ConnectionStrings.DefaultConnection\r\n        if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n    } catch {\r\n        Write-Warning \"Failed to parse ${SettingsPath}: $($_.Exception.Message)\"; return $false\r\n    }\r\n\r\n    # Expand ${ENV_VAR} placeholders if present in connection string\r\n    # Pattern sourced from standard PowerShell regex usage - see Microsoft Docs: about_Regular_Expressions\r\n    $expandEnv = {\r\n        param([string]$s)\r\n        if ([string]::IsNullOrWhiteSpace($s)) { return $s }\r\n        return [regex]::Replace($s, '\\$\\{([A-Za-z0-9_]+)\\}', {\r\n            param($m)\r\n            $name = $m.Groups[1].Value\r\n            $val  = [Environment]::GetEnvironmentVariable($name)\r\n            if (-not $val) { $m.Value } else { $val }\r\n        })\r\n    }\r\n    $original = $connString\r\n    $connString = & $expandEnv $connString\r\n    if ($connString -match '\\$\\{') {\r\n        Write-Information \"?? One or more environment placeholders are unresolved in connection string (file=${SettingsPath}). Set required variables in the environment before running tests.\" -InformationAction Continue\r\n    }\r\n\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 1\r\n    $sw = [System.Diagnostics.Stopwatch]::StartNew()\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $conn = [System.Data.SqlClient.SqlConnection]::new($connString)\r\n            $conn.Open()\r\n            try {\r\n                $cmd = $conn.CreateCommand()\r\n                $cmd.CommandText = 'SELECT DB_NAME()'\r\n                $db = $cmd.ExecuteScalar()\r\n                $sw.Stop()\r\n                Write-Information (\"? Azure SQL (native) reachable on attempt {0} - DB: {1}, latency={2}ms\" -f $attempts, $db, [math]::Round($sw.Elapsed.TotalMilliseconds,0)) -InformationAction Continue\r\n                return $true\r\n            } finally {\r\n                $conn.Dispose()\r\n            }\r\n        } catch {\r\n            Write-Warning (\"Native attempt {0} failed: {1}\" -f $attempts, $_.Exception.Message)\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds = [Math]::Min($delaySeconds * 2, 8) }\r\n        }\r\n    }\r\n    $sw.Stop()\r\n    Write-Warning \"?? Azure SQL (native) test failed after $attempts attempts.\"\r\n    return $false\r\n}\r\n\r\nfunction Get-BusBuddySqlStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Provide detailed Azure SQL / LocalDB status summary.\r\n    .OUTPUTS\r\n        Hashtable with status fields.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$AzureSettingsPath = 'appsettings.azure.json',\r\n        [string]$LocalSettingsPath = 'appsettings.json'\r\n    )\r\n    $status = [ordered]@{}\r\n    $status.Timestamp = Get-Date\r\n    $status.AzureSettingsPresent = Test-Path $AzureSettingsPath\r\n    $status.LocalSettingsPresent = Test-Path $LocalSettingsPath\r\n    $status.AzureReachable = $false\r\n    $status.LocalDbReachable = $false\r\n\r\n    if ($status.AzureSettingsPresent) {\r\n        $status.AzureReachable = Test-BusBuddyAzureSql -SettingsPath $AzureSettingsPath\r\n    }\r\n    # LocalDB quick probe via sqlcmd if installed\r\n    try {\r\n        $localJson = if (Test-Path $LocalSettingsPath) { Get-Content $LocalSettingsPath -Raw | ConvertFrom-Json } else { $null }\r\n        $localConn = $localJson.ConnectionStrings.DefaultConnection\r\n        if ($localConn -and $localConn -match 'localdb') {\r\n            try {\r\n                Invoke-Sqlcmd -ConnectionString $localConn -Query 'SELECT 1' -ErrorAction Stop | Out-Null\r\n                $status.LocalDbReachable = $true\r\n            } catch {\r\n                $status.LocalDbReachable = $false\r\n            }\r\n        }\r\n    } catch {\r\n        $status.LocalDbReachable = $false\r\n    }\r\n\r\n    $status.PrimaryDataSource = if ($status.AzureReachable) { 'Azure' } elseif ($status.LocalDbReachable) { 'LocalDB' } else { 'Unknown' }\r\n    return $status\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyAzureSql,Test-BusBuddyAzureSqlNative,Get-BusBuddySqlStatus\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestWatcher",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher\\BusBuddy.TestWatcher.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.TestWatcher Module\r\n# Provides debounced file change watching to trigger targeted test runs.\r\n\r\nfunction Start-BusBuddyTestWatchAdvanced {\r\n    <#\r\n    .SYNOPSIS\r\n        Start debounced test watch loop for a specific test suite.\r\n    .DESCRIPTION\r\n        Watches for changes to .cs and .xaml files under repo root and re-runs Get-BusBuddyTestOutput.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite = 'Unit',\r\n        [int]$DebounceSeconds = 2,\r\n        [switch]$RetryOnFailure,\r\n        [int]$MaxRetries = 2,\r\n        [int]$RetryDelaySeconds = 2\r\n    )\r\n    if ($script:BusBuddyTestWatchHandle) { Write-Warning 'Test watch already running.'; return }\r\n    $root = Get-Location\r\n    Write-Information \"?? Watching $root for changes (suite=$TestSuite, debounce=${DebounceSeconds}s)\" -InformationAction Continue\r\n    $watcher = New-Object System.IO.FileSystemWatcher -Property @{ Path = $root; Filter = '*.*'; IncludeSubdirectories = $true; EnableRaisingEvents = $true }\r\n    $script:BusBuddyTestWatchLastRun = Get-Date 0\r\n    $script:BusBuddyTestWatchIgnored = 0\r\n    $script:BusBuddyTestWatchTriggered = 0\r\n    $script:BusBuddyTestWatchFailures = 0\r\n    $script:BusBuddyTestWatchRetries = 0\r\n    # Correlation ID for this watcher session\r\n    $script:BusBuddyTestWatchCorrelation = [guid]::NewGuid().ToString()\r\n    $action = {\r\n        $full = $Event.SourceEventArgs.FullPath\r\n        $ext = [IO.Path]::GetExtension($full)\r\n        if ($ext -notin '.cs','.xaml') {\r\n            Write-Verbose (\"Ignoring change due to unsupported extension: {0}\" -f $ext)\r\n            return\r\n        }\r\n        # Ignore build/test artifacts to avoid infinite loops (bin/obj/TestResults/.git/.vs)\r\n        if ($full -match \"(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\\") {\r\n            $script:BusBuddyTestWatchIgnored++\r\n            Write-Verbose (\"Ignoring change in excluded path: {0}\" -f $full)\r\n            return\r\n        }\r\n        $now = Get-Date\r\n        $elapsed = ($now - $script:BusBuddyTestWatchLastRun).TotalSeconds\r\n        if ($elapsed -lt $using:DebounceSeconds) {\r\n            $remaining = [math]::Max([int]([math]::Ceiling($using:DebounceSeconds - $elapsed)), 0)\r\n            Write-Verbose (\"Debounce active - event suppressed. Time remaining: {0}s\" -f $remaining)\r\n            return\r\n        }\r\n        $script:BusBuddyTestWatchLastRun = $now\r\n        $script:BusBuddyTestWatchTriggered++\r\n        Write-Information \"?? [$script:BusBuddyTestWatchCorrelation] Change detected: $($Event.SourceEventArgs.Name) -> running $using:TestSuite tests (trigger #$script:BusBuddyTestWatchTriggered, ignored so far=$script:BusBuddyTestWatchIgnored)\" -InformationAction Continue\r\n        try {\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n        } catch {\r\n            $script:BusBuddyTestWatchFailures++\r\n            Write-Warning \"[$script:BusBuddyTestWatchCorrelation] Test watch run failed (#$script:BusBuddyTestWatchFailures): $($_.Exception.Message)\"\r\n            if ($using:RetryOnFailure) {\r\n                $attempt = 0\r\n                $delay = [int]$using:RetryDelaySeconds\r\n                while ($attempt -lt [int]$using:MaxRetries) {\r\n                    $attempt++\r\n                    $script:BusBuddyTestWatchRetries++\r\n                    Write-Information (\"?? [$script:BusBuddyTestWatchCorrelation] Retry trigger #{0} (attempt {1}/{2}) after failure - waiting {3}s...\" -f $script:BusBuddyTestWatchRetries, $attempt, [int]$using:MaxRetries, $delay) -InformationAction Continue\r\n                    Start-Sleep -Seconds $delay\r\n                    try {\r\n                        Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n                        Write-Information \"? [$script:BusBuddyTestWatchCorrelation] Retry succeeded on attempt $attempt\" -InformationAction Continue\r\n                        break\r\n                    } catch {\r\n                        Write-Warning (\"[$script:BusBuddyTestWatchCorrelation] Retry attempt {0} failed: {1}\" -f $attempt, $_.Exception.Message)\r\n                        $delay = [math]::Min($delay * 2, 30)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $handler = Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action\r\n    $script:BusBuddyTestWatchHandle = @{ Watcher = $watcher; Handler = $handler }\r\n    Write-Information \"Press Ctrl+C or run Stop-BusBuddyTestWatchAdvanced to stop. CorrelationId=$script:BusBuddyTestWatchCorrelation\" -InformationAction Continue\r\n}\r\n\r\nfunction Stop-BusBuddyTestWatchAdvanced {\r\n    [CmdletBinding()] param()\r\n    if (-not $script:BusBuddyTestWatchHandle) { Write-Warning 'No active test watch.'; return }\r\n    try {\r\n        $script:BusBuddyTestWatchHandle.Handler | Unregister-Event -ErrorAction SilentlyContinue\r\n        $script:BusBuddyTestWatchHandle.Watcher.EnableRaisingEvents = $false\r\n        $script:BusBuddyTestWatchHandle.Watcher.Dispose()\r\n        Write-Information '?? Test watch stopped.' -InformationAction Continue\r\n    } finally { Remove-Variable BusBuddyTestWatchHandle -Scope Script -ErrorAction SilentlyContinue }\r\n}\r\n\r\nExport-ModuleMember -Function Start-BusBuddyTestWatchAdvanced,Stop-BusBuddyTestWatchAdvanced\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.Cleanup",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup\\BusBuddy.Cleanup.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.Cleanup Module\r\n# Implements repository hygiene and artifact cleanup per project guidelines.\r\n\r\nfunction Invoke-BusBuddyCleanup {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove build artifacts and old log files.\r\n    .DESCRIPTION\r\n        Deletes bin/, obj/, TestResults/, and logs older than a retention window (default 7 days).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$LogRetentionDays = 7,\r\n        [switch]$IncludeNodeModules\r\n    )\r\n    $paths = @('bin','obj','TestResults')\r\n    if ($IncludeNodeModules) { $paths += 'node_modules' }\r\n    foreach ($p in $paths) {\r\n        Get-ChildItem -Recurse -Directory -Filter $p -ErrorAction SilentlyContinue | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove directory')) {\r\n                try { Remove-Item $_.FullName -Recurse -Force -ErrorAction Stop; Write-Information \"??? Removed $($_.FullName)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove $($_.FullName): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    if (Test-Path logs) {\r\n        $threshold = (Get-Date).AddDays(-$LogRetentionDays)\r\n        Get-ChildItem logs -File -Include *.log -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold } | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove old log')) {\r\n                try { Remove-Item $_.FullName -Force; Write-Information \"?? Removed old log $($_.Name)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove log $($_.Name): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Identify candidate unused .cs/.xaml files not referenced in solution or project includes.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([string[]])]\r\n    param(\r\n        [string]$Root = '.'\r\n    )\r\n    $solution = Get-ChildItem -Path $Root -Filter *.sln -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1\r\n    if (-not $solution) { Write-Warning 'Solution file not found.'; return @() }\r\n    $solutionText = Get-Content $solution.FullName -Raw\r\n    $candidates = Get-ChildItem $Root -Recurse -Include *.cs,*.xaml -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'bin\\\\|obj\\\\|TestResults\\\\|\\.git' }\r\n    $unused = @()\r\n    foreach ($f in $candidates) {\r\n        if ($solutionText -notmatch [regex]::Escape($f.Name)) { $unused += $f.FullName }\r\n    }\r\n    return $unused\r\n}\r\n\r\nfunction Remove-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove unused files interactively (WhatIf supported).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Medium')]\r\n    param(\r\n        [string]$Root='.'\r\n    )\r\n    $unused = Get-BusBuddyUnusedFiles -Root $Root\r\n    if (-not $unused -or $unused.Count -eq 0) { Write-Information 'No unused files detected.' -InformationAction Continue; return }\r\n    foreach ($file in $unused) {\r\n        if ($PSCmdlet.ShouldProcess($file,'Remove unused file')) {\r\n            try { Remove-Item $file -Force; Write-Information \"Removed unused file $file\" -InformationAction Continue } catch { $warn = 'Failed to remove ' + $file + ' -> ' + $_.Exception.Message; Write-Warning $warn }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyCleanup,Get-BusBuddyUnusedFiles,Remove-BusBuddyUnusedFiles\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          }
        ],
        "PowerShellHostName": null,
        "PowerShellHostVersion": null,
        "PowerShellVersion": {
          "Major": 7,
          "Minor": 5,
          "Build": -1,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ProcessorArchitecture": 0,
        "Scripts": [],
        "RequiredAssemblies": [],
        "RequiredModules": [],
        "RootModule": "BusBuddy.psm1",
        "ExportedVariables": {},
        "ExportedAliases": {
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "ExportedDscResources": [],
        "SessionState": {
          "Drive": {
            "Current": "C"
          },
          "Provider": {},
          "Path": {
            "CurrentLocation": "C:\\Users\\biges\\Desktop\\BusBuddy",
            "CurrentFileSystemLocation": "C:\\Users\\biges\\Desktop\\BusBuddy"
          },
          "PSVariable": {},
          "LanguageMode": 0,
          "UseFullLanguageModeInDebugger": false,
          "Scripts": [
            "*"
          ],
          "Applications": [
            "*"
          ],
          "Module": {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
            "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
            "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Development WPF DotNet BusBuddy Development WPF DotNet",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "RepositorySourceLocation": null,
            "Version": "2.0.0",
            "ModuleType": 0,
            "Author": "Bus Buddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Team",
            "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1",
            "CompatiblePSEditions": "Core",
            "ModuleList": "",
            "NestedModules": "BusBuddy.BuildOutput BusBuddy.TestOutput BusBuddy.ThemeValidation BusBuddy.AzureSqlHealth BusBuddy.TestWatcher BusBuddy.Cleanup",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          "InvokeProvider": {
            "Item": "System.Management.Automation.ItemCmdletProviderIntrinsics",
            "ChildItem": "System.Management.Automation.ChildItemCmdletProviderIntrinsics",
            "Content": "System.Management.Automation.ContentCmdletProviderIntrinsics",
            "Property": "System.Management.Automation.PropertyCmdletProviderIntrinsics",
            "SecurityDescriptor": "System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics"
          },
          "InvokeCommand": {
            "HasErrors": null,
            "CommandNotFoundAction": null,
            "PreCommandLookupAction": null,
            "PostCommandLookupAction": null,
            "LocationChangedAction": null
          }
        },
        "OnRemove": null,
        "ExportedFormatFiles": [],
        "ExportedTypeFiles": []
      }
    },
    {
      "Definition": "Invoke-BusBuddyRun",
      "Name": "bbRun",
      "Options": "None",
      "Module": {
        "LogPipelineExecutionDetails": false,
        "Name": "BusBuddy",
        "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
        "ImplementingAssembly": null,
        "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
        "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
        "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
        "HelpInfoUri": null,
        "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
        "PrivateData": {
          "PSData": {
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "Tags": "BusBuddy Development WPF DotNet"
          }
        },
        "ExperimentalFeatures": [],
        "Tags": [
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet",
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet"
        ],
        "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
        "IconUri": null,
        "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
        "ReleaseNotes": "Streamlined core module for reliable development workflow",
        "RepositorySourceLocation": null,
        "Version": {
          "Major": 2,
          "Minor": 0,
          "Build": 0,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ModuleType": 0,
        "Author": "Bus Buddy Development Team",
        "AccessMode": 0,
        "ClrVersion": null,
        "CompanyName": "BusBuddy Team",
        "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
        "DotNetFrameworkVersion": null,
        "ExportedFunctions": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          }
        },
        "Prefix": "",
        "ExportedCmdlets": {},
        "ExportedCommands": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "FileList": [
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1"
        ],
        "CompatiblePSEditions": [
          "Core"
        ],
        "ModuleList": [],
        "NestedModules": [
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.BuildOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "# Enhanced Build Commands with No Truncation\n# Part of BusBuddy PowerShell Module\n\n#region Enhanced Build Functions\n\nfunction Get-BusBuddyBuildOutput {\n    <#\n    .SYNOPSIS\n        Get complete build output without truncation\n\n    .DESCRIPTION\n        Captures full dotnet build output to both console and file, preventing truncation issues\n\n    .PARAMETER ProjectPath\n        Path to solution or project file\n\n    .PARAMETER Configuration\n        Build configuration (Debug/Release)\n\n    .PARAMETER SaveToFile\n        Save complete output to timestamped file\n\n    .EXAMPLE\n        Get-BusBuddyBuildOutput -SaveToFile\n    #>\n    [CmdletBinding()]\n    param(\n        [string]$ProjectPath = \"BusBuddy.sln\",\n        [string]$Configuration = \"Debug\",\n        [switch]$SaveToFile,\n        [switch]$ErrorsOnly\n    )\n\n    $timestamp = Get-Date -Format \"yyyyMMdd-HHmmss\"\n    $outputFile = \"logs\\build-output-$timestamp.log\"\n\n    # Ensure logs directory exists\n    if (-not (Test-Path \"logs\")) {\n        New-Item -ItemType Directory -Path \"logs\" -Force | Out-Null\n    }\n\n    Write-Host \"??? Building $ProjectPath...\" -ForegroundColor Cyan\n    Write-Host \"?? Configuration: $Configuration\" -ForegroundColor Gray\n\n    if ($SaveToFile) {\n        Write-Host \"?? Full output will be saved to: $outputFile\" -ForegroundColor Yellow\n    }\n\n    # Configure environment for maximum output\n    $env:DOTNET_CLI_UI_LANGUAGE = \"en-US\"\n    $env:DOTNET_NOLOGO = \"false\"  # We want full output\n\n    try {\n        # Capture all output streams with detailed verbosity\n        $verbosity = if ($ErrorsOnly) { \"quiet\" } else { \"detailed\" }\n\n        $startTime = Get-Date\n\n        # Use Start-Process for complete output capture\n        $processInfo = @{\n            FilePath = \"dotnet\"\n            ArgumentList = @(\"build\", $ProjectPath, \"--configuration\", $Configuration, \"--verbosity\", $verbosity, \"--no-restore\")\n            RedirectStandardOutput = $true\n            RedirectStandardError = $true\n            UseShellExecute = $false\n            CreateNoWindow = $true\n        }\n\n        $process = Start-Process @processInfo -PassThru\n\n        # Read output in real-time\n        $stdout = $process.StandardOutput.ReadToEnd()\n        $stderr = $process.StandardError.ReadToEnd()\n\n        $process.WaitForExit()\n        $exitCode = $process.ExitCode\n\n        $endTime = Get-Date\n        $duration = $endTime - $startTime\n\n        # Combine all output\n        $fullOutput = @\"\n=== BUSBUDDY BUILD LOG ===\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\nProject: $ProjectPath\nConfiguration: $Configuration\nDuration: $($duration.TotalSeconds) seconds\nExit Code: $exitCode\n\n=== STANDARD OUTPUT ===\n$stdout\n\n=== STANDARD ERROR ===\n$stderr\n\n=== BUILD SUMMARY ===\n\"@\n\n        # Save to file if requested\n        if ($SaveToFile) {\n            $fullOutput | Out-File -FilePath $outputFile -Encoding UTF8 -Width 500\n            Write-Host \"? Complete build log saved to: $outputFile\" -ForegroundColor Green\n        }\n\n        # Parse and display errors prominently\n        $errorLines = ($stdout + $stderr) -split \"`n\" | Where-Object { $_ -match \"error|Error|ERROR|\\s+CS\\d+|\\s+MSB\\d+\" }\n\n        if ($errorLines) {\n            Write-Host \"`n? BUILD ERRORS FOUND:\" -ForegroundColor Red\n            Write-Host \"=\" * 50 -ForegroundColor Red\n            $errorLines | ForEach-Object {\n                Write-Host $_ -ForegroundColor Red\n            }\n            Write-Host \"=\" * 50 -ForegroundColor Red\n\n            if ($SaveToFile) {\n                Write-Host \"?? Full details in: $outputFile\" -ForegroundColor Yellow\n            }\n        } else {\n            Write-Host \"? No errors found!\" -ForegroundColor Green\n        }\n\n        # Display summary\n        Write-Host \"`n?? BUILD SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"   Duration: $($duration.TotalSeconds) seconds\" -ForegroundColor Gray\n        Write-Host \"   Exit Code: $exitCode\" -ForegroundColor $(if ($exitCode -eq 0) { \"Green\" } else { \"Red\" })\n\n        if ($exitCode -eq 0) {\n            Write-Host \"   Status: SUCCESS ?\" -ForegroundColor Green\n        } else {\n            Write-Host \"   Status: FAILED ?\" -ForegroundColor Red\n        }\n\n        return @{\n            ExitCode = $exitCode\n            Duration = $duration\n            ErrorLines = $errorLines\n            OutputFile = if ($SaveToFile) { $outputFile } else { $null }\n            FullOutput = $fullOutput\n        }\n\n    } catch {\n        Write-Error \"Failed to execute build: $($_.Exception.Message)\"\n        return $null\n    }\n}\n\nfunction Start-BusBuddyBuildFull {\n    <#\n    .SYNOPSIS\n        Enhanced bb-build with complete output capture\n    #>\n    Get-BusBuddyBuildOutput -SaveToFile\n}\n\nfunction Get-BusBuddyBuildErrors {\n    <#\n    .SYNOPSIS\n        Get only build errors without full output\n    #>\n    Get-BusBuddyBuildOutput -ErrorsOnly\n}\n\nfunction Show-BusBuddyBuildLog {\n    <#\n    .SYNOPSIS\n        Show the most recent build log\n    #>\n    $latestLog = Get-ChildItem \"logs\\build-output-*.log\" | Sort-Object LastWriteTime -Descending | Select-Object -First 1\n\n    if ($latestLog) {\n        Write-Host \"?? Most recent build log: $($latestLog.Name)\" -ForegroundColor Cyan\n        Write-Host \"?? Created: $($latestLog.LastWriteTime)\" -ForegroundColor Gray\n        Write-Host \"\"\n        Get-Content $latestLog.FullName\n    } else {\n        Write-Host \"No build logs found. Run Start-BusBuddyBuildFull first.\" -ForegroundColor Yellow\n    }\n}\n\n#endregion\n\n# Export functions\nExport-ModuleMember -Function Get-BusBuddyBuildOutput, Start-BusBuddyBuildFull, Get-BusBuddyBuildErrors, Show-BusBuddyBuildLog\n",
            "Description": "Enhanced build output capture for BusBuddy - eliminates truncated terminal output",
            "Guid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Build Output Capture NoTruncation BusBuddy Build Output Capture NoTruncation",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": "v1.0.0 - Initial release\n- Complete build output capture without truncation\n- Automatic error parsing and highlighting\n- Timestamped log file generation\n- Enhanced terminal buffer configuration",
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Project",
            "Copyright": "(c) 2025 BusBuddy Project. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.BuildOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\nSet-StrictMode -Version 3.0\r\n\r\n# Avoid auto-executing on import - provide wrapper to run the script when requested\r\n$moduleRoot = Split-Path -Parent $PSScriptRoot\r\n$workspaceRoot = Split-Path -Parent (Split-Path -Parent $moduleRoot)\r\n$enhancedTestPath = Join-Path $workspaceRoot 'PowerShell\\Scripts\\Enhanced-Test-Output.ps1'\r\n\r\nfunction Invoke-BusBuddyEnhancedTestOutput {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromRemainingArguments = $true)]\r\n        [object[]] $Args\r\n    )\r\n    if (-not (Test-Path -LiteralPath $enhancedTestPath)) {\r\n        Write-Error \"Enhanced-Test-Output.ps1 not found at: $enhancedTestPath\"\r\n        return\r\n    }\r\n    & $enhancedTestPath @Args\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyEnhancedTestOutput\r\n",
            "Description": "",
            "Guid": "7c6a0d9e-1f2a-4b9e-b5a2-1c5f5d5b8a1c",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy",
            "Copyright": "(c) BusBuddy",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.TestOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.ThemeValidation",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation\\BusBuddy.ThemeValidation.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.ThemeValidation Module\r\n# Validates Syncfusion theme/style consistency across WPF XAML files.\r\n# Docs reference: https://help.syncfusion.com/wpf/themes/overview\r\n\r\nfunction Test-BusBuddyThemeConsistency {\r\n    <#\r\n    .SYNOPSIS\r\n        Scan XAML views for inline Syncfusion control styling violations.\r\n    .DESCRIPTION\r\n        Looks for Syncfusion controls (SfDataGrid, ButtonAdv, DockingManager etc.)\r\n        with inline size/margin/brush properties that should be centralized in resource dictionaries.\r\n    .OUTPUTS\r\n        Hashtable with Issues (string[]) and Status (Success|Failed)\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views'\r\n    )\r\n    $issues = New-Object System.Collections.Generic.List[string]\r\n    if (-not (Test-Path $ViewsPath)) {\r\n        Write-Warning \"Views path not found: $ViewsPath\"\r\n        return @{ Issues = @('Views path missing'); Status = 'Failed' }\r\n    }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    $mergedDictionaries = @{}\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $mergeMatches = [regex]::Matches($content,'<ResourceDictionary\\s+Source=\"([^\"]+)\"')\r\n        foreach ($m in $mergeMatches) { $mergedDictionaries[$m.Groups[1].Value] = $true }\r\n        # Detect inline width/height/margin on Syncfusion ButtonAdv or SfButton / SfDataGrid\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)[^>]*(Width|Height|Margin)=') {\r\n            $issues.Add(\"Inline layout property on Syncfusion button in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:SfDataGrid[^>]*(RowHeight|HeaderRowHeight|Background|BorderBrush)=') {\r\n            $issues.Add(\"Inline SfDataGrid visual property in $($file.Name)\")\r\n        }\r\n        # Missing namespace check (should declare syncfusion namespace where controls appear)\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'xmlns:syncfusion=') {\r\n            $issues.Add(\"Missing syncfusion xmlns in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'FluentDark' -and $content -notmatch 'FluentLight') {\r\n            $issues.Add(\"Potential missing theme reference (FluentDark/FluentLight) in $($file.Name)\")\r\n        }\r\n    }\r\n    if (-not ($mergedDictionaries.Keys | Where-Object { $_ -match 'Themes' })) {\r\n        $issues.Add('No merged resource dictionaries referencing Themes folder detected')\r\n    }\r\n    $status = if ($issues.Count -gt 0) { 'Failed' } else { 'Success' }\r\n    return @{ Issues = $issues.ToArray(); Status = $status; FileCount = $xamlFiles.Count; MergedDictionaries = $mergedDictionaries.Keys }\r\n}\r\n\r\nfunction Invoke-BusBuddyThemeRemediation {\r\n    <#\r\n    .SYNOPSIS\r\n        Attempt automatic remediation of common inline styling issues.\r\n    .DESCRIPTION\r\n        Replaces common inline size/margin attributes on Syncfusion buttons with Style reference.\r\n        Only performs safe textual substitutions; more advanced refactoring deferred post-MVP.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views',\r\n        [string]$ButtonStyleKey = 'SyncfusionPrimaryButtonStyle'\r\n    )\r\n    if (-not (Test-Path $ViewsPath)) { Write-Warning \"Views path not found: $ViewsPath\"; return }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $original = $content\r\n        $modified = $false\r\n        # Replace inline width/height/margin on buttons with style if not already styled\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)' -and $content -notmatch 'Style=\"{StaticResource') {\r\n            $content = [regex]::Replace($content,'(<syncfusion:(?:ButtonAdv|SfButton)[^>]*)(Width|Height|Margin)=\"[^\"]+\"','${1}')\r\n            if ($content -ne $original) { $modified = $true }\r\n            if ($modified) {\r\n                $content = [regex]::Replace($content,'<syncfusion:(ButtonAdv|SfButton)([^>]*)>','<syncfusion:$1$2 Style=\"{StaticResource ' + $ButtonStyleKey + '}\">')\r\n            }\r\n        }\r\n        if ($modified -and $PSCmdlet.ShouldProcess($file.FullName,'Apply style remediation')) {\r\n            $content | Set-Content $file.FullName -Encoding UTF8\r\n            Write-Information \"Remediated: $($file.Name)\" -InformationAction Continue\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyThemeConsistency,Invoke-BusBuddyThemeRemediation\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.AzureSqlHealth",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth\\BusBuddy.AzureSqlHealth.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.AzureSqlHealth Module\r\n# References: https://learn.microsoft.com/azure/azure-sql/database/connectivity-architecture\r\n\r\nfunction Test-BusBuddyAzureSql {\r\n    <#\r\n    .SYNOPSIS\r\n        Test connectivity to Azure SQL (fallback to LocalDB on failure).\r\n    .OUTPUTS\r\n        Bool indicating Azure SQL connectivity success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) {\r\n        Write-Warning \"Azure settings file not found: $SettingsPath\"\r\n        return $false\r\n    }\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 2\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n    $lastError = $null\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n            $connString = $json.ConnectionStrings.DefaultConnection\r\n            if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n            $query = 'SELECT TOP 1 name FROM sys.databases'\r\n            $result = Invoke-Sqlcmd -ConnectionString $connString -Query $query -ErrorAction Stop\r\n            $stopwatch.Stop()\r\n            Write-Information \"? Azure SQL reachable (attempt $attempts) latency=$([math]::Round($stopwatch.Elapsed.TotalMilliseconds,0))ms Databases: $($result.name -join ',')\" -InformationAction Continue\r\n            return $true\r\n        } catch {\r\n            $lastError = $_.Exception.Message\r\n            Write-Warning \"Attempt $attempts failed: $lastError\"\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds *= 2 }\r\n        }\r\n    }\r\n    $stopwatch.Stop()\r\n    Write-Warning \"?? Azure SQL test failed after $attempts attempts: $lastError\"\r\n    return $false\r\n}\r\n\r\nfunction Test-BusBuddyAzureSqlNative {\r\n    <#\r\n    .SYNOPSIS\r\n        Test Azure SQL connectivity using System.Data.SqlClient directly (no sqlcmd dependency).\r\n    .DESCRIPTION\r\n        Reads connection string from appsettings.azure.json (ConnectionStrings.DefaultConnection) and attempts to open a connection\r\n        and run a lightweight query. Implements simple retry with exponential backoff.\r\n        Docs: https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.open\r\n    .OUTPUTS\r\n        Bool indicating success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) { Write-Warning \"Azure settings file not found: $SettingsPath\"; return $false }\r\n    try {\r\n        $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n        $connString = $json.ConnectionStrings.DefaultConnection\r\n        if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n    } catch {\r\n        Write-Warning \"Failed to parse ${SettingsPath}: $($_.Exception.Message)\"; return $false\r\n    }\r\n\r\n    # Expand ${ENV_VAR} placeholders if present in connection string\r\n    # Pattern sourced from standard PowerShell regex usage - see Microsoft Docs: about_Regular_Expressions\r\n    $expandEnv = {\r\n        param([string]$s)\r\n        if ([string]::IsNullOrWhiteSpace($s)) { return $s }\r\n        return [regex]::Replace($s, '\\$\\{([A-Za-z0-9_]+)\\}', {\r\n            param($m)\r\n            $name = $m.Groups[1].Value\r\n            $val  = [Environment]::GetEnvironmentVariable($name)\r\n            if (-not $val) { $m.Value } else { $val }\r\n        })\r\n    }\r\n    $original = $connString\r\n    $connString = & $expandEnv $connString\r\n    if ($connString -match '\\$\\{') {\r\n        Write-Information \"?? One or more environment placeholders are unresolved in connection string (file=${SettingsPath}). Set required variables in the environment before running tests.\" -InformationAction Continue\r\n    }\r\n\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 1\r\n    $sw = [System.Diagnostics.Stopwatch]::StartNew()\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $conn = [System.Data.SqlClient.SqlConnection]::new($connString)\r\n            $conn.Open()\r\n            try {\r\n                $cmd = $conn.CreateCommand()\r\n                $cmd.CommandText = 'SELECT DB_NAME()'\r\n                $db = $cmd.ExecuteScalar()\r\n                $sw.Stop()\r\n                Write-Information (\"? Azure SQL (native) reachable on attempt {0} - DB: {1}, latency={2}ms\" -f $attempts, $db, [math]::Round($sw.Elapsed.TotalMilliseconds,0)) -InformationAction Continue\r\n                return $true\r\n            } finally {\r\n                $conn.Dispose()\r\n            }\r\n        } catch {\r\n            Write-Warning (\"Native attempt {0} failed: {1}\" -f $attempts, $_.Exception.Message)\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds = [Math]::Min($delaySeconds * 2, 8) }\r\n        }\r\n    }\r\n    $sw.Stop()\r\n    Write-Warning \"?? Azure SQL (native) test failed after $attempts attempts.\"\r\n    return $false\r\n}\r\n\r\nfunction Get-BusBuddySqlStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Provide detailed Azure SQL / LocalDB status summary.\r\n    .OUTPUTS\r\n        Hashtable with status fields.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$AzureSettingsPath = 'appsettings.azure.json',\r\n        [string]$LocalSettingsPath = 'appsettings.json'\r\n    )\r\n    $status = [ordered]@{}\r\n    $status.Timestamp = Get-Date\r\n    $status.AzureSettingsPresent = Test-Path $AzureSettingsPath\r\n    $status.LocalSettingsPresent = Test-Path $LocalSettingsPath\r\n    $status.AzureReachable = $false\r\n    $status.LocalDbReachable = $false\r\n\r\n    if ($status.AzureSettingsPresent) {\r\n        $status.AzureReachable = Test-BusBuddyAzureSql -SettingsPath $AzureSettingsPath\r\n    }\r\n    # LocalDB quick probe via sqlcmd if installed\r\n    try {\r\n        $localJson = if (Test-Path $LocalSettingsPath) { Get-Content $LocalSettingsPath -Raw | ConvertFrom-Json } else { $null }\r\n        $localConn = $localJson.ConnectionStrings.DefaultConnection\r\n        if ($localConn -and $localConn -match 'localdb') {\r\n            try {\r\n                Invoke-Sqlcmd -ConnectionString $localConn -Query 'SELECT 1' -ErrorAction Stop | Out-Null\r\n                $status.LocalDbReachable = $true\r\n            } catch {\r\n                $status.LocalDbReachable = $false\r\n            }\r\n        }\r\n    } catch {\r\n        $status.LocalDbReachable = $false\r\n    }\r\n\r\n    $status.PrimaryDataSource = if ($status.AzureReachable) { 'Azure' } elseif ($status.LocalDbReachable) { 'LocalDB' } else { 'Unknown' }\r\n    return $status\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyAzureSql,Test-BusBuddyAzureSqlNative,Get-BusBuddySqlStatus\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestWatcher",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher\\BusBuddy.TestWatcher.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.TestWatcher Module\r\n# Provides debounced file change watching to trigger targeted test runs.\r\n\r\nfunction Start-BusBuddyTestWatchAdvanced {\r\n    <#\r\n    .SYNOPSIS\r\n        Start debounced test watch loop for a specific test suite.\r\n    .DESCRIPTION\r\n        Watches for changes to .cs and .xaml files under repo root and re-runs Get-BusBuddyTestOutput.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite = 'Unit',\r\n        [int]$DebounceSeconds = 2,\r\n        [switch]$RetryOnFailure,\r\n        [int]$MaxRetries = 2,\r\n        [int]$RetryDelaySeconds = 2\r\n    )\r\n    if ($script:BusBuddyTestWatchHandle) { Write-Warning 'Test watch already running.'; return }\r\n    $root = Get-Location\r\n    Write-Information \"?? Watching $root for changes (suite=$TestSuite, debounce=${DebounceSeconds}s)\" -InformationAction Continue\r\n    $watcher = New-Object System.IO.FileSystemWatcher -Property @{ Path = $root; Filter = '*.*'; IncludeSubdirectories = $true; EnableRaisingEvents = $true }\r\n    $script:BusBuddyTestWatchLastRun = Get-Date 0\r\n    $script:BusBuddyTestWatchIgnored = 0\r\n    $script:BusBuddyTestWatchTriggered = 0\r\n    $script:BusBuddyTestWatchFailures = 0\r\n    $script:BusBuddyTestWatchRetries = 0\r\n    # Correlation ID for this watcher session\r\n    $script:BusBuddyTestWatchCorrelation = [guid]::NewGuid().ToString()\r\n    $action = {\r\n        $full = $Event.SourceEventArgs.FullPath\r\n        $ext = [IO.Path]::GetExtension($full)\r\n        if ($ext -notin '.cs','.xaml') {\r\n            Write-Verbose (\"Ignoring change due to unsupported extension: {0}\" -f $ext)\r\n            return\r\n        }\r\n        # Ignore build/test artifacts to avoid infinite loops (bin/obj/TestResults/.git/.vs)\r\n        if ($full -match \"(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\\") {\r\n            $script:BusBuddyTestWatchIgnored++\r\n            Write-Verbose (\"Ignoring change in excluded path: {0}\" -f $full)\r\n            return\r\n        }\r\n        $now = Get-Date\r\n        $elapsed = ($now - $script:BusBuddyTestWatchLastRun).TotalSeconds\r\n        if ($elapsed -lt $using:DebounceSeconds) {\r\n            $remaining = [math]::Max([int]([math]::Ceiling($using:DebounceSeconds - $elapsed)), 0)\r\n            Write-Verbose (\"Debounce active - event suppressed. Time remaining: {0}s\" -f $remaining)\r\n            return\r\n        }\r\n        $script:BusBuddyTestWatchLastRun = $now\r\n        $script:BusBuddyTestWatchTriggered++\r\n        Write-Information \"?? [$script:BusBuddyTestWatchCorrelation] Change detected: $($Event.SourceEventArgs.Name) -> running $using:TestSuite tests (trigger #$script:BusBuddyTestWatchTriggered, ignored so far=$script:BusBuddyTestWatchIgnored)\" -InformationAction Continue\r\n        try {\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n        } catch {\r\n            $script:BusBuddyTestWatchFailures++\r\n            Write-Warning \"[$script:BusBuddyTestWatchCorrelation] Test watch run failed (#$script:BusBuddyTestWatchFailures): $($_.Exception.Message)\"\r\n            if ($using:RetryOnFailure) {\r\n                $attempt = 0\r\n                $delay = [int]$using:RetryDelaySeconds\r\n                while ($attempt -lt [int]$using:MaxRetries) {\r\n                    $attempt++\r\n                    $script:BusBuddyTestWatchRetries++\r\n                    Write-Information (\"?? [$script:BusBuddyTestWatchCorrelation] Retry trigger #{0} (attempt {1}/{2}) after failure - waiting {3}s...\" -f $script:BusBuddyTestWatchRetries, $attempt, [int]$using:MaxRetries, $delay) -InformationAction Continue\r\n                    Start-Sleep -Seconds $delay\r\n                    try {\r\n                        Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n                        Write-Information \"? [$script:BusBuddyTestWatchCorrelation] Retry succeeded on attempt $attempt\" -InformationAction Continue\r\n                        break\r\n                    } catch {\r\n                        Write-Warning (\"[$script:BusBuddyTestWatchCorrelation] Retry attempt {0} failed: {1}\" -f $attempt, $_.Exception.Message)\r\n                        $delay = [math]::Min($delay * 2, 30)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $handler = Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action\r\n    $script:BusBuddyTestWatchHandle = @{ Watcher = $watcher; Handler = $handler }\r\n    Write-Information \"Press Ctrl+C or run Stop-BusBuddyTestWatchAdvanced to stop. CorrelationId=$script:BusBuddyTestWatchCorrelation\" -InformationAction Continue\r\n}\r\n\r\nfunction Stop-BusBuddyTestWatchAdvanced {\r\n    [CmdletBinding()] param()\r\n    if (-not $script:BusBuddyTestWatchHandle) { Write-Warning 'No active test watch.'; return }\r\n    try {\r\n        $script:BusBuddyTestWatchHandle.Handler | Unregister-Event -ErrorAction SilentlyContinue\r\n        $script:BusBuddyTestWatchHandle.Watcher.EnableRaisingEvents = $false\r\n        $script:BusBuddyTestWatchHandle.Watcher.Dispose()\r\n        Write-Information '?? Test watch stopped.' -InformationAction Continue\r\n    } finally { Remove-Variable BusBuddyTestWatchHandle -Scope Script -ErrorAction SilentlyContinue }\r\n}\r\n\r\nExport-ModuleMember -Function Start-BusBuddyTestWatchAdvanced,Stop-BusBuddyTestWatchAdvanced\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.Cleanup",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup\\BusBuddy.Cleanup.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.Cleanup Module\r\n# Implements repository hygiene and artifact cleanup per project guidelines.\r\n\r\nfunction Invoke-BusBuddyCleanup {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove build artifacts and old log files.\r\n    .DESCRIPTION\r\n        Deletes bin/, obj/, TestResults/, and logs older than a retention window (default 7 days).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$LogRetentionDays = 7,\r\n        [switch]$IncludeNodeModules\r\n    )\r\n    $paths = @('bin','obj','TestResults')\r\n    if ($IncludeNodeModules) { $paths += 'node_modules' }\r\n    foreach ($p in $paths) {\r\n        Get-ChildItem -Recurse -Directory -Filter $p -ErrorAction SilentlyContinue | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove directory')) {\r\n                try { Remove-Item $_.FullName -Recurse -Force -ErrorAction Stop; Write-Information \"??? Removed $($_.FullName)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove $($_.FullName): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    if (Test-Path logs) {\r\n        $threshold = (Get-Date).AddDays(-$LogRetentionDays)\r\n        Get-ChildItem logs -File -Include *.log -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold } | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove old log')) {\r\n                try { Remove-Item $_.FullName -Force; Write-Information \"?? Removed old log $($_.Name)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove log $($_.Name): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Identify candidate unused .cs/.xaml files not referenced in solution or project includes.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([string[]])]\r\n    param(\r\n        [string]$Root = '.'\r\n    )\r\n    $solution = Get-ChildItem -Path $Root -Filter *.sln -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1\r\n    if (-not $solution) { Write-Warning 'Solution file not found.'; return @() }\r\n    $solutionText = Get-Content $solution.FullName -Raw\r\n    $candidates = Get-ChildItem $Root -Recurse -Include *.cs,*.xaml -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'bin\\\\|obj\\\\|TestResults\\\\|\\.git' }\r\n    $unused = @()\r\n    foreach ($f in $candidates) {\r\n        if ($solutionText -notmatch [regex]::Escape($f.Name)) { $unused += $f.FullName }\r\n    }\r\n    return $unused\r\n}\r\n\r\nfunction Remove-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove unused files interactively (WhatIf supported).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Medium')]\r\n    param(\r\n        [string]$Root='.'\r\n    )\r\n    $unused = Get-BusBuddyUnusedFiles -Root $Root\r\n    if (-not $unused -or $unused.Count -eq 0) { Write-Information 'No unused files detected.' -InformationAction Continue; return }\r\n    foreach ($file in $unused) {\r\n        if ($PSCmdlet.ShouldProcess($file,'Remove unused file')) {\r\n            try { Remove-Item $file -Force; Write-Information \"Removed unused file $file\" -InformationAction Continue } catch { $warn = 'Failed to remove ' + $file + ' -> ' + $_.Exception.Message; Write-Warning $warn }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyCleanup,Get-BusBuddyUnusedFiles,Remove-BusBuddyUnusedFiles\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          }
        ],
        "PowerShellHostName": null,
        "PowerShellHostVersion": null,
        "PowerShellVersion": {
          "Major": 7,
          "Minor": 5,
          "Build": -1,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ProcessorArchitecture": 0,
        "Scripts": [],
        "RequiredAssemblies": [],
        "RequiredModules": [],
        "RootModule": "BusBuddy.psm1",
        "ExportedVariables": {},
        "ExportedAliases": {
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "ExportedDscResources": [],
        "SessionState": {
          "Drive": {
            "Current": "C"
          },
          "Provider": {},
          "Path": {
            "CurrentLocation": "C:\\Users\\biges\\Desktop\\BusBuddy",
            "CurrentFileSystemLocation": "C:\\Users\\biges\\Desktop\\BusBuddy"
          },
          "PSVariable": {},
          "LanguageMode": 0,
          "UseFullLanguageModeInDebugger": false,
          "Scripts": [
            "*"
          ],
          "Applications": [
            "*"
          ],
          "Module": {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
            "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
            "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Development WPF DotNet BusBuddy Development WPF DotNet",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "RepositorySourceLocation": null,
            "Version": "2.0.0",
            "ModuleType": 0,
            "Author": "Bus Buddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Team",
            "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1",
            "CompatiblePSEditions": "Core",
            "ModuleList": "",
            "NestedModules": "BusBuddy.BuildOutput BusBuddy.TestOutput BusBuddy.ThemeValidation BusBuddy.AzureSqlHealth BusBuddy.TestWatcher BusBuddy.Cleanup",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          "InvokeProvider": {
            "Item": "System.Management.Automation.ItemCmdletProviderIntrinsics",
            "ChildItem": "System.Management.Automation.ChildItemCmdletProviderIntrinsics",
            "Content": "System.Management.Automation.ContentCmdletProviderIntrinsics",
            "Property": "System.Management.Automation.PropertyCmdletProviderIntrinsics",
            "SecurityDescriptor": "System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics"
          },
          "InvokeCommand": {
            "HasErrors": null,
            "CommandNotFoundAction": null,
            "PreCommandLookupAction": null,
            "PostCommandLookupAction": null,
            "LocationChangedAction": null
          }
        },
        "OnRemove": null,
        "ExportedFormatFiles": [],
        "ExportedTypeFiles": []
      }
    },
    {
      "Definition": "Invoke-BusBuddyBuild",
      "Name": "bbBuild",
      "Options": "None",
      "Module": {
        "LogPipelineExecutionDetails": false,
        "Name": "BusBuddy",
        "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
        "ImplementingAssembly": null,
        "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
        "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
        "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
        "HelpInfoUri": null,
        "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
        "PrivateData": {
          "PSData": {
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "Tags": "BusBuddy Development WPF DotNet"
          }
        },
        "ExperimentalFeatures": [],
        "Tags": [
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet",
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet"
        ],
        "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
        "IconUri": null,
        "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
        "ReleaseNotes": "Streamlined core module for reliable development workflow",
        "RepositorySourceLocation": null,
        "Version": {
          "Major": 2,
          "Minor": 0,
          "Build": 0,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ModuleType": 0,
        "Author": "Bus Buddy Development Team",
        "AccessMode": 0,
        "ClrVersion": null,
        "CompanyName": "BusBuddy Team",
        "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
        "DotNetFrameworkVersion": null,
        "ExportedFunctions": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          }
        },
        "Prefix": "",
        "ExportedCmdlets": {},
        "ExportedCommands": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "FileList": [
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1"
        ],
        "CompatiblePSEditions": [
          "Core"
        ],
        "ModuleList": [],
        "NestedModules": [
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.BuildOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "# Enhanced Build Commands with No Truncation\n# Part of BusBuddy PowerShell Module\n\n#region Enhanced Build Functions\n\nfunction Get-BusBuddyBuildOutput {\n    <#\n    .SYNOPSIS\n        Get complete build output without truncation\n\n    .DESCRIPTION\n        Captures full dotnet build output to both console and file, preventing truncation issues\n\n    .PARAMETER ProjectPath\n        Path to solution or project file\n\n    .PARAMETER Configuration\n        Build configuration (Debug/Release)\n\n    .PARAMETER SaveToFile\n        Save complete output to timestamped file\n\n    .EXAMPLE\n        Get-BusBuddyBuildOutput -SaveToFile\n    #>\n    [CmdletBinding()]\n    param(\n        [string]$ProjectPath = \"BusBuddy.sln\",\n        [string]$Configuration = \"Debug\",\n        [switch]$SaveToFile,\n        [switch]$ErrorsOnly\n    )\n\n    $timestamp = Get-Date -Format \"yyyyMMdd-HHmmss\"\n    $outputFile = \"logs\\build-output-$timestamp.log\"\n\n    # Ensure logs directory exists\n    if (-not (Test-Path \"logs\")) {\n        New-Item -ItemType Directory -Path \"logs\" -Force | Out-Null\n    }\n\n    Write-Host \"??? Building $ProjectPath...\" -ForegroundColor Cyan\n    Write-Host \"?? Configuration: $Configuration\" -ForegroundColor Gray\n\n    if ($SaveToFile) {\n        Write-Host \"?? Full output will be saved to: $outputFile\" -ForegroundColor Yellow\n    }\n\n    # Configure environment for maximum output\n    $env:DOTNET_CLI_UI_LANGUAGE = \"en-US\"\n    $env:DOTNET_NOLOGO = \"false\"  # We want full output\n\n    try {\n        # Capture all output streams with detailed verbosity\n        $verbosity = if ($ErrorsOnly) { \"quiet\" } else { \"detailed\" }\n\n        $startTime = Get-Date\n\n        # Use Start-Process for complete output capture\n        $processInfo = @{\n            FilePath = \"dotnet\"\n            ArgumentList = @(\"build\", $ProjectPath, \"--configuration\", $Configuration, \"--verbosity\", $verbosity, \"--no-restore\")\n            RedirectStandardOutput = $true\n            RedirectStandardError = $true\n            UseShellExecute = $false\n            CreateNoWindow = $true\n        }\n\n        $process = Start-Process @processInfo -PassThru\n\n        # Read output in real-time\n        $stdout = $process.StandardOutput.ReadToEnd()\n        $stderr = $process.StandardError.ReadToEnd()\n\n        $process.WaitForExit()\n        $exitCode = $process.ExitCode\n\n        $endTime = Get-Date\n        $duration = $endTime - $startTime\n\n        # Combine all output\n        $fullOutput = @\"\n=== BUSBUDDY BUILD LOG ===\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\nProject: $ProjectPath\nConfiguration: $Configuration\nDuration: $($duration.TotalSeconds) seconds\nExit Code: $exitCode\n\n=== STANDARD OUTPUT ===\n$stdout\n\n=== STANDARD ERROR ===\n$stderr\n\n=== BUILD SUMMARY ===\n\"@\n\n        # Save to file if requested\n        if ($SaveToFile) {\n            $fullOutput | Out-File -FilePath $outputFile -Encoding UTF8 -Width 500\n            Write-Host \"? Complete build log saved to: $outputFile\" -ForegroundColor Green\n        }\n\n        # Parse and display errors prominently\n        $errorLines = ($stdout + $stderr) -split \"`n\" | Where-Object { $_ -match \"error|Error|ERROR|\\s+CS\\d+|\\s+MSB\\d+\" }\n\n        if ($errorLines) {\n            Write-Host \"`n? BUILD ERRORS FOUND:\" -ForegroundColor Red\n            Write-Host \"=\" * 50 -ForegroundColor Red\n            $errorLines | ForEach-Object {\n                Write-Host $_ -ForegroundColor Red\n            }\n            Write-Host \"=\" * 50 -ForegroundColor Red\n\n            if ($SaveToFile) {\n                Write-Host \"?? Full details in: $outputFile\" -ForegroundColor Yellow\n            }\n        } else {\n            Write-Host \"? No errors found!\" -ForegroundColor Green\n        }\n\n        # Display summary\n        Write-Host \"`n?? BUILD SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"   Duration: $($duration.TotalSeconds) seconds\" -ForegroundColor Gray\n        Write-Host \"   Exit Code: $exitCode\" -ForegroundColor $(if ($exitCode -eq 0) { \"Green\" } else { \"Red\" })\n\n        if ($exitCode -eq 0) {\n            Write-Host \"   Status: SUCCESS ?\" -ForegroundColor Green\n        } else {\n            Write-Host \"   Status: FAILED ?\" -ForegroundColor Red\n        }\n\n        return @{\n            ExitCode = $exitCode\n            Duration = $duration\n            ErrorLines = $errorLines\n            OutputFile = if ($SaveToFile) { $outputFile } else { $null }\n            FullOutput = $fullOutput\n        }\n\n    } catch {\n        Write-Error \"Failed to execute build: $($_.Exception.Message)\"\n        return $null\n    }\n}\n\nfunction Start-BusBuddyBuildFull {\n    <#\n    .SYNOPSIS\n        Enhanced bb-build with complete output capture\n    #>\n    Get-BusBuddyBuildOutput -SaveToFile\n}\n\nfunction Get-BusBuddyBuildErrors {\n    <#\n    .SYNOPSIS\n        Get only build errors without full output\n    #>\n    Get-BusBuddyBuildOutput -ErrorsOnly\n}\n\nfunction Show-BusBuddyBuildLog {\n    <#\n    .SYNOPSIS\n        Show the most recent build log\n    #>\n    $latestLog = Get-ChildItem \"logs\\build-output-*.log\" | Sort-Object LastWriteTime -Descending | Select-Object -First 1\n\n    if ($latestLog) {\n        Write-Host \"?? Most recent build log: $($latestLog.Name)\" -ForegroundColor Cyan\n        Write-Host \"?? Created: $($latestLog.LastWriteTime)\" -ForegroundColor Gray\n        Write-Host \"\"\n        Get-Content $latestLog.FullName\n    } else {\n        Write-Host \"No build logs found. Run Start-BusBuddyBuildFull first.\" -ForegroundColor Yellow\n    }\n}\n\n#endregion\n\n# Export functions\nExport-ModuleMember -Function Get-BusBuddyBuildOutput, Start-BusBuddyBuildFull, Get-BusBuddyBuildErrors, Show-BusBuddyBuildLog\n",
            "Description": "Enhanced build output capture for BusBuddy - eliminates truncated terminal output",
            "Guid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Build Output Capture NoTruncation BusBuddy Build Output Capture NoTruncation",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": "v1.0.0 - Initial release\n- Complete build output capture without truncation\n- Automatic error parsing and highlighting\n- Timestamped log file generation\n- Enhanced terminal buffer configuration",
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Project",
            "Copyright": "(c) 2025 BusBuddy Project. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.BuildOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\nSet-StrictMode -Version 3.0\r\n\r\n# Avoid auto-executing on import - provide wrapper to run the script when requested\r\n$moduleRoot = Split-Path -Parent $PSScriptRoot\r\n$workspaceRoot = Split-Path -Parent (Split-Path -Parent $moduleRoot)\r\n$enhancedTestPath = Join-Path $workspaceRoot 'PowerShell\\Scripts\\Enhanced-Test-Output.ps1'\r\n\r\nfunction Invoke-BusBuddyEnhancedTestOutput {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromRemainingArguments = $true)]\r\n        [object[]] $Args\r\n    )\r\n    if (-not (Test-Path -LiteralPath $enhancedTestPath)) {\r\n        Write-Error \"Enhanced-Test-Output.ps1 not found at: $enhancedTestPath\"\r\n        return\r\n    }\r\n    & $enhancedTestPath @Args\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyEnhancedTestOutput\r\n",
            "Description": "",
            "Guid": "7c6a0d9e-1f2a-4b9e-b5a2-1c5f5d5b8a1c",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy",
            "Copyright": "(c) BusBuddy",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.TestOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.ThemeValidation",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation\\BusBuddy.ThemeValidation.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.ThemeValidation Module\r\n# Validates Syncfusion theme/style consistency across WPF XAML files.\r\n# Docs reference: https://help.syncfusion.com/wpf/themes/overview\r\n\r\nfunction Test-BusBuddyThemeConsistency {\r\n    <#\r\n    .SYNOPSIS\r\n        Scan XAML views for inline Syncfusion control styling violations.\r\n    .DESCRIPTION\r\n        Looks for Syncfusion controls (SfDataGrid, ButtonAdv, DockingManager etc.)\r\n        with inline size/margin/brush properties that should be centralized in resource dictionaries.\r\n    .OUTPUTS\r\n        Hashtable with Issues (string[]) and Status (Success|Failed)\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views'\r\n    )\r\n    $issues = New-Object System.Collections.Generic.List[string]\r\n    if (-not (Test-Path $ViewsPath)) {\r\n        Write-Warning \"Views path not found: $ViewsPath\"\r\n        return @{ Issues = @('Views path missing'); Status = 'Failed' }\r\n    }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    $mergedDictionaries = @{}\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $mergeMatches = [regex]::Matches($content,'<ResourceDictionary\\s+Source=\"([^\"]+)\"')\r\n        foreach ($m in $mergeMatches) { $mergedDictionaries[$m.Groups[1].Value] = $true }\r\n        # Detect inline width/height/margin on Syncfusion ButtonAdv or SfButton / SfDataGrid\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)[^>]*(Width|Height|Margin)=') {\r\n            $issues.Add(\"Inline layout property on Syncfusion button in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:SfDataGrid[^>]*(RowHeight|HeaderRowHeight|Background|BorderBrush)=') {\r\n            $issues.Add(\"Inline SfDataGrid visual property in $($file.Name)\")\r\n        }\r\n        # Missing namespace check (should declare syncfusion namespace where controls appear)\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'xmlns:syncfusion=') {\r\n            $issues.Add(\"Missing syncfusion xmlns in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'FluentDark' -and $content -notmatch 'FluentLight') {\r\n            $issues.Add(\"Potential missing theme reference (FluentDark/FluentLight) in $($file.Name)\")\r\n        }\r\n    }\r\n    if (-not ($mergedDictionaries.Keys | Where-Object { $_ -match 'Themes' })) {\r\n        $issues.Add('No merged resource dictionaries referencing Themes folder detected')\r\n    }\r\n    $status = if ($issues.Count -gt 0) { 'Failed' } else { 'Success' }\r\n    return @{ Issues = $issues.ToArray(); Status = $status; FileCount = $xamlFiles.Count; MergedDictionaries = $mergedDictionaries.Keys }\r\n}\r\n\r\nfunction Invoke-BusBuddyThemeRemediation {\r\n    <#\r\n    .SYNOPSIS\r\n        Attempt automatic remediation of common inline styling issues.\r\n    .DESCRIPTION\r\n        Replaces common inline size/margin attributes on Syncfusion buttons with Style reference.\r\n        Only performs safe textual substitutions; more advanced refactoring deferred post-MVP.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views',\r\n        [string]$ButtonStyleKey = 'SyncfusionPrimaryButtonStyle'\r\n    )\r\n    if (-not (Test-Path $ViewsPath)) { Write-Warning \"Views path not found: $ViewsPath\"; return }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $original = $content\r\n        $modified = $false\r\n        # Replace inline width/height/margin on buttons with style if not already styled\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)' -and $content -notmatch 'Style=\"{StaticResource') {\r\n            $content = [regex]::Replace($content,'(<syncfusion:(?:ButtonAdv|SfButton)[^>]*)(Width|Height|Margin)=\"[^\"]+\"','${1}')\r\n            if ($content -ne $original) { $modified = $true }\r\n            if ($modified) {\r\n                $content = [regex]::Replace($content,'<syncfusion:(ButtonAdv|SfButton)([^>]*)>','<syncfusion:$1$2 Style=\"{StaticResource ' + $ButtonStyleKey + '}\">')\r\n            }\r\n        }\r\n        if ($modified -and $PSCmdlet.ShouldProcess($file.FullName,'Apply style remediation')) {\r\n            $content | Set-Content $file.FullName -Encoding UTF8\r\n            Write-Information \"Remediated: $($file.Name)\" -InformationAction Continue\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyThemeConsistency,Invoke-BusBuddyThemeRemediation\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.AzureSqlHealth",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth\\BusBuddy.AzureSqlHealth.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.AzureSqlHealth Module\r\n# References: https://learn.microsoft.com/azure/azure-sql/database/connectivity-architecture\r\n\r\nfunction Test-BusBuddyAzureSql {\r\n    <#\r\n    .SYNOPSIS\r\n        Test connectivity to Azure SQL (fallback to LocalDB on failure).\r\n    .OUTPUTS\r\n        Bool indicating Azure SQL connectivity success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) {\r\n        Write-Warning \"Azure settings file not found: $SettingsPath\"\r\n        return $false\r\n    }\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 2\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n    $lastError = $null\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n            $connString = $json.ConnectionStrings.DefaultConnection\r\n            if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n            $query = 'SELECT TOP 1 name FROM sys.databases'\r\n            $result = Invoke-Sqlcmd -ConnectionString $connString -Query $query -ErrorAction Stop\r\n            $stopwatch.Stop()\r\n            Write-Information \"? Azure SQL reachable (attempt $attempts) latency=$([math]::Round($stopwatch.Elapsed.TotalMilliseconds,0))ms Databases: $($result.name -join ',')\" -InformationAction Continue\r\n            return $true\r\n        } catch {\r\n            $lastError = $_.Exception.Message\r\n            Write-Warning \"Attempt $attempts failed: $lastError\"\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds *= 2 }\r\n        }\r\n    }\r\n    $stopwatch.Stop()\r\n    Write-Warning \"?? Azure SQL test failed after $attempts attempts: $lastError\"\r\n    return $false\r\n}\r\n\r\nfunction Test-BusBuddyAzureSqlNative {\r\n    <#\r\n    .SYNOPSIS\r\n        Test Azure SQL connectivity using System.Data.SqlClient directly (no sqlcmd dependency).\r\n    .DESCRIPTION\r\n        Reads connection string from appsettings.azure.json (ConnectionStrings.DefaultConnection) and attempts to open a connection\r\n        and run a lightweight query. Implements simple retry with exponential backoff.\r\n        Docs: https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.open\r\n    .OUTPUTS\r\n        Bool indicating success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) { Write-Warning \"Azure settings file not found: $SettingsPath\"; return $false }\r\n    try {\r\n        $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n        $connString = $json.ConnectionStrings.DefaultConnection\r\n        if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n    } catch {\r\n        Write-Warning \"Failed to parse ${SettingsPath}: $($_.Exception.Message)\"; return $false\r\n    }\r\n\r\n    # Expand ${ENV_VAR} placeholders if present in connection string\r\n    # Pattern sourced from standard PowerShell regex usage - see Microsoft Docs: about_Regular_Expressions\r\n    $expandEnv = {\r\n        param([string]$s)\r\n        if ([string]::IsNullOrWhiteSpace($s)) { return $s }\r\n        return [regex]::Replace($s, '\\$\\{([A-Za-z0-9_]+)\\}', {\r\n            param($m)\r\n            $name = $m.Groups[1].Value\r\n            $val  = [Environment]::GetEnvironmentVariable($name)\r\n            if (-not $val) { $m.Value } else { $val }\r\n        })\r\n    }\r\n    $original = $connString\r\n    $connString = & $expandEnv $connString\r\n    if ($connString -match '\\$\\{') {\r\n        Write-Information \"?? One or more environment placeholders are unresolved in connection string (file=${SettingsPath}). Set required variables in the environment before running tests.\" -InformationAction Continue\r\n    }\r\n\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 1\r\n    $sw = [System.Diagnostics.Stopwatch]::StartNew()\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $conn = [System.Data.SqlClient.SqlConnection]::new($connString)\r\n            $conn.Open()\r\n            try {\r\n                $cmd = $conn.CreateCommand()\r\n                $cmd.CommandText = 'SELECT DB_NAME()'\r\n                $db = $cmd.ExecuteScalar()\r\n                $sw.Stop()\r\n                Write-Information (\"? Azure SQL (native) reachable on attempt {0} - DB: {1}, latency={2}ms\" -f $attempts, $db, [math]::Round($sw.Elapsed.TotalMilliseconds,0)) -InformationAction Continue\r\n                return $true\r\n            } finally {\r\n                $conn.Dispose()\r\n            }\r\n        } catch {\r\n            Write-Warning (\"Native attempt {0} failed: {1}\" -f $attempts, $_.Exception.Message)\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds = [Math]::Min($delaySeconds * 2, 8) }\r\n        }\r\n    }\r\n    $sw.Stop()\r\n    Write-Warning \"?? Azure SQL (native) test failed after $attempts attempts.\"\r\n    return $false\r\n}\r\n\r\nfunction Get-BusBuddySqlStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Provide detailed Azure SQL / LocalDB status summary.\r\n    .OUTPUTS\r\n        Hashtable with status fields.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$AzureSettingsPath = 'appsettings.azure.json',\r\n        [string]$LocalSettingsPath = 'appsettings.json'\r\n    )\r\n    $status = [ordered]@{}\r\n    $status.Timestamp = Get-Date\r\n    $status.AzureSettingsPresent = Test-Path $AzureSettingsPath\r\n    $status.LocalSettingsPresent = Test-Path $LocalSettingsPath\r\n    $status.AzureReachable = $false\r\n    $status.LocalDbReachable = $false\r\n\r\n    if ($status.AzureSettingsPresent) {\r\n        $status.AzureReachable = Test-BusBuddyAzureSql -SettingsPath $AzureSettingsPath\r\n    }\r\n    # LocalDB quick probe via sqlcmd if installed\r\n    try {\r\n        $localJson = if (Test-Path $LocalSettingsPath) { Get-Content $LocalSettingsPath -Raw | ConvertFrom-Json } else { $null }\r\n        $localConn = $localJson.ConnectionStrings.DefaultConnection\r\n        if ($localConn -and $localConn -match 'localdb') {\r\n            try {\r\n                Invoke-Sqlcmd -ConnectionString $localConn -Query 'SELECT 1' -ErrorAction Stop | Out-Null\r\n                $status.LocalDbReachable = $true\r\n            } catch {\r\n                $status.LocalDbReachable = $false\r\n            }\r\n        }\r\n    } catch {\r\n        $status.LocalDbReachable = $false\r\n    }\r\n\r\n    $status.PrimaryDataSource = if ($status.AzureReachable) { 'Azure' } elseif ($status.LocalDbReachable) { 'LocalDB' } else { 'Unknown' }\r\n    return $status\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyAzureSql,Test-BusBuddyAzureSqlNative,Get-BusBuddySqlStatus\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestWatcher",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher\\BusBuddy.TestWatcher.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.TestWatcher Module\r\n# Provides debounced file change watching to trigger targeted test runs.\r\n\r\nfunction Start-BusBuddyTestWatchAdvanced {\r\n    <#\r\n    .SYNOPSIS\r\n        Start debounced test watch loop for a specific test suite.\r\n    .DESCRIPTION\r\n        Watches for changes to .cs and .xaml files under repo root and re-runs Get-BusBuddyTestOutput.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite = 'Unit',\r\n        [int]$DebounceSeconds = 2,\r\n        [switch]$RetryOnFailure,\r\n        [int]$MaxRetries = 2,\r\n        [int]$RetryDelaySeconds = 2\r\n    )\r\n    if ($script:BusBuddyTestWatchHandle) { Write-Warning 'Test watch already running.'; return }\r\n    $root = Get-Location\r\n    Write-Information \"?? Watching $root for changes (suite=$TestSuite, debounce=${DebounceSeconds}s)\" -InformationAction Continue\r\n    $watcher = New-Object System.IO.FileSystemWatcher -Property @{ Path = $root; Filter = '*.*'; IncludeSubdirectories = $true; EnableRaisingEvents = $true }\r\n    $script:BusBuddyTestWatchLastRun = Get-Date 0\r\n    $script:BusBuddyTestWatchIgnored = 0\r\n    $script:BusBuddyTestWatchTriggered = 0\r\n    $script:BusBuddyTestWatchFailures = 0\r\n    $script:BusBuddyTestWatchRetries = 0\r\n    # Correlation ID for this watcher session\r\n    $script:BusBuddyTestWatchCorrelation = [guid]::NewGuid().ToString()\r\n    $action = {\r\n        $full = $Event.SourceEventArgs.FullPath\r\n        $ext = [IO.Path]::GetExtension($full)\r\n        if ($ext -notin '.cs','.xaml') {\r\n            Write-Verbose (\"Ignoring change due to unsupported extension: {0}\" -f $ext)\r\n            return\r\n        }\r\n        # Ignore build/test artifacts to avoid infinite loops (bin/obj/TestResults/.git/.vs)\r\n        if ($full -match \"(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\\") {\r\n            $script:BusBuddyTestWatchIgnored++\r\n            Write-Verbose (\"Ignoring change in excluded path: {0}\" -f $full)\r\n            return\r\n        }\r\n        $now = Get-Date\r\n        $elapsed = ($now - $script:BusBuddyTestWatchLastRun).TotalSeconds\r\n        if ($elapsed -lt $using:DebounceSeconds) {\r\n            $remaining = [math]::Max([int]([math]::Ceiling($using:DebounceSeconds - $elapsed)), 0)\r\n            Write-Verbose (\"Debounce active - event suppressed. Time remaining: {0}s\" -f $remaining)\r\n            return\r\n        }\r\n        $script:BusBuddyTestWatchLastRun = $now\r\n        $script:BusBuddyTestWatchTriggered++\r\n        Write-Information \"?? [$script:BusBuddyTestWatchCorrelation] Change detected: $($Event.SourceEventArgs.Name) -> running $using:TestSuite tests (trigger #$script:BusBuddyTestWatchTriggered, ignored so far=$script:BusBuddyTestWatchIgnored)\" -InformationAction Continue\r\n        try {\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n        } catch {\r\n            $script:BusBuddyTestWatchFailures++\r\n            Write-Warning \"[$script:BusBuddyTestWatchCorrelation] Test watch run failed (#$script:BusBuddyTestWatchFailures): $($_.Exception.Message)\"\r\n            if ($using:RetryOnFailure) {\r\n                $attempt = 0\r\n                $delay = [int]$using:RetryDelaySeconds\r\n                while ($attempt -lt [int]$using:MaxRetries) {\r\n                    $attempt++\r\n                    $script:BusBuddyTestWatchRetries++\r\n                    Write-Information (\"?? [$script:BusBuddyTestWatchCorrelation] Retry trigger #{0} (attempt {1}/{2}) after failure - waiting {3}s...\" -f $script:BusBuddyTestWatchRetries, $attempt, [int]$using:MaxRetries, $delay) -InformationAction Continue\r\n                    Start-Sleep -Seconds $delay\r\n                    try {\r\n                        Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n                        Write-Information \"? [$script:BusBuddyTestWatchCorrelation] Retry succeeded on attempt $attempt\" -InformationAction Continue\r\n                        break\r\n                    } catch {\r\n                        Write-Warning (\"[$script:BusBuddyTestWatchCorrelation] Retry attempt {0} failed: {1}\" -f $attempt, $_.Exception.Message)\r\n                        $delay = [math]::Min($delay * 2, 30)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $handler = Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action\r\n    $script:BusBuddyTestWatchHandle = @{ Watcher = $watcher; Handler = $handler }\r\n    Write-Information \"Press Ctrl+C or run Stop-BusBuddyTestWatchAdvanced to stop. CorrelationId=$script:BusBuddyTestWatchCorrelation\" -InformationAction Continue\r\n}\r\n\r\nfunction Stop-BusBuddyTestWatchAdvanced {\r\n    [CmdletBinding()] param()\r\n    if (-not $script:BusBuddyTestWatchHandle) { Write-Warning 'No active test watch.'; return }\r\n    try {\r\n        $script:BusBuddyTestWatchHandle.Handler | Unregister-Event -ErrorAction SilentlyContinue\r\n        $script:BusBuddyTestWatchHandle.Watcher.EnableRaisingEvents = $false\r\n        $script:BusBuddyTestWatchHandle.Watcher.Dispose()\r\n        Write-Information '?? Test watch stopped.' -InformationAction Continue\r\n    } finally { Remove-Variable BusBuddyTestWatchHandle -Scope Script -ErrorAction SilentlyContinue }\r\n}\r\n\r\nExport-ModuleMember -Function Start-BusBuddyTestWatchAdvanced,Stop-BusBuddyTestWatchAdvanced\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.Cleanup",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup\\BusBuddy.Cleanup.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.Cleanup Module\r\n# Implements repository hygiene and artifact cleanup per project guidelines.\r\n\r\nfunction Invoke-BusBuddyCleanup {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove build artifacts and old log files.\r\n    .DESCRIPTION\r\n        Deletes bin/, obj/, TestResults/, and logs older than a retention window (default 7 days).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$LogRetentionDays = 7,\r\n        [switch]$IncludeNodeModules\r\n    )\r\n    $paths = @('bin','obj','TestResults')\r\n    if ($IncludeNodeModules) { $paths += 'node_modules' }\r\n    foreach ($p in $paths) {\r\n        Get-ChildItem -Recurse -Directory -Filter $p -ErrorAction SilentlyContinue | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove directory')) {\r\n                try { Remove-Item $_.FullName -Recurse -Force -ErrorAction Stop; Write-Information \"??? Removed $($_.FullName)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove $($_.FullName): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    if (Test-Path logs) {\r\n        $threshold = (Get-Date).AddDays(-$LogRetentionDays)\r\n        Get-ChildItem logs -File -Include *.log -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold } | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove old log')) {\r\n                try { Remove-Item $_.FullName -Force; Write-Information \"?? Removed old log $($_.Name)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove log $($_.Name): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Identify candidate unused .cs/.xaml files not referenced in solution or project includes.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([string[]])]\r\n    param(\r\n        [string]$Root = '.'\r\n    )\r\n    $solution = Get-ChildItem -Path $Root -Filter *.sln -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1\r\n    if (-not $solution) { Write-Warning 'Solution file not found.'; return @() }\r\n    $solutionText = Get-Content $solution.FullName -Raw\r\n    $candidates = Get-ChildItem $Root -Recurse -Include *.cs,*.xaml -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'bin\\\\|obj\\\\|TestResults\\\\|\\.git' }\r\n    $unused = @()\r\n    foreach ($f in $candidates) {\r\n        if ($solutionText -notmatch [regex]::Escape($f.Name)) { $unused += $f.FullName }\r\n    }\r\n    return $unused\r\n}\r\n\r\nfunction Remove-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove unused files interactively (WhatIf supported).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Medium')]\r\n    param(\r\n        [string]$Root='.'\r\n    )\r\n    $unused = Get-BusBuddyUnusedFiles -Root $Root\r\n    if (-not $unused -or $unused.Count -eq 0) { Write-Information 'No unused files detected.' -InformationAction Continue; return }\r\n    foreach ($file in $unused) {\r\n        if ($PSCmdlet.ShouldProcess($file,'Remove unused file')) {\r\n            try { Remove-Item $file -Force; Write-Information \"Removed unused file $file\" -InformationAction Continue } catch { $warn = 'Failed to remove ' + $file + ' -> ' + $_.Exception.Message; Write-Warning $warn }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyCleanup,Get-BusBuddyUnusedFiles,Remove-BusBuddyUnusedFiles\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          }
        ],
        "PowerShellHostName": null,
        "PowerShellHostVersion": null,
        "PowerShellVersion": {
          "Major": 7,
          "Minor": 5,
          "Build": -1,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ProcessorArchitecture": 0,
        "Scripts": [],
        "RequiredAssemblies": [],
        "RequiredModules": [],
        "RootModule": "BusBuddy.psm1",
        "ExportedVariables": {},
        "ExportedAliases": {
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "ExportedDscResources": [],
        "SessionState": {
          "Drive": {
            "Current": "C"
          },
          "Provider": {},
          "Path": {
            "CurrentLocation": "C:\\Users\\biges\\Desktop\\BusBuddy",
            "CurrentFileSystemLocation": "C:\\Users\\biges\\Desktop\\BusBuddy"
          },
          "PSVariable": {},
          "LanguageMode": 0,
          "UseFullLanguageModeInDebugger": false,
          "Scripts": [
            "*"
          ],
          "Applications": [
            "*"
          ],
          "Module": {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
            "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
            "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Development WPF DotNet BusBuddy Development WPF DotNet",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "RepositorySourceLocation": null,
            "Version": "2.0.0",
            "ModuleType": 0,
            "Author": "Bus Buddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Team",
            "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1",
            "CompatiblePSEditions": "Core",
            "ModuleList": "",
            "NestedModules": "BusBuddy.BuildOutput BusBuddy.TestOutput BusBuddy.ThemeValidation BusBuddy.AzureSqlHealth BusBuddy.TestWatcher BusBuddy.Cleanup",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          "InvokeProvider": {
            "Item": "System.Management.Automation.ItemCmdletProviderIntrinsics",
            "ChildItem": "System.Management.Automation.ChildItemCmdletProviderIntrinsics",
            "Content": "System.Management.Automation.ContentCmdletProviderIntrinsics",
            "Property": "System.Management.Automation.PropertyCmdletProviderIntrinsics",
            "SecurityDescriptor": "System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics"
          },
          "InvokeCommand": {
            "HasErrors": null,
            "CommandNotFoundAction": null,
            "PreCommandLookupAction": null,
            "PostCommandLookupAction": null,
            "LocationChangedAction": null
          }
        },
        "OnRemove": null,
        "ExportedFormatFiles": [],
        "ExportedTypeFiles": []
      }
    },
    {
      "Definition": "Invoke-BusBuddyTest",
      "Name": "bbTest",
      "Options": "None",
      "Module": {
        "LogPipelineExecutionDetails": false,
        "Name": "BusBuddy",
        "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
        "ImplementingAssembly": null,
        "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
        "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
        "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
        "HelpInfoUri": null,
        "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
        "PrivateData": {
          "PSData": {
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "Tags": "BusBuddy Development WPF DotNet"
          }
        },
        "ExperimentalFeatures": [],
        "Tags": [
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet",
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet"
        ],
        "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
        "IconUri": null,
        "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
        "ReleaseNotes": "Streamlined core module for reliable development workflow",
        "RepositorySourceLocation": null,
        "Version": {
          "Major": 2,
          "Minor": 0,
          "Build": 0,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ModuleType": 0,
        "Author": "Bus Buddy Development Team",
        "AccessMode": 0,
        "ClrVersion": null,
        "CompanyName": "BusBuddy Team",
        "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
        "DotNetFrameworkVersion": null,
        "ExportedFunctions": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          }
        },
        "Prefix": "",
        "ExportedCmdlets": {},
        "ExportedCommands": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "FileList": [
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1"
        ],
        "CompatiblePSEditions": [
          "Core"
        ],
        "ModuleList": [],
        "NestedModules": [
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.BuildOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "# Enhanced Build Commands with No Truncation\n# Part of BusBuddy PowerShell Module\n\n#region Enhanced Build Functions\n\nfunction Get-BusBuddyBuildOutput {\n    <#\n    .SYNOPSIS\n        Get complete build output without truncation\n\n    .DESCRIPTION\n        Captures full dotnet build output to both console and file, preventing truncation issues\n\n    .PARAMETER ProjectPath\n        Path to solution or project file\n\n    .PARAMETER Configuration\n        Build configuration (Debug/Release)\n\n    .PARAMETER SaveToFile\n        Save complete output to timestamped file\n\n    .EXAMPLE\n        Get-BusBuddyBuildOutput -SaveToFile\n    #>\n    [CmdletBinding()]\n    param(\n        [string]$ProjectPath = \"BusBuddy.sln\",\n        [string]$Configuration = \"Debug\",\n        [switch]$SaveToFile,\n        [switch]$ErrorsOnly\n    )\n\n    $timestamp = Get-Date -Format \"yyyyMMdd-HHmmss\"\n    $outputFile = \"logs\\build-output-$timestamp.log\"\n\n    # Ensure logs directory exists\n    if (-not (Test-Path \"logs\")) {\n        New-Item -ItemType Directory -Path \"logs\" -Force | Out-Null\n    }\n\n    Write-Host \"??? Building $ProjectPath...\" -ForegroundColor Cyan\n    Write-Host \"?? Configuration: $Configuration\" -ForegroundColor Gray\n\n    if ($SaveToFile) {\n        Write-Host \"?? Full output will be saved to: $outputFile\" -ForegroundColor Yellow\n    }\n\n    # Configure environment for maximum output\n    $env:DOTNET_CLI_UI_LANGUAGE = \"en-US\"\n    $env:DOTNET_NOLOGO = \"false\"  # We want full output\n\n    try {\n        # Capture all output streams with detailed verbosity\n        $verbosity = if ($ErrorsOnly) { \"quiet\" } else { \"detailed\" }\n\n        $startTime = Get-Date\n\n        # Use Start-Process for complete output capture\n        $processInfo = @{\n            FilePath = \"dotnet\"\n            ArgumentList = @(\"build\", $ProjectPath, \"--configuration\", $Configuration, \"--verbosity\", $verbosity, \"--no-restore\")\n            RedirectStandardOutput = $true\n            RedirectStandardError = $true\n            UseShellExecute = $false\n            CreateNoWindow = $true\n        }\n\n        $process = Start-Process @processInfo -PassThru\n\n        # Read output in real-time\n        $stdout = $process.StandardOutput.ReadToEnd()\n        $stderr = $process.StandardError.ReadToEnd()\n\n        $process.WaitForExit()\n        $exitCode = $process.ExitCode\n\n        $endTime = Get-Date\n        $duration = $endTime - $startTime\n\n        # Combine all output\n        $fullOutput = @\"\n=== BUSBUDDY BUILD LOG ===\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\nProject: $ProjectPath\nConfiguration: $Configuration\nDuration: $($duration.TotalSeconds) seconds\nExit Code: $exitCode\n\n=== STANDARD OUTPUT ===\n$stdout\n\n=== STANDARD ERROR ===\n$stderr\n\n=== BUILD SUMMARY ===\n\"@\n\n        # Save to file if requested\n        if ($SaveToFile) {\n            $fullOutput | Out-File -FilePath $outputFile -Encoding UTF8 -Width 500\n            Write-Host \"? Complete build log saved to: $outputFile\" -ForegroundColor Green\n        }\n\n        # Parse and display errors prominently\n        $errorLines = ($stdout + $stderr) -split \"`n\" | Where-Object { $_ -match \"error|Error|ERROR|\\s+CS\\d+|\\s+MSB\\d+\" }\n\n        if ($errorLines) {\n            Write-Host \"`n? BUILD ERRORS FOUND:\" -ForegroundColor Red\n            Write-Host \"=\" * 50 -ForegroundColor Red\n            $errorLines | ForEach-Object {\n                Write-Host $_ -ForegroundColor Red\n            }\n            Write-Host \"=\" * 50 -ForegroundColor Red\n\n            if ($SaveToFile) {\n                Write-Host \"?? Full details in: $outputFile\" -ForegroundColor Yellow\n            }\n        } else {\n            Write-Host \"? No errors found!\" -ForegroundColor Green\n        }\n\n        # Display summary\n        Write-Host \"`n?? BUILD SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"   Duration: $($duration.TotalSeconds) seconds\" -ForegroundColor Gray\n        Write-Host \"   Exit Code: $exitCode\" -ForegroundColor $(if ($exitCode -eq 0) { \"Green\" } else { \"Red\" })\n\n        if ($exitCode -eq 0) {\n            Write-Host \"   Status: SUCCESS ?\" -ForegroundColor Green\n        } else {\n            Write-Host \"   Status: FAILED ?\" -ForegroundColor Red\n        }\n\n        return @{\n            ExitCode = $exitCode\n            Duration = $duration\n            ErrorLines = $errorLines\n            OutputFile = if ($SaveToFile) { $outputFile } else { $null }\n            FullOutput = $fullOutput\n        }\n\n    } catch {\n        Write-Error \"Failed to execute build: $($_.Exception.Message)\"\n        return $null\n    }\n}\n\nfunction Start-BusBuddyBuildFull {\n    <#\n    .SYNOPSIS\n        Enhanced bb-build with complete output capture\n    #>\n    Get-BusBuddyBuildOutput -SaveToFile\n}\n\nfunction Get-BusBuddyBuildErrors {\n    <#\n    .SYNOPSIS\n        Get only build errors without full output\n    #>\n    Get-BusBuddyBuildOutput -ErrorsOnly\n}\n\nfunction Show-BusBuddyBuildLog {\n    <#\n    .SYNOPSIS\n        Show the most recent build log\n    #>\n    $latestLog = Get-ChildItem \"logs\\build-output-*.log\" | Sort-Object LastWriteTime -Descending | Select-Object -First 1\n\n    if ($latestLog) {\n        Write-Host \"?? Most recent build log: $($latestLog.Name)\" -ForegroundColor Cyan\n        Write-Host \"?? Created: $($latestLog.LastWriteTime)\" -ForegroundColor Gray\n        Write-Host \"\"\n        Get-Content $latestLog.FullName\n    } else {\n        Write-Host \"No build logs found. Run Start-BusBuddyBuildFull first.\" -ForegroundColor Yellow\n    }\n}\n\n#endregion\n\n# Export functions\nExport-ModuleMember -Function Get-BusBuddyBuildOutput, Start-BusBuddyBuildFull, Get-BusBuddyBuildErrors, Show-BusBuddyBuildLog\n",
            "Description": "Enhanced build output capture for BusBuddy - eliminates truncated terminal output",
            "Guid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Build Output Capture NoTruncation BusBuddy Build Output Capture NoTruncation",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": "v1.0.0 - Initial release\n- Complete build output capture without truncation\n- Automatic error parsing and highlighting\n- Timestamped log file generation\n- Enhanced terminal buffer configuration",
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Project",
            "Copyright": "(c) 2025 BusBuddy Project. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.BuildOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\nSet-StrictMode -Version 3.0\r\n\r\n# Avoid auto-executing on import - provide wrapper to run the script when requested\r\n$moduleRoot = Split-Path -Parent $PSScriptRoot\r\n$workspaceRoot = Split-Path -Parent (Split-Path -Parent $moduleRoot)\r\n$enhancedTestPath = Join-Path $workspaceRoot 'PowerShell\\Scripts\\Enhanced-Test-Output.ps1'\r\n\r\nfunction Invoke-BusBuddyEnhancedTestOutput {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromRemainingArguments = $true)]\r\n        [object[]] $Args\r\n    )\r\n    if (-not (Test-Path -LiteralPath $enhancedTestPath)) {\r\n        Write-Error \"Enhanced-Test-Output.ps1 not found at: $enhancedTestPath\"\r\n        return\r\n    }\r\n    & $enhancedTestPath @Args\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyEnhancedTestOutput\r\n",
            "Description": "",
            "Guid": "7c6a0d9e-1f2a-4b9e-b5a2-1c5f5d5b8a1c",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy",
            "Copyright": "(c) BusBuddy",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.TestOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.ThemeValidation",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation\\BusBuddy.ThemeValidation.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.ThemeValidation Module\r\n# Validates Syncfusion theme/style consistency across WPF XAML files.\r\n# Docs reference: https://help.syncfusion.com/wpf/themes/overview\r\n\r\nfunction Test-BusBuddyThemeConsistency {\r\n    <#\r\n    .SYNOPSIS\r\n        Scan XAML views for inline Syncfusion control styling violations.\r\n    .DESCRIPTION\r\n        Looks for Syncfusion controls (SfDataGrid, ButtonAdv, DockingManager etc.)\r\n        with inline size/margin/brush properties that should be centralized in resource dictionaries.\r\n    .OUTPUTS\r\n        Hashtable with Issues (string[]) and Status (Success|Failed)\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views'\r\n    )\r\n    $issues = New-Object System.Collections.Generic.List[string]\r\n    if (-not (Test-Path $ViewsPath)) {\r\n        Write-Warning \"Views path not found: $ViewsPath\"\r\n        return @{ Issues = @('Views path missing'); Status = 'Failed' }\r\n    }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    $mergedDictionaries = @{}\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $mergeMatches = [regex]::Matches($content,'<ResourceDictionary\\s+Source=\"([^\"]+)\"')\r\n        foreach ($m in $mergeMatches) { $mergedDictionaries[$m.Groups[1].Value] = $true }\r\n        # Detect inline width/height/margin on Syncfusion ButtonAdv or SfButton / SfDataGrid\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)[^>]*(Width|Height|Margin)=') {\r\n            $issues.Add(\"Inline layout property on Syncfusion button in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:SfDataGrid[^>]*(RowHeight|HeaderRowHeight|Background|BorderBrush)=') {\r\n            $issues.Add(\"Inline SfDataGrid visual property in $($file.Name)\")\r\n        }\r\n        # Missing namespace check (should declare syncfusion namespace where controls appear)\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'xmlns:syncfusion=') {\r\n            $issues.Add(\"Missing syncfusion xmlns in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'FluentDark' -and $content -notmatch 'FluentLight') {\r\n            $issues.Add(\"Potential missing theme reference (FluentDark/FluentLight) in $($file.Name)\")\r\n        }\r\n    }\r\n    if (-not ($mergedDictionaries.Keys | Where-Object { $_ -match 'Themes' })) {\r\n        $issues.Add('No merged resource dictionaries referencing Themes folder detected')\r\n    }\r\n    $status = if ($issues.Count -gt 0) { 'Failed' } else { 'Success' }\r\n    return @{ Issues = $issues.ToArray(); Status = $status; FileCount = $xamlFiles.Count; MergedDictionaries = $mergedDictionaries.Keys }\r\n}\r\n\r\nfunction Invoke-BusBuddyThemeRemediation {\r\n    <#\r\n    .SYNOPSIS\r\n        Attempt automatic remediation of common inline styling issues.\r\n    .DESCRIPTION\r\n        Replaces common inline size/margin attributes on Syncfusion buttons with Style reference.\r\n        Only performs safe textual substitutions; more advanced refactoring deferred post-MVP.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views',\r\n        [string]$ButtonStyleKey = 'SyncfusionPrimaryButtonStyle'\r\n    )\r\n    if (-not (Test-Path $ViewsPath)) { Write-Warning \"Views path not found: $ViewsPath\"; return }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $original = $content\r\n        $modified = $false\r\n        # Replace inline width/height/margin on buttons with style if not already styled\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)' -and $content -notmatch 'Style=\"{StaticResource') {\r\n            $content = [regex]::Replace($content,'(<syncfusion:(?:ButtonAdv|SfButton)[^>]*)(Width|Height|Margin)=\"[^\"]+\"','${1}')\r\n            if ($content -ne $original) { $modified = $true }\r\n            if ($modified) {\r\n                $content = [regex]::Replace($content,'<syncfusion:(ButtonAdv|SfButton)([^>]*)>','<syncfusion:$1$2 Style=\"{StaticResource ' + $ButtonStyleKey + '}\">')\r\n            }\r\n        }\r\n        if ($modified -and $PSCmdlet.ShouldProcess($file.FullName,'Apply style remediation')) {\r\n            $content | Set-Content $file.FullName -Encoding UTF8\r\n            Write-Information \"Remediated: $($file.Name)\" -InformationAction Continue\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyThemeConsistency,Invoke-BusBuddyThemeRemediation\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.AzureSqlHealth",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth\\BusBuddy.AzureSqlHealth.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.AzureSqlHealth Module\r\n# References: https://learn.microsoft.com/azure/azure-sql/database/connectivity-architecture\r\n\r\nfunction Test-BusBuddyAzureSql {\r\n    <#\r\n    .SYNOPSIS\r\n        Test connectivity to Azure SQL (fallback to LocalDB on failure).\r\n    .OUTPUTS\r\n        Bool indicating Azure SQL connectivity success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) {\r\n        Write-Warning \"Azure settings file not found: $SettingsPath\"\r\n        return $false\r\n    }\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 2\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n    $lastError = $null\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n            $connString = $json.ConnectionStrings.DefaultConnection\r\n            if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n            $query = 'SELECT TOP 1 name FROM sys.databases'\r\n            $result = Invoke-Sqlcmd -ConnectionString $connString -Query $query -ErrorAction Stop\r\n            $stopwatch.Stop()\r\n            Write-Information \"? Azure SQL reachable (attempt $attempts) latency=$([math]::Round($stopwatch.Elapsed.TotalMilliseconds,0))ms Databases: $($result.name -join ',')\" -InformationAction Continue\r\n            return $true\r\n        } catch {\r\n            $lastError = $_.Exception.Message\r\n            Write-Warning \"Attempt $attempts failed: $lastError\"\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds *= 2 }\r\n        }\r\n    }\r\n    $stopwatch.Stop()\r\n    Write-Warning \"?? Azure SQL test failed after $attempts attempts: $lastError\"\r\n    return $false\r\n}\r\n\r\nfunction Test-BusBuddyAzureSqlNative {\r\n    <#\r\n    .SYNOPSIS\r\n        Test Azure SQL connectivity using System.Data.SqlClient directly (no sqlcmd dependency).\r\n    .DESCRIPTION\r\n        Reads connection string from appsettings.azure.json (ConnectionStrings.DefaultConnection) and attempts to open a connection\r\n        and run a lightweight query. Implements simple retry with exponential backoff.\r\n        Docs: https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.open\r\n    .OUTPUTS\r\n        Bool indicating success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) { Write-Warning \"Azure settings file not found: $SettingsPath\"; return $false }\r\n    try {\r\n        $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n        $connString = $json.ConnectionStrings.DefaultConnection\r\n        if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n    } catch {\r\n        Write-Warning \"Failed to parse ${SettingsPath}: $($_.Exception.Message)\"; return $false\r\n    }\r\n\r\n    # Expand ${ENV_VAR} placeholders if present in connection string\r\n    # Pattern sourced from standard PowerShell regex usage - see Microsoft Docs: about_Regular_Expressions\r\n    $expandEnv = {\r\n        param([string]$s)\r\n        if ([string]::IsNullOrWhiteSpace($s)) { return $s }\r\n        return [regex]::Replace($s, '\\$\\{([A-Za-z0-9_]+)\\}', {\r\n            param($m)\r\n            $name = $m.Groups[1].Value\r\n            $val  = [Environment]::GetEnvironmentVariable($name)\r\n            if (-not $val) { $m.Value } else { $val }\r\n        })\r\n    }\r\n    $original = $connString\r\n    $connString = & $expandEnv $connString\r\n    if ($connString -match '\\$\\{') {\r\n        Write-Information \"?? One or more environment placeholders are unresolved in connection string (file=${SettingsPath}). Set required variables in the environment before running tests.\" -InformationAction Continue\r\n    }\r\n\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 1\r\n    $sw = [System.Diagnostics.Stopwatch]::StartNew()\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $conn = [System.Data.SqlClient.SqlConnection]::new($connString)\r\n            $conn.Open()\r\n            try {\r\n                $cmd = $conn.CreateCommand()\r\n                $cmd.CommandText = 'SELECT DB_NAME()'\r\n                $db = $cmd.ExecuteScalar()\r\n                $sw.Stop()\r\n                Write-Information (\"? Azure SQL (native) reachable on attempt {0} - DB: {1}, latency={2}ms\" -f $attempts, $db, [math]::Round($sw.Elapsed.TotalMilliseconds,0)) -InformationAction Continue\r\n                return $true\r\n            } finally {\r\n                $conn.Dispose()\r\n            }\r\n        } catch {\r\n            Write-Warning (\"Native attempt {0} failed: {1}\" -f $attempts, $_.Exception.Message)\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds = [Math]::Min($delaySeconds * 2, 8) }\r\n        }\r\n    }\r\n    $sw.Stop()\r\n    Write-Warning \"?? Azure SQL (native) test failed after $attempts attempts.\"\r\n    return $false\r\n}\r\n\r\nfunction Get-BusBuddySqlStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Provide detailed Azure SQL / LocalDB status summary.\r\n    .OUTPUTS\r\n        Hashtable with status fields.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$AzureSettingsPath = 'appsettings.azure.json',\r\n        [string]$LocalSettingsPath = 'appsettings.json'\r\n    )\r\n    $status = [ordered]@{}\r\n    $status.Timestamp = Get-Date\r\n    $status.AzureSettingsPresent = Test-Path $AzureSettingsPath\r\n    $status.LocalSettingsPresent = Test-Path $LocalSettingsPath\r\n    $status.AzureReachable = $false\r\n    $status.LocalDbReachable = $false\r\n\r\n    if ($status.AzureSettingsPresent) {\r\n        $status.AzureReachable = Test-BusBuddyAzureSql -SettingsPath $AzureSettingsPath\r\n    }\r\n    # LocalDB quick probe via sqlcmd if installed\r\n    try {\r\n        $localJson = if (Test-Path $LocalSettingsPath) { Get-Content $LocalSettingsPath -Raw | ConvertFrom-Json } else { $null }\r\n        $localConn = $localJson.ConnectionStrings.DefaultConnection\r\n        if ($localConn -and $localConn -match 'localdb') {\r\n            try {\r\n                Invoke-Sqlcmd -ConnectionString $localConn -Query 'SELECT 1' -ErrorAction Stop | Out-Null\r\n                $status.LocalDbReachable = $true\r\n            } catch {\r\n                $status.LocalDbReachable = $false\r\n            }\r\n        }\r\n    } catch {\r\n        $status.LocalDbReachable = $false\r\n    }\r\n\r\n    $status.PrimaryDataSource = if ($status.AzureReachable) { 'Azure' } elseif ($status.LocalDbReachable) { 'LocalDB' } else { 'Unknown' }\r\n    return $status\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyAzureSql,Test-BusBuddyAzureSqlNative,Get-BusBuddySqlStatus\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestWatcher",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher\\BusBuddy.TestWatcher.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.TestWatcher Module\r\n# Provides debounced file change watching to trigger targeted test runs.\r\n\r\nfunction Start-BusBuddyTestWatchAdvanced {\r\n    <#\r\n    .SYNOPSIS\r\n        Start debounced test watch loop for a specific test suite.\r\n    .DESCRIPTION\r\n        Watches for changes to .cs and .xaml files under repo root and re-runs Get-BusBuddyTestOutput.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite = 'Unit',\r\n        [int]$DebounceSeconds = 2,\r\n        [switch]$RetryOnFailure,\r\n        [int]$MaxRetries = 2,\r\n        [int]$RetryDelaySeconds = 2\r\n    )\r\n    if ($script:BusBuddyTestWatchHandle) { Write-Warning 'Test watch already running.'; return }\r\n    $root = Get-Location\r\n    Write-Information \"?? Watching $root for changes (suite=$TestSuite, debounce=${DebounceSeconds}s)\" -InformationAction Continue\r\n    $watcher = New-Object System.IO.FileSystemWatcher -Property @{ Path = $root; Filter = '*.*'; IncludeSubdirectories = $true; EnableRaisingEvents = $true }\r\n    $script:BusBuddyTestWatchLastRun = Get-Date 0\r\n    $script:BusBuddyTestWatchIgnored = 0\r\n    $script:BusBuddyTestWatchTriggered = 0\r\n    $script:BusBuddyTestWatchFailures = 0\r\n    $script:BusBuddyTestWatchRetries = 0\r\n    # Correlation ID for this watcher session\r\n    $script:BusBuddyTestWatchCorrelation = [guid]::NewGuid().ToString()\r\n    $action = {\r\n        $full = $Event.SourceEventArgs.FullPath\r\n        $ext = [IO.Path]::GetExtension($full)\r\n        if ($ext -notin '.cs','.xaml') {\r\n            Write-Verbose (\"Ignoring change due to unsupported extension: {0}\" -f $ext)\r\n            return\r\n        }\r\n        # Ignore build/test artifacts to avoid infinite loops (bin/obj/TestResults/.git/.vs)\r\n        if ($full -match \"(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\\") {\r\n            $script:BusBuddyTestWatchIgnored++\r\n            Write-Verbose (\"Ignoring change in excluded path: {0}\" -f $full)\r\n            return\r\n        }\r\n        $now = Get-Date\r\n        $elapsed = ($now - $script:BusBuddyTestWatchLastRun).TotalSeconds\r\n        if ($elapsed -lt $using:DebounceSeconds) {\r\n            $remaining = [math]::Max([int]([math]::Ceiling($using:DebounceSeconds - $elapsed)), 0)\r\n            Write-Verbose (\"Debounce active - event suppressed. Time remaining: {0}s\" -f $remaining)\r\n            return\r\n        }\r\n        $script:BusBuddyTestWatchLastRun = $now\r\n        $script:BusBuddyTestWatchTriggered++\r\n        Write-Information \"?? [$script:BusBuddyTestWatchCorrelation] Change detected: $($Event.SourceEventArgs.Name) -> running $using:TestSuite tests (trigger #$script:BusBuddyTestWatchTriggered, ignored so far=$script:BusBuddyTestWatchIgnored)\" -InformationAction Continue\r\n        try {\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n        } catch {\r\n            $script:BusBuddyTestWatchFailures++\r\n            Write-Warning \"[$script:BusBuddyTestWatchCorrelation] Test watch run failed (#$script:BusBuddyTestWatchFailures): $($_.Exception.Message)\"\r\n            if ($using:RetryOnFailure) {\r\n                $attempt = 0\r\n                $delay = [int]$using:RetryDelaySeconds\r\n                while ($attempt -lt [int]$using:MaxRetries) {\r\n                    $attempt++\r\n                    $script:BusBuddyTestWatchRetries++\r\n                    Write-Information (\"?? [$script:BusBuddyTestWatchCorrelation] Retry trigger #{0} (attempt {1}/{2}) after failure - waiting {3}s...\" -f $script:BusBuddyTestWatchRetries, $attempt, [int]$using:MaxRetries, $delay) -InformationAction Continue\r\n                    Start-Sleep -Seconds $delay\r\n                    try {\r\n                        Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n                        Write-Information \"? [$script:BusBuddyTestWatchCorrelation] Retry succeeded on attempt $attempt\" -InformationAction Continue\r\n                        break\r\n                    } catch {\r\n                        Write-Warning (\"[$script:BusBuddyTestWatchCorrelation] Retry attempt {0} failed: {1}\" -f $attempt, $_.Exception.Message)\r\n                        $delay = [math]::Min($delay * 2, 30)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $handler = Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action\r\n    $script:BusBuddyTestWatchHandle = @{ Watcher = $watcher; Handler = $handler }\r\n    Write-Information \"Press Ctrl+C or run Stop-BusBuddyTestWatchAdvanced to stop. CorrelationId=$script:BusBuddyTestWatchCorrelation\" -InformationAction Continue\r\n}\r\n\r\nfunction Stop-BusBuddyTestWatchAdvanced {\r\n    [CmdletBinding()] param()\r\n    if (-not $script:BusBuddyTestWatchHandle) { Write-Warning 'No active test watch.'; return }\r\n    try {\r\n        $script:BusBuddyTestWatchHandle.Handler | Unregister-Event -ErrorAction SilentlyContinue\r\n        $script:BusBuddyTestWatchHandle.Watcher.EnableRaisingEvents = $false\r\n        $script:BusBuddyTestWatchHandle.Watcher.Dispose()\r\n        Write-Information '?? Test watch stopped.' -InformationAction Continue\r\n    } finally { Remove-Variable BusBuddyTestWatchHandle -Scope Script -ErrorAction SilentlyContinue }\r\n}\r\n\r\nExport-ModuleMember -Function Start-BusBuddyTestWatchAdvanced,Stop-BusBuddyTestWatchAdvanced\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.Cleanup",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup\\BusBuddy.Cleanup.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.Cleanup Module\r\n# Implements repository hygiene and artifact cleanup per project guidelines.\r\n\r\nfunction Invoke-BusBuddyCleanup {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove build artifacts and old log files.\r\n    .DESCRIPTION\r\n        Deletes bin/, obj/, TestResults/, and logs older than a retention window (default 7 days).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$LogRetentionDays = 7,\r\n        [switch]$IncludeNodeModules\r\n    )\r\n    $paths = @('bin','obj','TestResults')\r\n    if ($IncludeNodeModules) { $paths += 'node_modules' }\r\n    foreach ($p in $paths) {\r\n        Get-ChildItem -Recurse -Directory -Filter $p -ErrorAction SilentlyContinue | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove directory')) {\r\n                try { Remove-Item $_.FullName -Recurse -Force -ErrorAction Stop; Write-Information \"??? Removed $($_.FullName)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove $($_.FullName): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    if (Test-Path logs) {\r\n        $threshold = (Get-Date).AddDays(-$LogRetentionDays)\r\n        Get-ChildItem logs -File -Include *.log -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold } | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove old log')) {\r\n                try { Remove-Item $_.FullName -Force; Write-Information \"?? Removed old log $($_.Name)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove log $($_.Name): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Identify candidate unused .cs/.xaml files not referenced in solution or project includes.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([string[]])]\r\n    param(\r\n        [string]$Root = '.'\r\n    )\r\n    $solution = Get-ChildItem -Path $Root -Filter *.sln -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1\r\n    if (-not $solution) { Write-Warning 'Solution file not found.'; return @() }\r\n    $solutionText = Get-Content $solution.FullName -Raw\r\n    $candidates = Get-ChildItem $Root -Recurse -Include *.cs,*.xaml -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'bin\\\\|obj\\\\|TestResults\\\\|\\.git' }\r\n    $unused = @()\r\n    foreach ($f in $candidates) {\r\n        if ($solutionText -notmatch [regex]::Escape($f.Name)) { $unused += $f.FullName }\r\n    }\r\n    return $unused\r\n}\r\n\r\nfunction Remove-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove unused files interactively (WhatIf supported).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Medium')]\r\n    param(\r\n        [string]$Root='.'\r\n    )\r\n    $unused = Get-BusBuddyUnusedFiles -Root $Root\r\n    if (-not $unused -or $unused.Count -eq 0) { Write-Information 'No unused files detected.' -InformationAction Continue; return }\r\n    foreach ($file in $unused) {\r\n        if ($PSCmdlet.ShouldProcess($file,'Remove unused file')) {\r\n            try { Remove-Item $file -Force; Write-Information \"Removed unused file $file\" -InformationAction Continue } catch { $warn = 'Failed to remove ' + $file + ' -> ' + $_.Exception.Message; Write-Warning $warn }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyCleanup,Get-BusBuddyUnusedFiles,Remove-BusBuddyUnusedFiles\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          }
        ],
        "PowerShellHostName": null,
        "PowerShellHostVersion": null,
        "PowerShellVersion": {
          "Major": 7,
          "Minor": 5,
          "Build": -1,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ProcessorArchitecture": 0,
        "Scripts": [],
        "RequiredAssemblies": [],
        "RequiredModules": [],
        "RootModule": "BusBuddy.psm1",
        "ExportedVariables": {},
        "ExportedAliases": {
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "ExportedDscResources": [],
        "SessionState": {
          "Drive": {
            "Current": "C"
          },
          "Provider": {},
          "Path": {
            "CurrentLocation": "C:\\Users\\biges\\Desktop\\BusBuddy",
            "CurrentFileSystemLocation": "C:\\Users\\biges\\Desktop\\BusBuddy"
          },
          "PSVariable": {},
          "LanguageMode": 0,
          "UseFullLanguageModeInDebugger": false,
          "Scripts": [
            "*"
          ],
          "Applications": [
            "*"
          ],
          "Module": {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
            "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
            "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Development WPF DotNet BusBuddy Development WPF DotNet",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "RepositorySourceLocation": null,
            "Version": "2.0.0",
            "ModuleType": 0,
            "Author": "Bus Buddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Team",
            "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1",
            "CompatiblePSEditions": "Core",
            "ModuleList": "",
            "NestedModules": "BusBuddy.BuildOutput BusBuddy.TestOutput BusBuddy.ThemeValidation BusBuddy.AzureSqlHealth BusBuddy.TestWatcher BusBuddy.Cleanup",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          "InvokeProvider": {
            "Item": "System.Management.Automation.ItemCmdletProviderIntrinsics",
            "ChildItem": "System.Management.Automation.ChildItemCmdletProviderIntrinsics",
            "Content": "System.Management.Automation.ContentCmdletProviderIntrinsics",
            "Property": "System.Management.Automation.PropertyCmdletProviderIntrinsics",
            "SecurityDescriptor": "System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics"
          },
          "InvokeCommand": {
            "HasErrors": null,
            "CommandNotFoundAction": null,
            "PreCommandLookupAction": null,
            "PostCommandLookupAction": null,
            "LocationChangedAction": null
          }
        },
        "OnRemove": null,
        "ExportedFormatFiles": [],
        "ExportedTypeFiles": []
      }
    },
    {
      "Definition": "Invoke-BusBuddyHealthCheck",
      "Name": "bbHealth",
      "Options": "None",
      "Module": {
        "LogPipelineExecutionDetails": false,
        "Name": "BusBuddy",
        "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
        "ImplementingAssembly": null,
        "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
        "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
        "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
        "HelpInfoUri": null,
        "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
        "PrivateData": {
          "PSData": {
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "Tags": "BusBuddy Development WPF DotNet"
          }
        },
        "ExperimentalFeatures": [],
        "Tags": [
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet",
          "BusBuddy",
          "Development",
          "WPF",
          "DotNet"
        ],
        "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
        "IconUri": null,
        "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
        "ReleaseNotes": "Streamlined core module for reliable development workflow",
        "RepositorySourceLocation": null,
        "Version": {
          "Major": 2,
          "Minor": 0,
          "Build": 0,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ModuleType": 0,
        "Author": "Bus Buddy Development Team",
        "AccessMode": 0,
        "ClrVersion": null,
        "CompanyName": "BusBuddy Team",
        "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
        "DotNetFrameworkVersion": null,
        "ExportedFunctions": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          }
        },
        "Prefix": "",
        "ExportedCmdlets": {},
        "ExportedCommands": {
          "Get-BusBuddyCommand": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyCommand",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyCommand",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Get-BusBuddyInfo": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Get",
            "Noun": "BusBuddyInfo",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Get-BusBuddyInfo",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyAntiRegression": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyAntiRegression",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Invoke-BusBuddyAntiRegression",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Detailed] [<CommonParameters>]"
          },
          "Invoke-BusBuddyBuild": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyBuild",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyBuild",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Clean] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyClean": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyClean",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyClean",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyHealthCheck": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyHealthCheck",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyHealthCheck",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "Invoke-BusBuddyRestore": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRestore",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRestore",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-Force] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyRun": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyRun",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Invoke-BusBuddyRun",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-WaitSeconds] <int>] [-WaitReady] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Invoke-BusBuddyTest": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Invoke",
            "Noun": "BusBuddyTest",
            "HelpFile": null,
            "OutputType": "System.Collections.Hashtable",
            "Name": "Invoke-BusBuddyTest",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[[-TestSuite] <string>] [-SaveToFile] [-DetailedOutput] [-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Start-BusBuddyDevSession": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Start",
            "Noun": "BusBuddyDevSession",
            "HelpFile": null,
            "OutputType": "",
            "Name": "Start-BusBuddyDevSession",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[-WhatIf] [-Confirm] [<CommonParameters>]"
          },
          "Test-BusBuddyMVPReadiness": {
            "ScriptBlock": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "CmdletBinding": true,
            "DefaultParameterSet": null,
            "Definition": "\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n",
            "Options": 0,
            "Description": null,
            "Verb": "Test",
            "Noun": "BusBuddyMVPReadiness",
            "HelpFile": null,
            "OutputType": "System.Boolean",
            "Name": "Test-BusBuddyMVPReadiness",
            "CommandType": 2,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": "[<CommonParameters>]"
          },
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "FileList": [
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1",
          "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1"
        ],
        "CompatiblePSEditions": [
          "Core"
        ],
        "ModuleList": [],
        "NestedModules": [
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.BuildOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "# Enhanced Build Commands with No Truncation\n# Part of BusBuddy PowerShell Module\n\n#region Enhanced Build Functions\n\nfunction Get-BusBuddyBuildOutput {\n    <#\n    .SYNOPSIS\n        Get complete build output without truncation\n\n    .DESCRIPTION\n        Captures full dotnet build output to both console and file, preventing truncation issues\n\n    .PARAMETER ProjectPath\n        Path to solution or project file\n\n    .PARAMETER Configuration\n        Build configuration (Debug/Release)\n\n    .PARAMETER SaveToFile\n        Save complete output to timestamped file\n\n    .EXAMPLE\n        Get-BusBuddyBuildOutput -SaveToFile\n    #>\n    [CmdletBinding()]\n    param(\n        [string]$ProjectPath = \"BusBuddy.sln\",\n        [string]$Configuration = \"Debug\",\n        [switch]$SaveToFile,\n        [switch]$ErrorsOnly\n    )\n\n    $timestamp = Get-Date -Format \"yyyyMMdd-HHmmss\"\n    $outputFile = \"logs\\build-output-$timestamp.log\"\n\n    # Ensure logs directory exists\n    if (-not (Test-Path \"logs\")) {\n        New-Item -ItemType Directory -Path \"logs\" -Force | Out-Null\n    }\n\n    Write-Host \"??? Building $ProjectPath...\" -ForegroundColor Cyan\n    Write-Host \"?? Configuration: $Configuration\" -ForegroundColor Gray\n\n    if ($SaveToFile) {\n        Write-Host \"?? Full output will be saved to: $outputFile\" -ForegroundColor Yellow\n    }\n\n    # Configure environment for maximum output\n    $env:DOTNET_CLI_UI_LANGUAGE = \"en-US\"\n    $env:DOTNET_NOLOGO = \"false\"  # We want full output\n\n    try {\n        # Capture all output streams with detailed verbosity\n        $verbosity = if ($ErrorsOnly) { \"quiet\" } else { \"detailed\" }\n\n        $startTime = Get-Date\n\n        # Use Start-Process for complete output capture\n        $processInfo = @{\n            FilePath = \"dotnet\"\n            ArgumentList = @(\"build\", $ProjectPath, \"--configuration\", $Configuration, \"--verbosity\", $verbosity, \"--no-restore\")\n            RedirectStandardOutput = $true\n            RedirectStandardError = $true\n            UseShellExecute = $false\n            CreateNoWindow = $true\n        }\n\n        $process = Start-Process @processInfo -PassThru\n\n        # Read output in real-time\n        $stdout = $process.StandardOutput.ReadToEnd()\n        $stderr = $process.StandardError.ReadToEnd()\n\n        $process.WaitForExit()\n        $exitCode = $process.ExitCode\n\n        $endTime = Get-Date\n        $duration = $endTime - $startTime\n\n        # Combine all output\n        $fullOutput = @\"\n=== BUSBUDDY BUILD LOG ===\nTimestamp: $(Get-Date -Format \"yyyy-MM-dd HH:mm:ss\")\nProject: $ProjectPath\nConfiguration: $Configuration\nDuration: $($duration.TotalSeconds) seconds\nExit Code: $exitCode\n\n=== STANDARD OUTPUT ===\n$stdout\n\n=== STANDARD ERROR ===\n$stderr\n\n=== BUILD SUMMARY ===\n\"@\n\n        # Save to file if requested\n        if ($SaveToFile) {\n            $fullOutput | Out-File -FilePath $outputFile -Encoding UTF8 -Width 500\n            Write-Host \"? Complete build log saved to: $outputFile\" -ForegroundColor Green\n        }\n\n        # Parse and display errors prominently\n        $errorLines = ($stdout + $stderr) -split \"`n\" | Where-Object { $_ -match \"error|Error|ERROR|\\s+CS\\d+|\\s+MSB\\d+\" }\n\n        if ($errorLines) {\n            Write-Host \"`n? BUILD ERRORS FOUND:\" -ForegroundColor Red\n            Write-Host \"=\" * 50 -ForegroundColor Red\n            $errorLines | ForEach-Object {\n                Write-Host $_ -ForegroundColor Red\n            }\n            Write-Host \"=\" * 50 -ForegroundColor Red\n\n            if ($SaveToFile) {\n                Write-Host \"?? Full details in: $outputFile\" -ForegroundColor Yellow\n            }\n        } else {\n            Write-Host \"? No errors found!\" -ForegroundColor Green\n        }\n\n        # Display summary\n        Write-Host \"`n?? BUILD SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"   Duration: $($duration.TotalSeconds) seconds\" -ForegroundColor Gray\n        Write-Host \"   Exit Code: $exitCode\" -ForegroundColor $(if ($exitCode -eq 0) { \"Green\" } else { \"Red\" })\n\n        if ($exitCode -eq 0) {\n            Write-Host \"   Status: SUCCESS ?\" -ForegroundColor Green\n        } else {\n            Write-Host \"   Status: FAILED ?\" -ForegroundColor Red\n        }\n\n        return @{\n            ExitCode = $exitCode\n            Duration = $duration\n            ErrorLines = $errorLines\n            OutputFile = if ($SaveToFile) { $outputFile } else { $null }\n            FullOutput = $fullOutput\n        }\n\n    } catch {\n        Write-Error \"Failed to execute build: $($_.Exception.Message)\"\n        return $null\n    }\n}\n\nfunction Start-BusBuddyBuildFull {\n    <#\n    .SYNOPSIS\n        Enhanced bb-build with complete output capture\n    #>\n    Get-BusBuddyBuildOutput -SaveToFile\n}\n\nfunction Get-BusBuddyBuildErrors {\n    <#\n    .SYNOPSIS\n        Get only build errors without full output\n    #>\n    Get-BusBuddyBuildOutput -ErrorsOnly\n}\n\nfunction Show-BusBuddyBuildLog {\n    <#\n    .SYNOPSIS\n        Show the most recent build log\n    #>\n    $latestLog = Get-ChildItem \"logs\\build-output-*.log\" | Sort-Object LastWriteTime -Descending | Select-Object -First 1\n\n    if ($latestLog) {\n        Write-Host \"?? Most recent build log: $($latestLog.Name)\" -ForegroundColor Cyan\n        Write-Host \"?? Created: $($latestLog.LastWriteTime)\" -ForegroundColor Gray\n        Write-Host \"\"\n        Get-Content $latestLog.FullName\n    } else {\n        Write-Host \"No build logs found. Run Start-BusBuddyBuildFull first.\" -ForegroundColor Yellow\n    }\n}\n\n#endregion\n\n# Export functions\nExport-ModuleMember -Function Get-BusBuddyBuildOutput, Start-BusBuddyBuildFull, Get-BusBuddyBuildErrors, Show-BusBuddyBuildLog\n",
            "Description": "Enhanced build output capture for BusBuddy - eliminates truncated terminal output",
            "Guid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.BuildOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Build Output Capture NoTruncation BusBuddy Build Output Capture NoTruncation",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": "v1.0.0 - Initial release\n- Complete build output capture without truncation\n- Automatic error parsing and highlighting\n- Timestamped log file generation\n- Enhanced terminal buffer configuration",
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Project",
            "Copyright": "(c) 2025 BusBuddy Project. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.BuildOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestOutput",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\nSet-StrictMode -Version 3.0\r\n\r\n# Avoid auto-executing on import - provide wrapper to run the script when requested\r\n$moduleRoot = Split-Path -Parent $PSScriptRoot\r\n$workspaceRoot = Split-Path -Parent (Split-Path -Parent $moduleRoot)\r\n$enhancedTestPath = Join-Path $workspaceRoot 'PowerShell\\Scripts\\Enhanced-Test-Output.ps1'\r\n\r\nfunction Invoke-BusBuddyEnhancedTestOutput {\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(ValueFromRemainingArguments = $true)]\r\n        [object[]] $Args\r\n    )\r\n    if (-not (Test-Path -LiteralPath $enhancedTestPath)) {\r\n        Write-Error \"Enhanced-Test-Output.ps1 not found at: $enhancedTestPath\"\r\n        return\r\n    }\r\n    & $enhancedTestPath @Args\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyEnhancedTestOutput\r\n",
            "Description": "",
            "Guid": "7c6a0d9e-1f2a-4b9e-b5a2-1c5f5d5b8a1c",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestOutput",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "1.0.0",
            "ModuleType": 0,
            "Author": "BusBuddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy",
            "Copyright": "(c) BusBuddy",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.TestOutput.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.ThemeValidation",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation\\BusBuddy.ThemeValidation.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.ThemeValidation Module\r\n# Validates Syncfusion theme/style consistency across WPF XAML files.\r\n# Docs reference: https://help.syncfusion.com/wpf/themes/overview\r\n\r\nfunction Test-BusBuddyThemeConsistency {\r\n    <#\r\n    .SYNOPSIS\r\n        Scan XAML views for inline Syncfusion control styling violations.\r\n    .DESCRIPTION\r\n        Looks for Syncfusion controls (SfDataGrid, ButtonAdv, DockingManager etc.)\r\n        with inline size/margin/brush properties that should be centralized in resource dictionaries.\r\n    .OUTPUTS\r\n        Hashtable with Issues (string[]) and Status (Success|Failed)\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views'\r\n    )\r\n    $issues = New-Object System.Collections.Generic.List[string]\r\n    if (-not (Test-Path $ViewsPath)) {\r\n        Write-Warning \"Views path not found: $ViewsPath\"\r\n        return @{ Issues = @('Views path missing'); Status = 'Failed' }\r\n    }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    $mergedDictionaries = @{}\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $mergeMatches = [regex]::Matches($content,'<ResourceDictionary\\s+Source=\"([^\"]+)\"')\r\n        foreach ($m in $mergeMatches) { $mergedDictionaries[$m.Groups[1].Value] = $true }\r\n        # Detect inline width/height/margin on Syncfusion ButtonAdv or SfButton / SfDataGrid\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)[^>]*(Width|Height|Margin)=') {\r\n            $issues.Add(\"Inline layout property on Syncfusion button in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:SfDataGrid[^>]*(RowHeight|HeaderRowHeight|Background|BorderBrush)=') {\r\n            $issues.Add(\"Inline SfDataGrid visual property in $($file.Name)\")\r\n        }\r\n        # Missing namespace check (should declare syncfusion namespace where controls appear)\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'xmlns:syncfusion=') {\r\n            $issues.Add(\"Missing syncfusion xmlns in $($file.Name)\")\r\n        }\r\n        if ($content -match '<syncfusion:' -and $content -notmatch 'FluentDark' -and $content -notmatch 'FluentLight') {\r\n            $issues.Add(\"Potential missing theme reference (FluentDark/FluentLight) in $($file.Name)\")\r\n        }\r\n    }\r\n    if (-not ($mergedDictionaries.Keys | Where-Object { $_ -match 'Themes' })) {\r\n        $issues.Add('No merged resource dictionaries referencing Themes folder detected')\r\n    }\r\n    $status = if ($issues.Count -gt 0) { 'Failed' } else { 'Success' }\r\n    return @{ Issues = $issues.ToArray(); Status = $status; FileCount = $xamlFiles.Count; MergedDictionaries = $mergedDictionaries.Keys }\r\n}\r\n\r\nfunction Invoke-BusBuddyThemeRemediation {\r\n    <#\r\n    .SYNOPSIS\r\n        Attempt automatic remediation of common inline styling issues.\r\n    .DESCRIPTION\r\n        Replaces common inline size/margin attributes on Syncfusion buttons with Style reference.\r\n        Only performs safe textual substitutions; more advanced refactoring deferred post-MVP.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [string]$ViewsPath = 'BusBuddy.WPF/Views',\r\n        [string]$ButtonStyleKey = 'SyncfusionPrimaryButtonStyle'\r\n    )\r\n    if (-not (Test-Path $ViewsPath)) { Write-Warning \"Views path not found: $ViewsPath\"; return }\r\n    $xamlFiles = Get-ChildItem $ViewsPath -Recurse -Include *.xaml -ErrorAction SilentlyContinue\r\n    foreach ($file in $xamlFiles) {\r\n        $content = Get-Content $file.FullName -Raw\r\n        $original = $content\r\n        $modified = $false\r\n        # Replace inline width/height/margin on buttons with style if not already styled\r\n        if ($content -match '<syncfusion:(?:ButtonAdv|SfButton)' -and $content -notmatch 'Style=\"{StaticResource') {\r\n            $content = [regex]::Replace($content,'(<syncfusion:(?:ButtonAdv|SfButton)[^>]*)(Width|Height|Margin)=\"[^\"]+\"','${1}')\r\n            if ($content -ne $original) { $modified = $true }\r\n            if ($modified) {\r\n                $content = [regex]::Replace($content,'<syncfusion:(ButtonAdv|SfButton)([^>]*)>','<syncfusion:$1$2 Style=\"{StaticResource ' + $ButtonStyleKey + '}\">')\r\n            }\r\n        }\r\n        if ($modified -and $PSCmdlet.ShouldProcess($file.FullName,'Apply style remediation')) {\r\n            $content | Set-Content $file.FullName -Encoding UTF8\r\n            Write-Information \"Remediated: $($file.Name)\" -InformationAction Continue\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyThemeConsistency,Invoke-BusBuddyThemeRemediation\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.ThemeValidation",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.AzureSqlHealth",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth\\BusBuddy.AzureSqlHealth.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.AzureSqlHealth Module\r\n# References: https://learn.microsoft.com/azure/azure-sql/database/connectivity-architecture\r\n\r\nfunction Test-BusBuddyAzureSql {\r\n    <#\r\n    .SYNOPSIS\r\n        Test connectivity to Azure SQL (fallback to LocalDB on failure).\r\n    .OUTPUTS\r\n        Bool indicating Azure SQL connectivity success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) {\r\n        Write-Warning \"Azure settings file not found: $SettingsPath\"\r\n        return $false\r\n    }\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 2\r\n    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n    $lastError = $null\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n            $connString = $json.ConnectionStrings.DefaultConnection\r\n            if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n            $query = 'SELECT TOP 1 name FROM sys.databases'\r\n            $result = Invoke-Sqlcmd -ConnectionString $connString -Query $query -ErrorAction Stop\r\n            $stopwatch.Stop()\r\n            Write-Information \"? Azure SQL reachable (attempt $attempts) latency=$([math]::Round($stopwatch.Elapsed.TotalMilliseconds,0))ms Databases: $($result.name -join ',')\" -InformationAction Continue\r\n            return $true\r\n        } catch {\r\n            $lastError = $_.Exception.Message\r\n            Write-Warning \"Attempt $attempts failed: $lastError\"\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds *= 2 }\r\n        }\r\n    }\r\n    $stopwatch.Stop()\r\n    Write-Warning \"?? Azure SQL test failed after $attempts attempts: $lastError\"\r\n    return $false\r\n}\r\n\r\nfunction Test-BusBuddyAzureSqlNative {\r\n    <#\r\n    .SYNOPSIS\r\n        Test Azure SQL connectivity using System.Data.SqlClient directly (no sqlcmd dependency).\r\n    .DESCRIPTION\r\n        Reads connection string from appsettings.azure.json (ConnectionStrings.DefaultConnection) and attempts to open a connection\r\n        and run a lightweight query. Implements simple retry with exponential backoff.\r\n        Docs: https://learn.microsoft.com/dotnet/api/system.data.sqlclient.sqlconnection.open\r\n    .OUTPUTS\r\n        Bool indicating success.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [string]$SettingsPath = 'appsettings.azure.json'\r\n    )\r\n    if (-not (Test-Path $SettingsPath)) { Write-Warning \"Azure settings file not found: $SettingsPath\"; return $false }\r\n    try {\r\n        $json = Get-Content $SettingsPath -Raw | ConvertFrom-Json -ErrorAction Stop\r\n        $connString = $json.ConnectionStrings.DefaultConnection\r\n        if (-not $connString) { throw 'Connection string not found in JSON (ConnectionStrings.DefaultConnection)' }\r\n    } catch {\r\n        Write-Warning \"Failed to parse ${SettingsPath}: $($_.Exception.Message)\"; return $false\r\n    }\r\n\r\n    # Expand ${ENV_VAR} placeholders if present in connection string\r\n    # Pattern sourced from standard PowerShell regex usage - see Microsoft Docs: about_Regular_Expressions\r\n    $expandEnv = {\r\n        param([string]$s)\r\n        if ([string]::IsNullOrWhiteSpace($s)) { return $s }\r\n        return [regex]::Replace($s, '\\$\\{([A-Za-z0-9_]+)\\}', {\r\n            param($m)\r\n            $name = $m.Groups[1].Value\r\n            $val  = [Environment]::GetEnvironmentVariable($name)\r\n            if (-not $val) { $m.Value } else { $val }\r\n        })\r\n    }\r\n    $original = $connString\r\n    $connString = & $expandEnv $connString\r\n    if ($connString -match '\\$\\{') {\r\n        Write-Information \"?? One or more environment placeholders are unresolved in connection string (file=${SettingsPath}). Set required variables in the environment before running tests.\" -InformationAction Continue\r\n    }\r\n\r\n    $attempts = 0\r\n    $maxAttempts = 3\r\n    $delaySeconds = 1\r\n    $sw = [System.Diagnostics.Stopwatch]::StartNew()\r\n    while ($attempts -lt $maxAttempts) {\r\n        $attempts++\r\n        try {\r\n            $conn = [System.Data.SqlClient.SqlConnection]::new($connString)\r\n            $conn.Open()\r\n            try {\r\n                $cmd = $conn.CreateCommand()\r\n                $cmd.CommandText = 'SELECT DB_NAME()'\r\n                $db = $cmd.ExecuteScalar()\r\n                $sw.Stop()\r\n                Write-Information (\"? Azure SQL (native) reachable on attempt {0} - DB: {1}, latency={2}ms\" -f $attempts, $db, [math]::Round($sw.Elapsed.TotalMilliseconds,0)) -InformationAction Continue\r\n                return $true\r\n            } finally {\r\n                $conn.Dispose()\r\n            }\r\n        } catch {\r\n            Write-Warning (\"Native attempt {0} failed: {1}\" -f $attempts, $_.Exception.Message)\r\n            if ($attempts -lt $maxAttempts) { Start-Sleep -Seconds $delaySeconds; $delaySeconds = [Math]::Min($delaySeconds * 2, 8) }\r\n        }\r\n    }\r\n    $sw.Stop()\r\n    Write-Warning \"?? Azure SQL (native) test failed after $attempts attempts.\"\r\n    return $false\r\n}\r\n\r\nfunction Get-BusBuddySqlStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Provide detailed Azure SQL / LocalDB status summary.\r\n    .OUTPUTS\r\n        Hashtable with status fields.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [string]$AzureSettingsPath = 'appsettings.azure.json',\r\n        [string]$LocalSettingsPath = 'appsettings.json'\r\n    )\r\n    $status = [ordered]@{}\r\n    $status.Timestamp = Get-Date\r\n    $status.AzureSettingsPresent = Test-Path $AzureSettingsPath\r\n    $status.LocalSettingsPresent = Test-Path $LocalSettingsPath\r\n    $status.AzureReachable = $false\r\n    $status.LocalDbReachable = $false\r\n\r\n    if ($status.AzureSettingsPresent) {\r\n        $status.AzureReachable = Test-BusBuddyAzureSql -SettingsPath $AzureSettingsPath\r\n    }\r\n    # LocalDB quick probe via sqlcmd if installed\r\n    try {\r\n        $localJson = if (Test-Path $LocalSettingsPath) { Get-Content $LocalSettingsPath -Raw | ConvertFrom-Json } else { $null }\r\n        $localConn = $localJson.ConnectionStrings.DefaultConnection\r\n        if ($localConn -and $localConn -match 'localdb') {\r\n            try {\r\n                Invoke-Sqlcmd -ConnectionString $localConn -Query 'SELECT 1' -ErrorAction Stop | Out-Null\r\n                $status.LocalDbReachable = $true\r\n            } catch {\r\n                $status.LocalDbReachable = $false\r\n            }\r\n        }\r\n    } catch {\r\n        $status.LocalDbReachable = $false\r\n    }\r\n\r\n    $status.PrimaryDataSource = if ($status.AzureReachable) { 'Azure' } elseif ($status.LocalDbReachable) { 'LocalDB' } else { 'Unknown' }\r\n    return $status\r\n}\r\n\r\nExport-ModuleMember -Function Test-BusBuddyAzureSql,Test-BusBuddyAzureSqlNative,Get-BusBuddySqlStatus\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.AzureSqlHealth",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.TestWatcher",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher\\BusBuddy.TestWatcher.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.TestWatcher Module\r\n# Provides debounced file change watching to trigger targeted test runs.\r\n\r\nfunction Start-BusBuddyTestWatchAdvanced {\r\n    <#\r\n    .SYNOPSIS\r\n        Start debounced test watch loop for a specific test suite.\r\n    .DESCRIPTION\r\n        Watches for changes to .cs and .xaml files under repo root and re-runs Get-BusBuddyTestOutput.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite = 'Unit',\r\n        [int]$DebounceSeconds = 2,\r\n        [switch]$RetryOnFailure,\r\n        [int]$MaxRetries = 2,\r\n        [int]$RetryDelaySeconds = 2\r\n    )\r\n    if ($script:BusBuddyTestWatchHandle) { Write-Warning 'Test watch already running.'; return }\r\n    $root = Get-Location\r\n    Write-Information \"?? Watching $root for changes (suite=$TestSuite, debounce=${DebounceSeconds}s)\" -InformationAction Continue\r\n    $watcher = New-Object System.IO.FileSystemWatcher -Property @{ Path = $root; Filter = '*.*'; IncludeSubdirectories = $true; EnableRaisingEvents = $true }\r\n    $script:BusBuddyTestWatchLastRun = Get-Date 0\r\n    $script:BusBuddyTestWatchIgnored = 0\r\n    $script:BusBuddyTestWatchTriggered = 0\r\n    $script:BusBuddyTestWatchFailures = 0\r\n    $script:BusBuddyTestWatchRetries = 0\r\n    # Correlation ID for this watcher session\r\n    $script:BusBuddyTestWatchCorrelation = [guid]::NewGuid().ToString()\r\n    $action = {\r\n        $full = $Event.SourceEventArgs.FullPath\r\n        $ext = [IO.Path]::GetExtension($full)\r\n        if ($ext -notin '.cs','.xaml') {\r\n            Write-Verbose (\"Ignoring change due to unsupported extension: {0}\" -f $ext)\r\n            return\r\n        }\r\n        # Ignore build/test artifacts to avoid infinite loops (bin/obj/TestResults/.git/.vs)\r\n        if ($full -match \"(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\\") {\r\n            $script:BusBuddyTestWatchIgnored++\r\n            Write-Verbose (\"Ignoring change in excluded path: {0}\" -f $full)\r\n            return\r\n        }\r\n        $now = Get-Date\r\n        $elapsed = ($now - $script:BusBuddyTestWatchLastRun).TotalSeconds\r\n        if ($elapsed -lt $using:DebounceSeconds) {\r\n            $remaining = [math]::Max([int]([math]::Ceiling($using:DebounceSeconds - $elapsed)), 0)\r\n            Write-Verbose (\"Debounce active - event suppressed. Time remaining: {0}s\" -f $remaining)\r\n            return\r\n        }\r\n        $script:BusBuddyTestWatchLastRun = $now\r\n        $script:BusBuddyTestWatchTriggered++\r\n        Write-Information \"?? [$script:BusBuddyTestWatchCorrelation] Change detected: $($Event.SourceEventArgs.Name) -> running $using:TestSuite tests (trigger #$script:BusBuddyTestWatchTriggered, ignored so far=$script:BusBuddyTestWatchIgnored)\" -InformationAction Continue\r\n        try {\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n        } catch {\r\n            $script:BusBuddyTestWatchFailures++\r\n            Write-Warning \"[$script:BusBuddyTestWatchCorrelation] Test watch run failed (#$script:BusBuddyTestWatchFailures): $($_.Exception.Message)\"\r\n            if ($using:RetryOnFailure) {\r\n                $attempt = 0\r\n                $delay = [int]$using:RetryDelaySeconds\r\n                while ($attempt -lt [int]$using:MaxRetries) {\r\n                    $attempt++\r\n                    $script:BusBuddyTestWatchRetries++\r\n                    Write-Information (\"?? [$script:BusBuddyTestWatchCorrelation] Retry trigger #{0} (attempt {1}/{2}) after failure - waiting {3}s...\" -f $script:BusBuddyTestWatchRetries, $attempt, [int]$using:MaxRetries, $delay) -InformationAction Continue\r\n                    Start-Sleep -Seconds $delay\r\n                    try {\r\n                        Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile | Out-Null\r\n                        Write-Information \"? [$script:BusBuddyTestWatchCorrelation] Retry succeeded on attempt $attempt\" -InformationAction Continue\r\n                        break\r\n                    } catch {\r\n                        Write-Warning (\"[$script:BusBuddyTestWatchCorrelation] Retry attempt {0} failed: {1}\" -f $attempt, $_.Exception.Message)\r\n                        $delay = [math]::Min($delay * 2, 30)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    $handler = Register-ObjectEvent -InputObject $watcher -EventName Changed -Action $action\r\n    $script:BusBuddyTestWatchHandle = @{ Watcher = $watcher; Handler = $handler }\r\n    Write-Information \"Press Ctrl+C or run Stop-BusBuddyTestWatchAdvanced to stop. CorrelationId=$script:BusBuddyTestWatchCorrelation\" -InformationAction Continue\r\n}\r\n\r\nfunction Stop-BusBuddyTestWatchAdvanced {\r\n    [CmdletBinding()] param()\r\n    if (-not $script:BusBuddyTestWatchHandle) { Write-Warning 'No active test watch.'; return }\r\n    try {\r\n        $script:BusBuddyTestWatchHandle.Handler | Unregister-Event -ErrorAction SilentlyContinue\r\n        $script:BusBuddyTestWatchHandle.Watcher.EnableRaisingEvents = $false\r\n        $script:BusBuddyTestWatchHandle.Watcher.Dispose()\r\n        Write-Information '?? Test watch stopped.' -InformationAction Continue\r\n    } finally { Remove-Variable BusBuddyTestWatchHandle -Scope Script -ErrorAction SilentlyContinue }\r\n}\r\n\r\nExport-ModuleMember -Function Start-BusBuddyTestWatchAdvanced,Stop-BusBuddyTestWatchAdvanced\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.TestWatcher",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy.Cleanup",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup\\BusBuddy.Cleanup.psm1",
            "ImplementingAssembly": null,
            "Definition": "# BusBuddy.Cleanup Module\r\n# Implements repository hygiene and artifact cleanup per project guidelines.\r\n\r\nfunction Invoke-BusBuddyCleanup {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove build artifacts and old log files.\r\n    .DESCRIPTION\r\n        Deletes bin/, obj/, TestResults/, and logs older than a retention window (default 7 days).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$LogRetentionDays = 7,\r\n        [switch]$IncludeNodeModules\r\n    )\r\n    $paths = @('bin','obj','TestResults')\r\n    if ($IncludeNodeModules) { $paths += 'node_modules' }\r\n    foreach ($p in $paths) {\r\n        Get-ChildItem -Recurse -Directory -Filter $p -ErrorAction SilentlyContinue | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove directory')) {\r\n                try { Remove-Item $_.FullName -Recurse -Force -ErrorAction Stop; Write-Information \"??? Removed $($_.FullName)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove $($_.FullName): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    if (Test-Path logs) {\r\n        $threshold = (Get-Date).AddDays(-$LogRetentionDays)\r\n        Get-ChildItem logs -File -Include *.log -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $threshold } | ForEach-Object {\r\n            if ($PSCmdlet.ShouldProcess($_.FullName,'Remove old log')) {\r\n                try { Remove-Item $_.FullName -Force; Write-Information \"?? Removed old log $($_.Name)\" -InformationAction Continue } catch { Write-Warning \"Failed to remove log $($_.Name): $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Identify candidate unused .cs/.xaml files not referenced in solution or project includes.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([string[]])]\r\n    param(\r\n        [string]$Root = '.'\r\n    )\r\n    $solution = Get-ChildItem -Path $Root -Filter *.sln -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1\r\n    if (-not $solution) { Write-Warning 'Solution file not found.'; return @() }\r\n    $solutionText = Get-Content $solution.FullName -Raw\r\n    $candidates = Get-ChildItem $Root -Recurse -Include *.cs,*.xaml -File -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notmatch 'bin\\\\|obj\\\\|TestResults\\\\|\\.git' }\r\n    $unused = @()\r\n    foreach ($f in $candidates) {\r\n        if ($solutionText -notmatch [regex]::Escape($f.Name)) { $unused += $f.FullName }\r\n    }\r\n    return $unused\r\n}\r\n\r\nfunction Remove-BusBuddyUnusedFiles {\r\n    <#\r\n    .SYNOPSIS\r\n        Remove unused files interactively (WhatIf supported).\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Medium')]\r\n    param(\r\n        [string]$Root='.'\r\n    )\r\n    $unused = Get-BusBuddyUnusedFiles -Root $Root\r\n    if (-not $unused -or $unused.Count -eq 0) { Write-Information 'No unused files detected.' -InformationAction Continue; return }\r\n    foreach ($file in $unused) {\r\n        if ($PSCmdlet.ShouldProcess($file,'Remove unused file')) {\r\n            try { Remove-Item $file -Force; Write-Information \"Removed unused file $file\" -InformationAction Continue } catch { $warn = 'Failed to remove ' + $file + ' -> ' + $_.Exception.Message; Write-Warning $warn }\r\n        }\r\n    }\r\n}\r\n\r\nExport-ModuleMember -Function Invoke-BusBuddyCleanup,Get-BusBuddyUnusedFiles,Remove-BusBuddyUnusedFiles\r\n",
            "Description": "",
            "Guid": "00000000-0000-0000-0000-000000000000",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Cleanup",
            "PrivateData": null,
            "ExperimentalFeatures": "",
            "Tags": "",
            "ProjectUri": null,
            "IconUri": null,
            "LicenseUri": null,
            "ReleaseNotes": null,
            "RepositorySourceLocation": null,
            "Version": "0.0",
            "ModuleType": 0,
            "Author": null,
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": null,
            "Copyright": null,
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": null,
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "",
            "CompatiblePSEditions": "",
            "ModuleList": "",
            "NestedModules": "",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": null,
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": null,
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          }
        ],
        "PowerShellHostName": null,
        "PowerShellHostVersion": null,
        "PowerShellVersion": {
          "Major": 7,
          "Minor": 5,
          "Build": -1,
          "Revision": -1,
          "MajorRevision": -1,
          "MinorRevision": -1
        },
        "ProcessorArchitecture": 0,
        "Scripts": [],
        "RequiredAssemblies": [],
        "RequiredModules": [],
        "RootModule": "BusBuddy.psm1",
        "ExportedVariables": {},
        "ExportedAliases": {
          "bbBuild": {
            "ReferencedCommand": "Invoke-BusBuddyBuild",
            "ResolvedCommand": "Invoke-BusBuddyBuild",
            "Definition": "Invoke-BusBuddyBuild",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbBuild",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbCommands": {
            "ReferencedCommand": "Get-BusBuddyCommand",
            "ResolvedCommand": "Get-BusBuddyCommand",
            "Definition": "Get-BusBuddyCommand",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbCommands",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbDevSession": {
            "ReferencedCommand": "Start-BusBuddyDevSession",
            "ResolvedCommand": "Start-BusBuddyDevSession",
            "Definition": "Start-BusBuddyDevSession",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbDevSession",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbHealth": {
            "ReferencedCommand": "Invoke-BusBuddyHealthCheck",
            "ResolvedCommand": "Invoke-BusBuddyHealthCheck",
            "Definition": "Invoke-BusBuddyHealthCheck",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbHealth",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbRun": {
            "ReferencedCommand": "Invoke-BusBuddyRun",
            "ResolvedCommand": "Invoke-BusBuddyRun",
            "Definition": "Invoke-BusBuddyRun",
            "Options": 0,
            "Description": "",
            "OutputType": "",
            "Name": "bbRun",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          },
          "bbTest": {
            "ReferencedCommand": "Invoke-BusBuddyTest",
            "ResolvedCommand": "Invoke-BusBuddyTest",
            "Definition": "Invoke-BusBuddyTest",
            "Options": 0,
            "Description": "",
            "OutputType": "System.Collections.Hashtable",
            "Name": "bbTest",
            "CommandType": 1,
            "Source": "BusBuddy",
            "Version": "2.0.0",
            "Visibility": 0,
            "ModuleName": "BusBuddy",
            "Module": "BusBuddy",
            "RemotingCapability": 1,
            "Parameters": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.ParameterMetadata]",
            "ParameterSets": null
          }
        },
        "ExportedDscResources": [],
        "SessionState": {
          "Drive": {
            "Current": "C"
          },
          "Provider": {},
          "Path": {
            "CurrentLocation": "C:\\Users\\biges\\Desktop\\BusBuddy",
            "CurrentFileSystemLocation": "C:\\Users\\biges\\Desktop\\BusBuddy"
          },
          "PSVariable": {},
          "LanguageMode": 0,
          "UseFullLanguageModeInDebugger": false,
          "Scripts": [
            "*"
          ],
          "Applications": [
            "*"
          ],
          "Module": {
            "LogPipelineExecutionDetails": false,
            "Name": "BusBuddy",
            "Path": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1",
            "ImplementingAssembly": null,
            "Definition": "#requires -Version 7.5\r\n# NOTE: Module updated to require PowerShell 7.5+ per project standards.\r\n# References:\r\n# - Microsoft PowerShell Module Guidelines: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n# - Streams and Error Handling: https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n\r\n##region Enhanced Test Output Functions\r\nfunction Get-BusBuddyTestOutput {\r\n<#\r\n.SYNOPSIS\r\n    Run solution/tests with full build + test output capture.\r\n#>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All',\r\n        [string]$ProjectPath='BusBuddy.sln',\r\n        [switch]$SaveToFile,\r\n        [string]$Filter,\r\n        [ValidateSet('quiet','minimal','normal','detailed','diagnostic')][string]$Verbosity='normal'\r\n    )\r\n    $ts = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n    $logDir = 'logs'; if(-not (Test-Path $logDir)){New-Item -ItemType Directory -Path $logDir|Out-Null}\r\n    $file = Join-Path $logDir \"test-output-$TestSuite-$ts.log\"\r\n    if(-not $Filter){\r\n        $Filter = switch($TestSuite){\r\n            'Unit' {'Category=Unit|TestCategory=Unit'}\r\n            'Integration' {'Category=Integration|TestCategory=Integration'}\r\n            'Validation' {'Category=Validation|TestCategory=Validation'}\r\n            'Core' {'FullyQualifiedName~BusBuddy.Tests.Core'}\r\n            'WPF' {'FullyQualifiedName~BusBuddy.UITests'}\r\n            default {''}\r\n        }\r\n    }\r\n    try {\r\n        $start = Get-Date\r\n        Write-Information \"??? Building...\" -InformationAction Continue\r\n        $buildOutPath = Join-Path $logDir \"build-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet build ($Verbosity)\")) {\r\n            & dotnet build $ProjectPath --configuration Debug --verbosity $Verbosity 2>&1 |\r\n                Tee-Object -FilePath $buildOutPath\r\n        }\r\n        $buildExit = $LASTEXITCODE\r\n        if($buildExit -ne 0){\r\n            Write-Error 'Build failed'\r\n            return @{ ExitCode=$buildExit; Status='BuildFailed'; BuildOutput= (Get-Content $buildOutPath -Raw) }\r\n        }\r\n        Write-Information '?? Testing...' -InformationAction Continue\r\n        # Use explicit TRX filename per CI/reporting standards\r\n        # Docs: https://learn.microsoft.com/visualstudio/test/diagnostics/loggers?view=vs-2022\r\n        $testArgs = @(\r\n            'test', $ProjectPath,\r\n            '--configuration','Debug',\r\n            '--verbosity',$Verbosity,\r\n            '--logger','trx;LogFileName=Tests.trx',\r\n            '--results-directory','TestResults',\r\n            '--collect:XPlat Code Coverage',\r\n            '--no-build'\r\n        )\r\n        if($Filter){$testArgs += @('--filter',$Filter)}\r\n        $testOutPath = Join-Path $logDir \"test-$ts.log\"\r\n        if ($PSCmdlet.ShouldProcess($ProjectPath, \"dotnet $($testArgs -join ' ')\")) {\r\n            & dotnet @testArgs 2>&1 | Tee-Object -FilePath $testOutPath\r\n        }\r\n        $exit = $LASTEXITCODE\r\n        $end = Get-Date; $dur = $end - $start\r\n        $testStd = Get-Content $testOutPath -Raw\r\n        $passed = [regex]::Matches($testStd,'Passed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $failed = [regex]::Matches($testStd,'Failed:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $skipped = [regex]::Matches($testStd,'Skipped:\\s+(\\d+)')|ForEach-Object{[int]$_.Groups[1].Value}|Measure-Object -Sum|Select-Object -ExpandProperty Sum\r\n        $summary = \"TestSuite=$TestSuite Duration=$([int]$dur.TotalSeconds)s Passed=$passed Failed=$failed Skipped=$skipped ExitCode=$exit\"\r\n        if($SaveToFile){ $summary | Out-File -FilePath $file -Encoding utf8; Write-Information \"Saved: $file\" -InformationAction Continue }\r\n        if($failed -gt 0){ Write-Error \"Failures detected ($failed)\" }\r\n        return @{ ExitCode=$exit; Duration=$dur; PassedTests=$passed; FailedTests=$failed; SkippedTests=$skipped; OutputFile= (if($SaveToFile){$file}); Status= (if($exit -eq 0){'Success'} else {'Failed'}) }\r\n    } catch {\r\n        Write-Error $_.Exception.Message\r\n        return @{ ExitCode=-1; Status='Error'; ErrorMessage=$_.Exception.Message }\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestFull {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n}\r\n\r\nfunction Get-BusBuddyTestError {\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='All'\r\n    )\r\n    Get-BusBuddyTestOutput -TestSuite $TestSuite -Verbosity quiet\r\n}\r\n\r\nfunction Get-BusBuddyTestLog {\r\n    [CmdletBinding()]\r\n    param()\r\n    $l = Get-ChildItem 'logs/test-output-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n    if($l){\r\n        Write-Information \"?? $($l.Name)\" -InformationAction Continue\r\n        Get-Content $l.FullName\r\n    } else {\r\n        Write-Information 'No test logs found. Run bbTestFull first.' -InformationAction Continue\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyTestWatch {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([System.Management.Automation.Job[]])]\r\n    param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')]\r\n        [string]$TestSuite='Unit'\r\n    )\r\n    Write-Information \"?? Watch $TestSuite\" -InformationAction Continue\r\n    if ($PSCmdlet.ShouldProcess('Tests',\"Run initial suite: $TestSuite\")) {\r\n        Get-BusBuddyTestOutput -TestSuite $TestSuite -SaveToFile\r\n    }\r\n\r\n    # FIX: Correct FileSystemWatcher usage\r\n    # Docs: https://learn.microsoft.com/dotnet/api/system.io.filesystemwatcher\r\n    $path = (Get-Location).Path\r\n    $w = New-Object System.IO.FileSystemWatcher -ArgumentList $path, '*.cs'\r\n    $w.IncludeSubdirectories = $true\r\n    $w.EnableRaisingEvents   = $true\r\n\r\n    $action = {\r\n        Start-Sleep 1\r\n        Write-Information '?? Change detected - re-running tests' -InformationAction Continue\r\n        try {\r\n            $p = $Event.SourceEventArgs.FullPath\r\n            if ($p -match '(?i)\\\\bin\\\\|\\\\obj\\\\|\\\\TestResults\\\\|\\\\\\.git\\\\|\\\\\\.vs\\\\') { return }\r\n            $ext = [IO.Path]::GetExtension($p)\r\n            if ($ext -notin '.cs','.xaml') { return }\r\n            Get-BusBuddyTestOutput -TestSuite $using:TestSuite -SaveToFile\r\n        } catch { Write-Warning \"Watcher action failed: $($_.Exception.Message)\" }\r\n    }\r\n\r\n    $subs = @()\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Changed -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Created -Action $action\r\n    $subs += Register-ObjectEvent -InputObject $w -EventName Renamed -Action $action\r\n\r\n    # Return event subscriptions so the caller can Unregister-Event / Remove-Job when done\r\n    return $subs\r\n}\r\n##endregion\r\n<#\r\n.SYNOPSIS\r\n    BusBuddy PowerShell Module - Complete Working Module\r\n\r\n.DESCRIPTION\r\n    Professional PowerShell module for Bus Buddy WPF development environment.\r\n    This is a WORKING version that contains all functions inline rather than\r\n    trying to load them from separate files (which has scoping issues).\r\n\r\n.NOTES\r\n    File Name      : BusBuddy.psm1\r\n    Author         : Bus Buddy Development Team\r\n    Prerequisite   : PowerShell 7.5.2+   # FIX: align with #requires -Version 7.5\r\n    Copyright      : (c) 2025 Bus Buddy Project\r\n#>\r\n\r\n#region Module Initialization and Buffer Configuration\r\n\r\n# Configure PowerShell Buffer Limits to Prevent Truncated Output\r\ntry {\r\n    if ($Host.UI.RawUI) {\r\n        # Increase buffer size for full output capture\r\n        $newBuffer = New-Object System.Management.Automation.Host.Size(200, 3000)\r\n        $Host.UI.RawUI.BufferSize = $newBuffer\r\n\r\n        # Increase window size for better visibility\r\n        $currentWindow = $Host.UI.RawUI.WindowSize\r\n        $maxWidth = [Math]::Min(200, $currentWindow.Width)\r\n        $maxHeight = [Math]::Min(50, $currentWindow.Height)\r\n        $newWindow = New-Object System.Management.Automation.Host.Size($maxWidth, $maxHeight)\r\n        $Host.UI.RawUI.WindowSize = $newWindow\r\n    }\r\n\r\n    # Configure output preferences\r\n    $OutputEncoding = [System.Text.Encoding]::UTF8\r\n    $PSDefaultParameterValues['Out-File:Encoding'] = 'UTF8'\r\n    $PSDefaultParameterValues['*:Encoding'] = 'UTF8'\r\n\r\n    # Set maximum history count\r\n    if (Get-Command Set-PSReadLineOption -ErrorAction SilentlyContinue) {\r\n        Set-PSReadLineOption -MaximumHistoryCount 10000 -HistoryNoDuplicates\r\n    }\r\n\r\n    Write-Verbose \"? PowerShell buffer configuration optimized for full output capture\"\r\n} catch {\r\n    Write-Warning \"Could not optimize PowerShell buffer: $($_.Exception.Message)\"\r\n}\r\n\r\n\r\n#region Enhanced Output Function Loader (runs after all functions are defined)\r\ntry {\r\n    # Determine project root relative to this module: Modules/BusBuddy/ -> PowerShell/Modules/BusBuddy\r\n    # Repo root is three levels up from this .psm1\r\n    $projectRoot = (Split-Path $PSScriptRoot -Parent | Split-Path -Parent | Split-Path -Parent)\r\n    $enhancedBuildModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.BuildOutput\\BusBuddy.BuildOutput.psd1\"\r\n    $enhancedTestModule  = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.TestOutput\\BusBuddy.TestOutput.psd1\"\r\n\r\n    if (Test-Path $enhancedBuildModule) {\r\n        Import-Module $enhancedBuildModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced build output module loaded\"\r\n    }\r\n\r\n    if (Test-Path $enhancedTestModule) {\r\n        Import-Module $enhancedTestModule -Force -ErrorAction SilentlyContinue\r\n        Write-Verbose \"? Enhanced test output module loaded\"\r\n    } else {\r\n        Write-Warning \"BusBuddy.TestOutput module not found at $enhancedTestModule\"\r\n    }\r\n} catch {\r\n    Write-Warning \"Error loading enhanced output functions: $($_.Exception.Message)\"\r\n}\r\n#endregion\r\n\r\n#region Quick-Win Module Auto Import (ThemeValidation, AzureSqlHealth, TestWatcher, Cleanup)\r\ntry {\r\n    $quickWinModules = @(\r\n        'BusBuddy.ThemeValidation/BusBuddy.ThemeValidation.psm1',\r\n        'BusBuddy.AzureSqlHealth/BusBuddy.AzureSqlHealth.psm1',\r\n        'BusBuddy.TestWatcher/BusBuddy.TestWatcher.psm1',\r\n        'BusBuddy.Cleanup/BusBuddy.Cleanup.psm1'\r\n    )\r\n    # FIX: ensure $projectRoot is set even if previous block failed\r\n    if (-not $projectRoot) { $projectRoot = Get-BusBuddyProjectRoot }\r\n\r\n    $telemetryDir = Join-Path $projectRoot 'logs'\r\n    if (-not (Test-Path $telemetryDir)) { New-Item -ItemType Directory -Path $telemetryDir -Force | Out-Null }\r\n    $telemetryFile = Join-Path $telemetryDir 'module-telemetry.json'\r\n\r\n    foreach ($rel in $quickWinModules) {\r\n        $candidate = Join-Path $projectRoot \"PowerShell/Modules/$rel\"\r\n        if (-not (Test-Path $candidate)) { continue }\r\n        try { Import-Module $candidate -Force -ErrorAction Stop; Write-Verbose \"? Loaded quick-win module: $rel\" }\r\n        catch { Write-Warning \"Failed to load quick-win module $rel -> $($_.Exception.Message)\"; continue }\r\n\r\n        # Lightweight telemetry append with rotation\r\n        try {\r\n            if (Test-Path $telemetryFile) {\r\n                $item = Get-Item -Path $telemetryFile -ErrorAction SilentlyContinue\r\n                if ($item -and $item.Length -gt 1MB) {\r\n                $stamp = Get-Date -Format 'yyyyMMdd-HHmmss'\r\n                    Move-Item $telemetryFile (Join-Path $telemetryDir \"module-telemetry-$stamp.json\") -Force\r\n                }\r\n            }\r\n            ([ordered]@{ Timestamp = (Get-Date).ToString('o'); Module = $rel; Status = 'Loaded' } | ConvertTo-Json -Compress) | Add-Content -Path $telemetryFile\r\n        } catch { Write-Verbose 'Telemetry logging failed' }\r\n    }\r\n} catch { Write-Warning \"Quick-win module import pass failed: $($_.Exception.Message)\" }\r\n#endregion\r\n\r\n#region Telemetry Utilities (module import & future operational events)\r\nfunction Get-BusBuddyTelemetrySummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Summarise module telemetry JSON line files.\r\n    .DESCRIPTION\r\n        Reads module-telemetry*.json (JSON Lines format) from the logs directory, aggregates counts per module\r\n        and optionally returns the last N entries. Designed to be light-weight and safe if files are missing.\r\n    .PARAMETER Last\r\n        Return only the last N entries (in chronological order). 0 means return all (default).\r\n    .PARAMETER LogsPath\r\n        Override path to logs directory (defaults to project root / logs).\r\n    .EXAMPLE\r\n        Get-BusBuddyTelemetrySummary -Last 5\r\n    .OUTPUTS\r\n        PSCustomObject with properties: Total, Modules, Entries (optional)\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [int]$Last = 0,\r\n        [string]$LogsPath\r\n    )\r\n    try {\r\n        if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n        # Copilot: Read JSON lines safely - ignore malformed lines and aggregate by module.\r\n        $files = Get-ChildItem $LogsPath -Filter 'module-telemetry*.json' -File -ErrorAction SilentlyContinue | Sort-Object LastWriteTime\r\n        if (-not $files) { Write-Warning 'No telemetry files present.'; return }\r\n        $entries = foreach ($f in $files) {\r\n            Get-Content $f -ErrorAction SilentlyContinue | ForEach-Object {\r\n                if ($_ -match '^\\s*{') { try { $_ | ConvertFrom-Json -ErrorAction Stop } catch { Write-Error (\"Malformed telemetry JSON: {0}\" -f $_) }\r\n                }\r\n            }\r\n        }\r\n        if (-not $entries) { Write-Warning 'Telemetry empty.'; return }\r\n        $ordered = $entries | Sort-Object { $_.Timestamp }\r\n        if ($Last -gt 0) { $tail = $ordered | Select-Object -Last $Last } else { $tail = $null }\r\n        $byModule = $ordered | Group-Object Module | ForEach-Object { [pscustomobject]@{ Module = $_.Name; Count = $_.Count } }\r\n        [pscustomobject]@{\r\n            Total   = $ordered.Count\r\n            Modules = $byModule\r\n            Entries = $tail\r\n        }\r\n    } catch {\r\n        Write-Warning \"Failed to read telemetry: $($_.Exception.Message)\"\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTelemetryPurge {\r\n    <#\r\n    .SYNOPSIS\r\n        Purge old rotated telemetry archives.\r\n    .DESCRIPTION\r\n        Deletes module-telemetry-*.json files older than a retention window (default 14 days). The active\r\n        module-telemetry.json (current writer) is never deleted.\r\n    .PARAMETER RetentionDays\r\n        Number of days to retain archived telemetry files.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [int]$RetentionDays = 14,\r\n        [string]$LogsPath\r\n    )\r\n    if (-not $LogsPath) { $LogsPath = Join-Path (Get-BusBuddyProjectRoot) 'logs' }\r\n    if (-not (Test-Path $LogsPath)) { Write-Warning 'Logs directory not found.'; return }\r\n    $cutoff = (Get-Date).AddDays(-$RetentionDays)\r\n    $archives = Get-ChildItem $LogsPath -Filter 'module-telemetry-*.json' -File -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt $cutoff }\r\n    foreach ($a in $archives) {\r\n        if ($PSCmdlet.ShouldProcess($a.FullName,'Remove old telemetry')) {\r\n            try { Remove-Item $a.FullName -Force } catch { Write-Warning \"Failed to remove $($a.Name): $($_.Exception.Message)\" }\r\n        }\r\n    }\r\n}\r\n\r\nSet-Alias -Name bbTelemetry -Value Get-BusBuddyTelemetrySummary -ErrorAction SilentlyContinue\r\nSet-Alias -Name bbTelemetryPurge -Value Invoke-BusBuddyTelemetryPurge -ErrorAction SilentlyContinue\r\n#endregion Telemetry Utilities\r\n\r\n#region Compliance Review (PowerShell 7.5.2)\r\nfunction Get-BusBuddyPS75Compliance {\r\n    <#\r\n    .SYNOPSIS\r\n        Review the PowerShell environment and flag 7.5.2 compliance issues.\r\n    .DESCRIPTION\r\n        Scans PowerShell/* for *.psm1, *.psd1, *.ps1 and reports:\r\n        - Missing '#requires -Version 7.5' header\r\n        - Write-Host usage (use Write-Information/Write-Output per Microsoft guidance)\r\n        - Global alias pollution (-Scope Global)\r\n        - Potential missing Export-ModuleMember in .psm1\r\n        Optionally disables only obvious temp/backup artifacts by renaming to .disabled.\r\n    .PARAMETER Root\r\n        Root path to scan. Defaults to project root / PowerShell.\r\n    .PARAMETER DisableObviousArtifacts\r\n        If set, renames temp/backup artifacts (*.bak|*.old|*.tmp|*.backup*) to *.disabled (no deletion).\r\n    .OUTPUTS\r\n        PSCustomObject[] with Path, Kind, Lines, Issues, Recommendation\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n        https://learn.microsoft.com/powershell/scripting/developer/cmdlet/cmdlet-overview#confirming-impactful-operations\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([pscustomobject[]])]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell'),\r\n        [switch]$DisableObviousArtifacts\r\n    )\r\n\r\n    if (-not (Test-Path $Root)) {\r\n        Write-Warning \"Root not found: $Root\"\r\n        return @()\r\n    }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -File -Include *.psm1, *.psd1, *.ps1 -ErrorAction SilentlyContinue\r\n    $results = [System.Collections.Generic.List[object]]::new()\r\n\r\n    foreach ($f in $files) {\r\n        $kind = $f.Extension.ToLowerInvariant()\r\n        $text = try { Get-Content $f.FullName -Raw -ErrorAction Stop } catch { '' }\r\n        $lines = if ($text) { ($text -split \"`r?`n\").Length } else { 0 }\r\n\r\n        $issues = [System.Collections.Generic.List[string]]::new()\r\n        $recommend = [System.Collections.Generic.List[string]]::new()\r\n\r\n        # Check '#requires -Version 7.5' presence near the top\r\n        $top512 = ($text -split \"`r?`n\") | Select-Object -First 25\r\n        if ($top512 -and ($top512 -notmatch '^\\s*#requires\\s+-Version\\s+7\\.5')) {\r\n            $issues.Add(\"Missing '#requires -Version 7.5' header\")\r\n            $recommend.Add(\"Add: #requires -Version 7.5\")\r\n        }\r\n\r\n        # Detect Write-Host (discouraged per Microsoft output guidance)\r\n        $writeHostCount = if ($text) { ([regex]::Matches($text, '(?im)^\\s*Write-Host\\b')).Count } else { 0 }\r\n        if ($writeHostCount -gt 0) {\r\n            $issues.Add(\"Uses Write-Host ($writeHostCount)\")\r\n            $recommend.Add(\"Replace with Write-Information/Write-Output/Write-Verbose as appropriate\")\r\n        }\r\n\r\n        # Detect Set-Alias with -Scope Global (pollutes session)\r\n        $globalAliases = if ($text) { ([regex]::Matches($text, '(?im)Set-Alias\\s+.*-Scope\\s+Global')).Count } else { 0 }\r\n        if ($globalAliases -gt 0) {\r\n            $issues.Add(\"Defines $globalAliases global alias(es)\")\r\n            $recommend.Add(\"Remove -Scope Global; export aliases via module manifest/Export-ModuleMember\")\r\n        }\r\n\r\n        # .psm1: check for Export-ModuleMember presence\r\n        if ($kind -eq '.psm1') {\r\n            if ($text -notmatch '(?im)^\\s*Export-ModuleMember\\b') {\r\n                $issues.Add(\"No Export-ModuleMember found\")\r\n                $recommend.Add(\"Export public functions explicitly\")\r\n            }\r\n        }\r\n\r\n        # Flag obvious temp/backup artifacts\r\n        $isArtifact = $false\r\n        if ($f.Name -match '(?i)\\.(bak|backup|old|tmp)$' -or $f.Name -match '(?i)_backup|_temp|_tmp') {\r\n            $isArtifact = $true\r\n            $issues.Add(\"Temporary/backup artifact\")\r\n            $recommend.Add(\"Rename to .disabled or remove from repo\")\r\n            if ($DisableObviousArtifacts) {\r\n                $newName = \"$($f.FullName).disabled\"\r\n                if ($PSCmdlet.ShouldProcess($f.FullName, \"Rename to $newName\")) {\r\n                    try { Rename-Item -Path $f.FullName -NewName ($f.Name + '.disabled') -Force } catch { Write-Warning \"Rename failed: $($_.Exception.Message)\" }\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summarize\r\n        $results.Add([pscustomobject]@{\r\n            Path          = $f.FullName\r\n            Kind          = $kind.TrimStart('.').ToUpper()\r\n            Lines         = $lines\r\n            Issues        = [string[]]$issues\r\n            Recommendation= [string[]]$recommend\r\n            IsArtifact    = $isArtifact\r\n        })\r\n    }\r\n\r\n    # Sort by severity (artifacts and write-host first), then missing requires\r\n    $ordered = $results | Sort-Object {\r\n        $score = 0\r\n        if ($_.IsArtifact) { $score -= 100 }\r\n        if ($_.Issues -match 'Write-Host') { $score -= 50 }\r\n        if ($_.Issues -match 'Missing .*#requires') { $score -= 25 }\r\n        $score\r\n    }\r\n    return $ordered\r\n}\r\nSet-Alias -Name bb-ps-review -Value Get-BusBuddyPS75Compliance -ErrorAction SilentlyContinue\r\n#endregion Compliance Review (PowerShell 7.5.2)\r\n\r\n#region Pester Helper\r\nfunction Invoke-BusBuddyPester {\r\n    <#\r\n    .SYNOPSIS\r\n        Run Pester tests for BusBuddy PowerShell modules.\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Path,\r\n        [switch]$PassThru\r\n    )\r\n    # Copilot: Validate suggestions - ensure cmdlet exists before use (Get-Command).\r\n    # Docs: https://learn.microsoft.com/powershell/module/microsoft.powershell.core/get-command\r\n    if (-not (Get-Command Invoke-Pester -ErrorAction SilentlyContinue)) {\r\n        Write-Warning 'Pester not available. Install with: Install-Module Pester -Scope CurrentUser'\r\n        return\r\n    }\r\n    if (-not $Path) { $Path = Join-Path (Get-BusBuddyProjectRoot) 'PowerShell/Tests' }\r\n    if (-not (Test-Path $Path)) { Write-Warning \"Tests path not found: $Path\"; return }\r\n    Write-Information \"?? Running Pester tests in $Path\" -InformationAction Continue\r\n    try {\r\n        $config = New-PesterConfiguration\r\n        $config.Run.Path = $Path\r\n        $config.Run.PassThru = $true\r\n        $config.TestResult.Enabled = $true\r\n        $config.Output.Verbosity = 'Normal'\r\n        $result = Invoke-Pester -Configuration $config\r\n        if ($PassThru) { return $result } else { return $result.Result }\r\n    } catch { Write-Error \"Pester execution failed: $($_.Exception.Message)\" }\r\n}\r\n# Scope aliases to the module to avoid polluting global session\r\nSet-Alias -Name bbPester -Value Invoke-BusBuddyPester -ErrorAction SilentlyContinue\r\n#endregion Pester Helper\r\n\r\n#endregion\r\n\r\n#region Script Lint: Detect invalid ErrorAction pipeline misuse\r\nfunction Test-BusBuddyErrorActionPipeline {\r\n    <#\r\n    .SYNOPSIS\r\n        Scans PowerShell scripts for the invalid pattern that causes \"The variable '$_' cannot be retrieved because it has not been set\".\r\n    .DESCRIPTION\r\n        Looks for statements like \"ErrorAction SilentlyContinue | Select-Object Name, Definition\" or attempts to pipe\r\n        preference variables (e.g., $ErrorActionPreference) directly into Select-Object. Reports offending files/lines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to project PowerShell folder.\r\n    .OUTPUTS\r\n        PSCustomObject with File, LineNumber, Line\r\n    .LINK\r\n        https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()] param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n    if (-not (Test-Path $Root)) { Write-Warning \"Root not found: $Root\"; return @() }\r\n\r\n    $files = Get-ChildItem -Path $Root -Recurse -Include *.ps1,*.psm1,*.psd1 -File -ErrorAction SilentlyContinue\r\n\r\n    #region bb* Aliases and Refresh Helper\r\n    function Invoke-BusBuddyRefresh {\r\n        <#\r\n        .SYNOPSIS\r\n            Reload BusBuddy module/profile wiring for the current session.\r\n        .DESCRIPTION\r\n            Calls the repo profile loader to reinitialize bb* aliases and module wiring.\r\n            Docs: https://learn.microsoft.com/powershell/scripting/developer/module/writing-a-windows-powershell-module\r\n        #>\r\n        [CmdletBinding(SupportsShouldProcess=$true,ConfirmImpact='Low')]\r\n        param()\r\n        try {\r\n            $projectRoot = Get-BusBuddyProjectRoot\r\n            $loader = Join-Path $projectRoot 'PowerShell/Profiles/Import-BusBuddyModule.ps1'\r\n            if (-not (Test-Path $loader)) { Write-Warning \"Profile loader not found: $loader\"; return }\r\n            if ($PSCmdlet.ShouldProcess($loader,'Invoke profile/module loader')) { & $loader }\r\n        } catch { Write-Warning (\"bbRefresh failed: {0}\" -f $_.Exception.Message) }\r\n    }\r\n\r\n    # Export bb* aliases within the module scope (no -Scope Global)\r\n    Set-Alias -Name bbHealth        -Value Test-BusBuddyHealth          -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbBuild         -Value Invoke-BusBuddyBuild         -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRun           -Value Invoke-BusBuddyRun           -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbMvpCheck      -Value Test-BusBuddyMVPReadiness    -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbAntiRegression-Value Invoke-BusBuddyAntiRegression-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbXamlValidate  -Value Invoke-BusBuddyXamlValidation-ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbDevSession    -Value Start-BusBuddyDevSession     -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbRefresh       -Value Invoke-BusBuddyRefresh       -ErrorAction SilentlyContinue\r\n    Set-Alias -Name bbCommands      -Value Get-BusBuddyCommand          -ErrorAction SilentlyContinue\r\n    # Note: bbTest, bbTestWatch, bbTestReport are defined in BusBuddy.Testing module\r\n    #endregion bb* Aliases and Refresh Helper\r\n    $findings = @()\r\n\r\n    foreach ($f in $files) {\r\n        try {\r\n            $i = 0\r\n            Get-Content -Path $f.FullName -ErrorAction Stop | ForEach-Object {\r\n                $i++\r\n                $line = $_\r\n                # Flag known-bad constructs\r\n                $bad1 = $line -match '(?i)\\bErrorAction\\s+SilentlyContinue\\s*\\|\\s*Select-Object'\r\n                $bad2 = $line -match '(?i)\\$ErrorActionPreference\\s*\\|\\s*Select-Object'\r\n                if ($bad1 -or $bad2) {\r\n                    $findings += [pscustomobject]@{ File = $f.FullName; LineNumber = $i; Line = $line.Trim() }\r\n                }\r\n            }\r\n        } catch { Write-Error (\"Failed scanning file {0}: {1}\" -f $f.FullName, $_.Exception.Message) }\r\n    }\r\n    return $findings\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea -Value Test-BusBuddyErrorActionPipeline -ErrorAction SilentlyContinue\r\n# Wrapper to safely run the validation and print a summary without relying on external variables like $r\r\nfunction Invoke-BusBuddyErrorActionAudit {\r\n    <#\r\n    .SYNOPSIS\r\n        Runs the ErrorAction pipeline validator and prints a concise summary.\r\n    .DESCRIPTION\r\n    Convenience wrapper that captures results from Test-BusBuddyErrorActionPipeline, writes a count,\r\n        and formats a table when findings exist-avoiding patterns that depend on a pre-set variable (e.g., $r).\r\n        Uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER Root\r\n        Root folder to scan. Defaults to the project's PowerShell folder.\r\n    .OUTPUTS\r\n    Same objects as Test-BusBuddyErrorActionPipeline, passed through after printing.\r\n    .LINK\r\n        Microsoft PowerShell Output Streams - https://learn.microsoft.com/powershell/scripting/learn/deep-dives/everything-about-output-streams\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$Root = (Join-Path (Get-BusBuddyProjectRoot) 'PowerShell')\r\n    )\r\n\r\n    try {\r\n    $results = Test-BusBuddyErrorActionPipeline -Root $Root\r\n    }\r\n    catch {\r\n        Write-Error (\"Validation failed: {0}\" -f $_.Exception.Message)\r\n        return @()\r\n    }\r\n\r\n    $count = @($results).Count\r\n    Write-Output (\"Findings: {0}\" -f $count)\r\n    if ($count -gt 0) {\r\n        $results |\r\n            Select-Object File, LineNumber, Line |\r\n            Format-Table -AutoSize |\r\n            Out-String |\r\n            Write-Output\r\n    }\r\n\r\n    return $results\r\n}\r\n\r\nSet-Alias -Name bb-ps-validate-ea-run -Value Invoke-BusBuddyErrorActionAudit -ErrorAction SilentlyContinue\r\n#endregion Script Lint\r\n\r\n#region Log Summary Utilities\r\nfunction Get-BusBuddyLogSummary {\r\n    <#\r\n    .SYNOPSIS\r\n        Loads BusBuddy.WPF utilities and prints a concise log summary.\r\n    .DESCRIPTION\r\n        Uses BusBuddy.WPF.Utilities.LogLifecycleManager to read logs and output a category count table.\r\n        Avoids relying on pre-set variables like $r and uses Write-Information/Write-Output per Microsoft guidelines.\r\n    .PARAMETER LogsDir\r\n        Logs directory path. Defaults to \"logs\" under the project root.\r\n    .PARAMETER PassThru\r\n        When specified, also returns the summary object.\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [string]$LogsDir = (Join-Path (Get-BusBuddyProjectRoot) 'logs'),\r\n        [switch]$PassThru\r\n    )\r\n\r\n    try {\r\n        # Copilot: Get log files and count them - ensure logs folder exists before reading.\r\n        # Docs (I/O): https://learn.microsoft.com/powershell/module/microsoft.powershell.management/new-item\r\n        if (-not (Test-Path -LiteralPath $LogsDir)) { New-Item -ItemType Directory -Path $LogsDir -Force | Out-Null }\r\n\r\n        $manager = New-Object BusBuddy.WPF.Utilities.LogLifecycleManager($LogsDir)\r\n        $summary = $manager.GetLogSummary()\r\n\r\n        # Copilot: Print a concise table - use Write-Output for pipeline-safe text.\r\n        $count = [int]($summary.TotalFiles)\r\n        Write-Output (\"Findings: {0}\" -f $count)\r\n        if ($count -gt 0) {\r\n            $summary.Categories.GetEnumerator() |\r\n                Select-Object @{n='Name';e={$_.Key}}, @{n='FileCount';e={$_.Value.FileCount}} |\r\n                Format-Table -AutoSize |\r\n                Out-String |\r\n                Write-Output\r\n        }\r\n\r\n        if ($PassThru) { return $summary }\r\n    }\r\n    catch {\r\n        Write-Error (\"Log summary failed: {0}\" -f $_.Exception.Message)\r\n    }\r\n}\r\n\r\ntry { Set-Alias -Name bb-logs-summary -Value Get-BusBuddyLogSummary -Force } catch { Write-Warning (\"Failed to set alias bb-logs-summary: {0}\" -f $_.Exception.Message) }\r\n#endregion Log Summary Utilities\r\n\r\n#region Core Functions\r\n\r\nfunction Get-BusBuddyProjectRoot {\r\n    <#\r\n    .SYNOPSIS\r\n        Get the root directory of the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    $currentPath = $PWD.Path\r\n\r\n    while ($currentPath -and $currentPath -ne [System.IO.Path]::GetPathRoot($currentPath)) {\r\n        if ((Test-Path (Join-Path $currentPath \"BusBuddy.sln\")) -and\r\n            (Test-Path (Join-Path $currentPath \"Directory.Build.props\"))) {\r\n            return $currentPath\r\n        }\r\n        $currentPath = Split-Path $currentPath -Parent\r\n    }\r\n\r\n    return $PWD.Path\r\n}\r\n\r\nfunction Write-BusBuddyStatus {\r\n    <#\r\n    .SYNOPSIS\r\n        Write status message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted status messages following Microsoft PowerShell Development Guidelines.\r\n        Uses Write-Information with proper ANSI colors and structured output for enhanced readability.\r\n\r\n    .PARAMETER Message\r\n        The status message to display. Can be empty for blank lines.\r\n\r\n    .PARAMETER Type\r\n        The type of status message (Info, Success, Warning, Error)\r\n\r\n    .PARAMETER Status\r\n        Legacy alias for Type parameter to maintain backward compatibility\r\n\r\n    .PARAMETER NoEmoji\r\n        Suppress the BusBuddy emoji prefix for cleaner output\r\n\r\n    .PARAMETER Indent\r\n        Number of spaces to indent the message (default: 0)\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Build completed\" -Type Success\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Warning detected\" -Type Warning\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"\" -Type Info  # Creates blank line\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyStatus \"Detailed info\" -Type Info -Indent 2\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory=$false, Position=0, ValueFromPipeline=$true)]\r\n        [AllowEmptyString()]\r\n        [AllowNull()]\r\n        [string]$Message = \"\",\r\n\r\n        [Parameter(ParameterSetName='Type')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Type = 'Info',\r\n\r\n        [Parameter(ParameterSetName='Status')]\r\n        [ValidateSet('Info', 'Success', 'Warning', 'Error', 'Debug')]\r\n        [string]$Status = 'Info',\r\n\r\n        [Parameter()]\r\n        [switch]$NoEmoji,\r\n\r\n        [Parameter()]\r\n        [int]$Indent = 0\r\n    )\r\n\r\n    begin {\r\n        # Use Status parameter if provided, otherwise use Type\r\n        $statusType = if ($PSCmdlet.ParameterSetName -eq 'Status') { $Status } else { $Type }\r\n\r\n        # Handle null or empty messages properly - allow empty strings for spacing\r\n        if ($null -eq $Message) {\r\n            $Message = \"\"\r\n        }\r\n\r\n        # Create indentation\r\n        $indentString = \" \" * $Indent\r\n    }\r\n\r\n    process {\r\n        try {\r\n            # Handle empty messages for spacing\r\n            if ([string]::IsNullOrWhiteSpace($Message)) {\r\n                Write-Information \" \" -InformationAction Continue\r\n                return\r\n            }\r\n\r\n            # Enhanced formatting with ANSI colors and icons\r\n            $icon = if ($NoEmoji) { \"\" } else {\r\n                switch ($statusType) {\r\n                    'Info'    { \"??\" }\r\n                    'Success' { \"?\" }\r\n                    'Warning' { \"?? \" }\r\n                    'Error'   { \"?\" }\r\n                    'Debug'   { \"??\" }\r\n                    default   { \"??\" }\r\n                }\r\n            }\r\n\r\n            $formattedMessage = \"$indentString$icon $Message\"\r\n\r\n            # Use appropriate PowerShell 7.5.2 output streams\r\n            switch ($statusType) {\r\n                'Info' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Success' {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n                'Warning' {\r\n                    Write-Warning $formattedMessage\r\n                }\r\n                'Error' {\r\n                    Write-Error $formattedMessage\r\n                }\r\n                'Debug' {\r\n                    Write-Debug $formattedMessage\r\n                }\r\n                default {\r\n                    Write-Information $formattedMessage -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n        catch {\r\n            Write-Error \"Error in Write-BusBuddyStatus: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\nfunction Write-BusBuddyError {\r\n    <#\r\n    .SYNOPSIS\r\n        Write error message with BusBuddy formatting using PowerShell 7.5.2 best practices\r\n\r\n    .DESCRIPTION\r\n        Displays formatted error messages with optional exception details.\r\n        Uses structured error output for better diagnostics and actionable information.\r\n\r\n    .PARAMETER Message\r\n        The primary error message to display\r\n\r\n    .PARAMETER Exception\r\n        Optional exception object for detailed error information\r\n\r\n    .PARAMETER Context\r\n        Optional context information about where the error occurred\r\n\r\n    .PARAMETER ShowStackTrace\r\n        Include stack trace information for debugging\r\n\r\n    .PARAMETER Suggestions\r\n        Array of suggested actions to resolve the error\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Build failed\" -Exception $_.Exception\r\n\r\n    .EXAMPLE\r\n        Write-BusBuddyError \"Database connection failed\" -Context \"Startup\" -Suggestions @(\"Check connection string\", \"Verify database is running\")\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Message,\r\n\r\n        # Accept either System.Exception or ErrorRecord (coerced below)\r\n        [Parameter()]\r\n        [object]$Exception,\r\n\r\n        [Parameter()]\r\n        [string]$Context,\r\n\r\n        [Parameter()]\r\n        [switch]$ShowStackTrace,\r\n\r\n        [Parameter()]\r\n        [string[]]$Suggestions\r\n    )\r\n\r\n    process {\r\n        try {\r\n            # Primary error message\r\n            Write-Error \"? $Message\"\r\n\r\n            # Additional context information using Write-Information\r\n            if ($Context) {\r\n                Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n            }\r\n\r\n            # Exception details (coerce ErrorRecord -> Exception safely)\r\n            if ($Exception) {\r\n                $exObj = $null\r\n                if ($Exception -is [System.Management.Automation.ErrorRecord]) {\r\n                    $exObj = $Exception.Exception\r\n                } elseif ($Exception -is [System.Exception]) {\r\n                    $exObj = $Exception\r\n                } else {\r\n                    try { $exObj = [System.Exception]::new([string]$Exception) } catch { $exObj = $null }\r\n                }\r\n\r\n                if ($exObj) {\r\n                    Write-Information \"?? Exception: $($exObj.Message)\" -InformationAction Continue\r\n\r\n                    if ($ShowStackTrace -and $exObj.StackTrace) {\r\n                        Write-Information \"?? Stack Trace:\" -InformationAction Continue\r\n                        $exObj.StackTrace.Split(\"`n\") | ForEach-Object {\r\n                            Write-Information \"   $_\" -InformationAction Continue\r\n                        }\r\n                    }\r\n\r\n                    # Inner exception details\r\n                    $innerEx = $exObj.InnerException\r\n                    $level = 1\r\n                    while ($innerEx -and $level -le 3) {\r\n                        Write-Information \"?? Inner Exception ($level): $($innerEx.Message)\" -InformationAction Continue\r\n                        $innerEx = $innerEx.InnerException\r\n                        $level++\r\n                    }\r\n                }\r\n            }\r\n\r\n            # Suggestions for resolution\r\n            if ($Suggestions -and $Suggestions.Length -gt 0) {\r\n                Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n                $Suggestions | ForEach-Object {\r\n                    Write-Information \"    $_\" -InformationAction Continue\r\n                }\r\n            }\r\n\r\n            # Timestamp for debugging\r\n            $timestamp = Get-Date -Format \"yyyy-MM-dd HH:mm:ss.fff\"\r\n            Write-Information \"? Timestamp: $timestamp\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            # Fallback error handling\r\n            Write-Error \"Critical error in Write-BusBuddyError: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Mantra ID (Context Correlation)\r\n<#\r\n.SYNOPSIS\r\n  Manage a session-scoped \"Mantra\" ID used to correlate BusBuddy operations.\r\n.DESCRIPTION\r\n  Loads from environment variable BUSBUDDY_MANTRA_ID, then optional .mantra file at project root,\r\n  else generates a short GUID fragment. Exposed via Get-BusBuddyMantraId. Reset-BusBuddyMantraId\r\n  can rotate it. Pattern aligns with Microsoft docs on environment variables and advanced functions\r\n  (about_Environment_Variables, about_Functions_Advanced, about_Prompts).\r\n#>\r\ntry {\r\n    if (-not $script:MantraId) {\r\n        $script:MantraId = $env:BUSBUDDY_MANTRA_ID\r\n        if (-not $script:MantraId) {\r\n            $rootForMantra = try { Get-BusBuddyProjectRoot } catch { $null }\r\n            if ($rootForMantra) {\r\n                $mantraFile = Join-Path $rootForMantra '.mantra'\r\n                if (Test-Path $mantraFile) {\r\n                    $script:MantraId = (Get-Content $mantraFile -Raw).Trim()\r\n                }\r\n            }\r\n        }\r\n        if (-not $script:MantraId) {\r\n            $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n            Write-Information \"Generated transient Mantra ID: $script:MantraId\" -InformationAction Continue\r\n        }\r\n    }\r\n} catch {\r\n    Write-Information \"(Non-fatal) Mantra initialization issue: $($_.Exception.Message)\" -InformationAction Continue\r\n}\r\n\r\nfunction Get-BusBuddyMantraId {\r\n    [CmdletBinding()] [OutputType([string])] param() return $script:MantraId\r\n}\r\n\r\nfunction Reset-BusBuddyMantraId {\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')] param()\r\n    if ($PSCmdlet.ShouldProcess('Session','Rotate Mantra ID')) {\r\n        $script:MantraId = ([guid]::NewGuid().ToString('N').Substring(0,8))\r\n        Write-Information \"New Mantra ID: $script:MantraId\" -InformationAction Continue\r\n    }\r\n    return $script:MantraId\r\n}\r\n\r\n#endregion\r\n\r\n#region Build Functions\r\n\r\nfunction Invoke-BusBuddyBuild {\r\n    <#\r\n    .SYNOPSIS\r\n        Build the BusBuddy solution\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param(\r\n        [switch]$Clean\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $issues = @()\r\n\r\n    if (Get-Command Test-BusBuddyAzureSql -ErrorAction SilentlyContinue) {\r\n        try {\r\n            $sqlOk = Test-BusBuddyAzureSql\r\n            if ($sqlOk) { Write-BusBuddyStatus \"Azure SQL connectivity: OK\" -Type Success } else { $issues += 'Azure SQL connectivity failed'; Write-BusBuddyStatus \"Azure SQL connectivity: FAILED\" -Type Warning }\r\n        } catch { $issues += 'Azure SQL connectivity check error'; Write-BusBuddyStatus 'Azure SQL connectivity check error' -Type Warning }\r\n    }\r\n    Push-Location $projectRoot\r\n    try {\r\n        if ($Clean) {\r\n            Write-BusBuddyStatus \"Cleaning solution...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n                dotnet clean BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Building BusBuddy solution...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet build\")) {\r\n            # Removed dependency on missing Invoke-BusBuddyWithExceptionCapture\r\n            $buildResult = & dotnet build BusBuddy.sln --verbosity minimal 2>&1\r\n\r\n            $buildLines = $buildResult | Where-Object {\r\n                $_ -match \"-> |succeeded|failed|error|warning|Error|Warning|Time Elapsed\" -and\r\n                $_ -notmatch \"CompilerServer|analyzer|reference:|X.509 certificate|Assets file|NuGet Config|Feeds used\"\r\n            }\r\n            if ($buildLines) {\r\n                Write-Information \"?? Build Output:\" -InformationAction Continue\r\n                $buildLines | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n            }\r\n\r\n            if ($LASTEXITCODE -eq 0) {\r\n                Write-BusBuddyStatus \"Build completed successfully\" -Type Success\r\n            } else {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Build error occurred\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRun {\r\n    <#\r\n    .SYNOPSIS\r\n        Run the BusBuddy application from an STA thread to avoid exit code 1.\r\n    .DESCRIPTION\r\n        Launches the built WPF executable using an STA runspace as required by WPF's threading model.\r\n        References:\r\n        - WPF Threading Model - STA requirement:\r\n          https://learn.microsoft.com/dotnet/desktop/wpf/advanced/threading-model\r\n        - RunspaceFactory.CreateRunspace / ApartmentState:\r\n          https://learn.microsoft.com/dotnet/api/system.management.automation.runspaces.runspacefactory.createrunspace\r\n          https://learn.microsoft.com/dotnet/api/system.threading.apartmentstate\r\n        - powershell.exe -STA parameter (for callers):\r\n          https://learn.microsoft.com/powershell/scripting/windows-powershell/starting-windows-powershell#parameters\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$WaitReady,\r\n        [int]$WaitSeconds = 30\r\n    )\r\n\r\n    # Optional: warn about Syncfusion license presence\r\n    try {\r\n        if ([string]::IsNullOrWhiteSpace($env:SYNCFUSION_LICENSE_KEY)) {\r\n            Write-BusBuddyStatus \"SYNCFUSION_LICENSE_KEY not set - app may show trial watermarks\" -Type Warning\r\n        }\r\n    } catch { Write-Warning (\"Failed to access SYNCFUSION_LICENSE_KEY: {0}\" -f $_.Exception.Message) }\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $wpfDir      = Join-Path $projectRoot 'BusBuddy.WPF'\r\n    $outDir      = Join-Path $wpfDir 'bin\\Debug\\net9.0-windows'\r\n\r\n    Push-Location $projectRoot\r\n    try {\r\n        # Locate the built exe (support both assembly names)\r\n        $exeCandidates = @(\r\n            (Join-Path $outDir 'BusBuddy.exe'),\r\n            (Join-Path $outDir 'BusBuddy.WPF.exe')\r\n        )\r\n        $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n\r\n        # Build if missing\r\n        if (-not $exePath) {\r\n            Write-BusBuddyStatus \"Building BusBuddy.WPF (Debug)...\" -Type Info\r\n            if ($PSCmdlet.ShouldProcess(\"BusBuddy.WPF/BusBuddy.WPF.csproj\", \"dotnet build -c Debug\")) {\r\n                & dotnet build \"BusBuddy.WPF/BusBuddy.WPF.csproj\" -c Debug --verbosity minimal 2>&1 | Out-Null\r\n            }\r\n            if ($LASTEXITCODE -ne 0) {\r\n                Write-BusBuddyError \"Build failed with exit code $LASTEXITCODE\"\r\n                return\r\n            }\r\n            $exePath = $exeCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1\r\n        }\r\n\r\n        if (-not $exePath) {\r\n            Write-BusBuddyError \"WPF executable not found after build - expected under: $outDir\"\r\n            return\r\n        }\r\n\r\n        Write-BusBuddyStatus \"Starting BusBuddy (STA)...\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess($exePath, \"Start-Process (STA runspace)\")) {\r\n            # Create an STA runspace and launch the GUI process inside it.\r\n            # Docs: RunspaceFactory.CreateRunspace / ApartmentState - see function header.\r\n            $rs = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()\r\n            $rs.ApartmentState = [System.Threading.ApartmentState]::STA\r\n            $rs.Open()\r\n\r\n            $ps = [System.Management.Automation.PowerShell]::Create().AddScript({\r\n                param($FilePath, $WorkingDir)\r\n                Start-Process -FilePath $FilePath -WorkingDirectory $WorkingDir\r\n            }).AddArgument($exePath).AddArgument($wpfDir)\r\n\r\n            $ps.Runspace = $rs\r\n            try {\r\n                $null = $ps.Invoke()\r\n            } finally {\r\n                $ps.Dispose()\r\n                $rs.Close()\r\n                $rs.Dispose()\r\n            }\r\n        }\r\n\r\n        Write-BusBuddyStatus \"BusBuddy launch command issued (process started)\" -Type Success\r\n\r\n        if ($WaitReady) {\r\n            # Wait for exact process name readiness up to WaitSeconds\r\n            $deadline = (Get-Date).AddSeconds($WaitSeconds)\r\n            $procName = 'BusBuddy.WPF'\r\n            $started = $false\r\n            do {\r\n                Start-Sleep -Milliseconds 300\r\n                $p = Get-Process -Name $procName -ErrorAction SilentlyContinue | Select-Object -First 1\r\n                if ($p) { $started = $true; break }\r\n            } while ((Get-Date) -lt $deadline)\r\n\r\n            if ($started) {\r\n                Write-BusBuddyStatus \"Process $procName detected (PID=$($p.Id))\" -Type Success\r\n            } else {\r\n                Write-BusBuddyStatus \"Process $procName not detected within ${WaitSeconds}s - possible startup failure\" -Type Warning\r\n                # Attempt to show last 60 lines of log for quick diagnostics\r\n                try {\r\n                    $logsDir = Join-Path $projectRoot 'BusBuddy.WPF\\bin\\Debug\\net9.0-windows\\logs'\r\n                    $latest = Get-ChildItem -Path $logsDir -Filter 'busbuddy-*.log' -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1\r\n                    if ($latest) {\r\n                        Write-Information \"?? Last 60 log lines from $($latest.Name):\" -InformationAction Continue\r\n                        Get-Content -Path $latest.FullName -Tail 60 | ForEach-Object { Write-Information \"   $_\" -InformationAction Continue }\r\n                    } else {\r\n                        Write-Information \"No log files found under $logsDir\" -InformationAction Continue\r\n                    }\r\n                } catch { Write-Warning \"Failed reading logs: $($_.Exception.Message)\" }\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to start application\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRunSta {\r\n    <#\r\n    .SYNOPSIS\r\n        Launch BusBuddy ensuring an STA-hosted PowerShell shell spawns the app.\r\n    .DESCRIPTION\r\n        WPF itself starts on an STA thread via Program.Main [STAThread], but this provides an\r\n        STA-hosted pwsh wrapper for environments sensitive to MTA shells. Uses Start-Process so\r\n        the main console isn't blocked.\r\n        Docs: Windows PowerShell/PowerShell on Windows supports -STA switch for single-threaded apartment.\r\n    .PARAMETER Wait\r\n        Wait for the child shell to exit before returning.\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true)]\r\n    param(\r\n        [switch]$Wait\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $pwsh = (Get-Command pwsh -ErrorAction SilentlyContinue)?.Source\r\n    if (-not $pwsh) { $pwsh = \"pwsh.exe\" }\r\n\r\n    $cmd = 'dotnet run --project \"BusBuddy.WPF/BusBuddy.WPF.csproj\"'\r\n    # Avoid assigning to automatic variable $args (PSAvoidAssignmentToAutomaticVariable)\r\n    $pwshArgs = @('-NoProfile','-NoLogo')\r\n    # Attempt -STA on Windows pwsh; ignore if not supported\r\n    $pwshArgs = @('-STA') + $pwshArgs + @('-Command', $cmd)\r\n\r\n    Write-BusBuddyStatus \"Launching via STA-hosted shell...\" -Type Info\r\n    if ($PSCmdlet.ShouldProcess($pwsh, \"Start-Process (STA)\")) {\r\n        $p = Start-Process -FilePath $pwsh -ArgumentList $pwshArgs -WorkingDirectory $projectRoot -PassThru\r\n    if ($Wait) { try { $p.WaitForExit() } catch { Write-Warning (\"WaitForExit failed: {0}\" -f $_.Exception.Message) } }\r\n        return $p\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyApartmentState {\r\n    <#\r\n    .SYNOPSIS\r\n        Show the current shell thread's apartment state (STA/MTA).\r\n    #>\r\n    [CmdletBinding()] param()\r\n    try {\r\n        $apt = [System.Threading.Thread]::CurrentThread.GetApartmentState()\r\n        Write-Information \"Current apartment state: $apt\" -InformationAction Continue\r\n        return $apt\r\n    } catch {\r\n        Write-Warning \"Unable to read apartment state: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTest {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy tests using Phase 4 NUnit Test Runner (deprecated .NET 9 dotnet test method)\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [ValidateSet('All', 'Unit', 'Integration', 'Validation', 'Core', 'WPF')]\r\n        [string]$TestSuite = 'All',\r\n\r\n        [switch]$SaveToFile,\r\n\r\n        [switch]$DetailedOutput\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n\r\n    try {\r\n        Write-BusBuddyStatus \"?? BusBuddy Phase 4 NUnit Test System\" -Type Info\r\n        Write-Information \"Using reliable NUnit Test Runner (deprecated unreliable .NET 9 method)\" -InformationAction Continue\r\n\r\n        # Import the BusBuddy.Testing module which provides Start-BusBuddyPhase4TestAdvanced\r\n        $testingModule = Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1\"\r\n        if (Test-Path $testingModule) {\r\n            Import-Module $testingModule -Force -ErrorAction Stop\r\n        } elseif (Test-Path (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\")) {\r\n            Import-Module (Join-Path $projectRoot \"PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psm1\") -Force -ErrorAction Stop\r\n        } else {\r\n            Write-BusBuddyError \"? BusBuddy.Testing module not found\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"BusBuddy.Testing module not found\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if (-not (Get-Command Start-BusBuddyPhase4TestAdvanced -ErrorAction SilentlyContinue)) {\r\n            Write-BusBuddyError \"? Start-BusBuddyPhase4TestAdvanced not available after module import\" -Context \"Phase 4 NUnit\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = \"Start-BusBuddyPhase4TestAdvanced not available\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        Write-Information \"?? Test Suite: $TestSuite\" -InformationAction Continue\r\n        Write-Information \"?? Executing Phase 4 NUnit (module) runner...\" -InformationAction Continue\r\n\r\n        $ok = $false\r\n        try {\r\n            $ok = Start-BusBuddyPhase4TestAdvanced -TestSuite $TestSuite -Detailed:$DetailedOutput -SaveFullOutput:$SaveToFile\r\n        } catch {\r\n            Write-BusBuddyError \"? Phase 4 NUnit execution failed\" -Exception $_ -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = -1\r\n                ErrorMessage = $_.Exception.Message\r\n                Output = \"Phase 4 NUnit module runner execution error\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n\r\n        if ($ok) {\r\n            Write-BusBuddyStatus \"? Phase 4 NUnit tests completed successfully!\" -Type Success\r\n            return @{\r\n                ExitCode = 0\r\n                PassedTests = 1\r\n                FailedTests = 0\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner completed successfully\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        } else {\r\n            Write-BusBuddyError \"? Phase 4 NUnit tests reported failures\" -Context \"Module Runner\"\r\n            return @{\r\n                ExitCode = 1\r\n                PassedTests = 0\r\n                FailedTests = 1\r\n                SkippedTests = 0\r\n                Output = \"Phase 4 NUnit Test Runner reported failures\"\r\n                Method = \"Phase4-NUnit\"\r\n            }\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Test execution error\" -Exception $_\r\n        return @{\r\n            ExitCode = -1\r\n            ErrorMessage = $_.Exception.Message\r\n            Method = \"Phase4-NUnit-Error\"\r\n        }\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyTestLegacy {\r\n    <#\r\n    .SYNOPSIS\r\n        DEPRECATED: Legacy .NET 9 dotnet test method with compatibility issues\r\n\r\n    .DESCRIPTION\r\n        This function represents the old, unreliable method of running tests using\r\n        'dotnet test' directly, which has known compatibility issues with .NET 9\r\n        and Microsoft.TestPlatform.CoreUtilities version conflicts.\r\n\r\n        USE INSTEAD: Invoke-BusBuddyTest (which now uses Phase 4 NUnit Test Runner)\r\n\r\n    .NOTES\r\n        DEPRECATED: This method is deprecated due to .NET 9 compatibility issues\r\n        REPLACEMENT: Use bbTest (Invoke-BusBuddyTest) which now uses Phase 4 NUnit\r\n        ISSUE: Microsoft.TestPlatform.CoreUtilities v15.0.0.0 vs .NET 9 conflict\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-Warning \"??  DEPRECATED METHOD CALLED\"\r\n    Write-Warning \"The legacy .NET 9 'dotnet test' method has known compatibility issues\"\r\n    Write-Warning \"USE INSTEAD: bbTest (now uses reliable Phase 4 NUnit Test Runner)\"\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"MIGRATION GUIDANCE:\" -InformationAction Continue\r\n    Write-Information \"- Replace 'Invoke-BusBuddyTestLegacy' with 'Invoke-BusBuddyTest'\" -InformationAction Continue\r\n    Write-Information \"- Use 'bbTest' command which now uses Phase 4 NUnit script\" -InformationAction Continue\r\n    Write-Information \"- Benefits: VS Code integration, enhanced logging, reliable execution\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    # Redirect to new method\r\n    Write-Information \"?? Redirecting to new Phase 4 NUnit method...\" -InformationAction Continue\r\n    return Invoke-BusBuddyTest @PSBoundParameters\r\n}\r\n\r\n# Hard deprecate legacy test helpers by forwarding to Phase 4 NUnit\r\nfunction Get-BusBuddyTestOutputDeprecated {\r\n    [CmdletBinding()] param(\r\n        [ValidateSet('All','Unit','Integration','Validation','Core','WPF')][string]$TestSuite='All'\r\n    )\r\n    Write-Warning \"Get-BusBuddyTestOutput is deprecated. Use bbTest (Phase 4 NUnit).\"\r\n    return Invoke-BusBuddyTest -TestSuite $TestSuite\r\n}\r\n\r\n\r\nfunction Invoke-BusBuddyClean {\r\n    <#\r\n    .SYNOPSIS\r\n        Clean BusBuddy build artifacts\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Medium')]\r\n    param()\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Cleaning BusBuddy artifacts...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", \"dotnet clean\")) {\r\n            dotnet clean BusBuddy.sln\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Clean completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Clean failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Clean operation error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\nfunction Invoke-BusBuddyRestore {\r\n    <#\r\n    .SYNOPSIS\r\n        Restore BusBuddy NuGet packages\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param(\r\n        [switch]$Force\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Push-Location $projectRoot\r\n    try {\r\n        Write-BusBuddyStatus \"Restoring NuGet packages...\" -Type Info\r\n        if ($PSCmdlet.ShouldProcess(\"BusBuddy.sln\", (\"dotnet restore\" + ($Force ? \" --force\" : \"\")))) {\r\n            if ($Force) {\r\n                dotnet restore BusBuddy.sln --force\r\n            } else {\r\n                dotnet restore BusBuddy.sln\r\n            }\r\n        }\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"Package restore completed successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyError \"Package restore failed with exit code $LASTEXITCODE\"\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Package restore error\" -Exception $_\r\n    }\r\n    finally {\r\n        Pop-Location\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Development Functions\r\n\r\nfunction Start-BusBuddyDevSession {\r\n    <#\r\n    .SYNOPSIS\r\n        Start a complete BusBuddy development session\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Starting BusBuddy development session...\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    Write-BusBuddyStatus \"Project root: $projectRoot\" -Type Info\r\n\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Restore')) { Invoke-BusBuddyRestore }\r\n    if ($PSCmdlet.ShouldProcess('BusBuddy.sln','Build')) { Invoke-BusBuddyBuild }\r\n    if ($PSCmdlet.ShouldProcess('Environment','HealthCheck')) { Invoke-BusBuddyHealthCheck }\r\n\r\n    Write-BusBuddyStatus \"Development session ready!\" -Type Success\r\n}\r\n\r\nfunction Invoke-BusBuddyHealthCheck {\r\n    <#\r\n    .SYNOPSIS\r\n        Perform BusBuddy system health check\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Performing BusBuddy health check...\" -Type Info\r\n\r\n    $issues = @()\r\n\r\n    try {\r\n        $dotnetVersion = dotnet --version\r\n        Write-BusBuddyStatus \".NET Version: $dotnetVersion\" -Type Info\r\n    }\r\n    catch {\r\n        $issues += \"Unable to determine .NET version\"\r\n    }\r\n\r\n    Write-BusBuddyStatus \"PowerShell Version: $($PSVersionTable.PSVersion)\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $requiredFiles = @('BusBuddy.sln', 'Directory.Build.props', 'NuGet.config')\r\n\r\n    foreach ($file in $requiredFiles) {\r\n        $filePath = Join-Path $projectRoot $file\r\n        if (Test-Path $filePath) {\r\n            Write-BusBuddyStatus \"√ Found: $file\" -Type Success\r\n        } else {\r\n            $issues += \"Missing required file: $file\"\r\n            Write-BusBuddyStatus \"? Missing: $file\" -Type Warning\r\n        }\r\n    }\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"All health checks passed!\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"Health check found $($issues.Count) issue(s):\" -Type Warning\r\n        foreach ($issue in $issues) {\r\n            Write-BusBuddyStatus \"  - $issue\" -Type Warning\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyHealth {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy health check (alias for Invoke-BusBuddyHealthCheck)\r\n    .DESCRIPTION\r\n        Performs comprehensive health check of the BusBuddy system including .NET version,\r\n        PowerShell version, and required project files.\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    # Call the main health check function\r\n    Invoke-BusBuddyHealthCheck\r\n}\r\n\r\nfunction Get-BusBuddyInfo {\r\n    <#\r\n    .SYNOPSIS\r\n        Display BusBuddy module information\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"BusBuddy PowerShell Module Information\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Name: BusBuddy\" -InformationAction Continue\r\n    Write-Information \"Version: 2.2.0\" -InformationAction Continue\r\n    Write-Information \"Author: Bus Buddy Development Team\" -InformationAction Continue\r\n    Write-Information \"PowerShell Version: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n    Write-Information \"Project Root: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-BusBuddyStatus \"Use 'Get-BusBuddyCommand' to see available commands\" -Type Info\r\n}\r\n\r\nfunction Get-BusBuddyCommand {\r\n    <#\r\n    .SYNOPSIS\r\n        List all available BusBuddy commands\r\n    #>\r\n    [CmdletBinding()]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"Available BusBuddy Commands\" -Type Info\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    Write-Information \"Core Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbBuild      - Build the BusBuddy solution\" -InformationAction Continue\r\n    Write-Information \"  bbRun        - Run the BusBuddy application\" -InformationAction Continue\r\n    Write-Information \"  bbTest       - Run BusBuddy tests\" -InformationAction Continue\r\n    Write-Information \"  bbClean      - Clean build artifacts\" -InformationAction Continue\r\n    Write-Information \"  bbRestore    - Restore NuGet packages\" -InformationAction Continue\r\n    Write-Information \"  bbHealth     - Check system health\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Development Aliases:\" -InformationAction Continue\r\n    Write-Information \"  bbDevSession - Start development session\" -InformationAction Continue\r\n    Write-Information \"  bbInfo       - Show module information\" -InformationAction Continue\r\n    Write-Information \"  bbCommands   - List all commands (this command)\" -InformationAction Continue\r\n    Write-Information \"  bbMantra     - Show session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbMantraReset- Rotate session Mantra ID\" -InformationAction Continue\r\n    Write-Information \"  bbTestFull   - Build + test with full logs\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Deprecated:\" -InformationAction Continue\r\n    Write-Information \"  MVP tooling and XAI route optimization shell commands are deprecated.\" -InformationAction Continue\r\n    Write-Information \"  Use in-app features and core commands (bbBuild, bbRun, bbTest, bbHealth).\" -InformationAction Continue\r\n\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"Functions:\" -InformationAction Continue\r\n    $functions = Get-Command -Module BusBuddy -CommandType Function | Sort-Object Name\r\n    foreach ($func in $functions) {\r\n        Write-Information \"  $($func.Name)\" -InformationAction Continue\r\n    }\r\n}\r\n#endregion\r\n\r\n#region XAML Validation Functions\r\n\r\nfunction Invoke-BusBuddyXamlValidation {\r\n    <#\r\n    .SYNOPSIS\r\n        Validate all XAML files in the BusBuddy project\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$ProjectPath = (Get-BusBuddyProjectRoot)\r\n    )\r\n\r\n    Write-BusBuddyStatus \"Starting XAML validation...\" -Type Info\r\n\r\n    $xamlPath = Join-Path $ProjectPath \"BusBuddy.WPF\"\r\n    if (-not (Test-Path $xamlPath)) {\r\n        Write-BusBuddyError \"BusBuddy.WPF directory not found at: $xamlPath\"\r\n        return\r\n    }\r\n\r\n    $xamlFiles = Get-ChildItem -Path $xamlPath -Filter \"*.xaml\" -Recurse\r\n    $validFiles = 0\r\n    $invalidFiles = 0\r\n\r\n    foreach ($file in $xamlFiles) {\r\n        Write-BusBuddyStatus \"Validating: $($file.Name)\" -Type Info\r\n\r\n        try {\r\n            $content = Get-Content $file.FullName -Raw\r\n\r\n            # Basic XAML validation\r\n            if ($content -match '<.*?>' -and $content -match 'xmlns') {\r\n                $validFiles++\r\n                Write-BusBuddyStatus \"  √ $($file.Name)\" -Type Success\r\n            } else {\r\n                $invalidFiles++\r\n                Write-BusBuddyStatus \"  ? $($file.Name) - Invalid XAML structure\" -Type Warning\r\n            }\r\n        }\r\n        catch {\r\n            $invalidFiles++\r\n            Write-BusBuddyError \"  ? $($file.Name) - Exception: $($_.Exception.Message)\"\r\n        }\r\n    }\r\n\r\n    Write-BusBuddyStatus \"XAML Validation Complete: $validFiles valid, $invalidFiles invalid\" -Type Info\r\n}\r\n\r\n#endregion\r\n\r\n#region Exception Capture Functions\r\n\r\nfunction Invoke-BusBuddyWithExceptionCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Execute a command with comprehensive exception capture and enhanced diagnostics\r\n\r\n    .DESCRIPTION\r\n        Provides detailed execution monitoring with timing, error analysis, system context,\r\n        and actionable diagnostics for BusBuddy development operations.\r\n\r\n    .PARAMETER Command\r\n        The command to execute (e.g., 'dotnet', 'pwsh', 'git')\r\n\r\n    .PARAMETER Arguments\r\n        Array of arguments to pass to the command\r\n\r\n    .PARAMETER Context\r\n        Descriptive context for the operation (used in logs and error reports)\r\n\r\n    .PARAMETER ThrowOnError\r\n        If specified, re-throws exceptions instead of capturing them\r\n\r\n    # Output is captured and summarized\r\n\r\n    .PARAMETER Timeout\r\n        Maximum execution time in seconds (default: 300)\r\n\r\n    .EXAMPLE\r\n        Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"build\", \"BusBuddy.sln\") -Context \"Solution Build\"\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter(Mandatory)]\r\n        [string]$Command,\r\n\r\n        [Parameter()]\r\n        [string[]]$Arguments = @(),\r\n\r\n        [Parameter()]\r\n        [string]$Context = \"BusBuddy Operation\",\r\n\r\n    [Parameter()]\r\n    [switch]$ThrowOnError,\r\n        [Parameter()]\r\n        [int]$Timeout = 300\r\n    )\r\n\r\n    $startTime = Get-Date\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $fullCommand = \"$Command $($Arguments -join ' ')\"\r\n\r\n    # Enhanced status reporting\r\n    Write-Information \"?? [$sessionId] Executing: $fullCommand\" -InformationAction Continue\r\n    Write-Information \"?? Context: $Context\" -InformationAction Continue\r\n    Write-Information \"??  Timeout: $Timeout seconds\" -InformationAction Continue\r\n\r\n    # System context capture\r\n    $systemContext = @{\r\n        WorkingDirectory = Get-Location\r\n        PowerShellVersion = $PSVersionTable.PSVersion\r\n        ProcessId = $PID\r\n        UserName = $env:USERNAME\r\n        MachineName = $env:COMPUTERNAME\r\n        Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n        SessionId = $sessionId\r\n    }\r\n\r\n    try {\r\n        # Execute synchronously and capture combined output\r\n        $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()\r\n        if ($Arguments.Count -gt 0) {\r\n            $result = & $Command @Arguments 2>&1\r\n        } else {\r\n            $result = & $Command 2>&1\r\n        }\r\n        $stopwatch.Stop()\r\n\r\n        $duration = $stopwatch.Elapsed\r\n        Write-Information \"? [$sessionId] Success in $($duration.TotalSeconds.ToString('F2'))s\" -InformationAction Continue\r\n\r\n        if ($result) {\r\n            $outputLines = ($result | Measure-Object -Line).Lines\r\n            Write-Information \"?? Output: $outputLines lines captured\" -InformationAction Continue\r\n            $warnings = $result | Where-Object { $_ -match \"warning|warn|WRN\" }\r\n            if ($warnings) {\r\n                Write-Warning \"??  [$sessionId] $($warnings.Count) warnings detected in output\"\r\n            }\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n        $errorDetails = $_.Exception.Message\r\n\r\n        # Enhanced error reporting with diagnostics\r\n        Write-Error \"? [$sessionId] Command failed after $($duration.TotalSeconds.ToString('F2'))s\"\r\n        Write-Information \"?? Error Details:\" -InformationAction Continue\r\n        Write-Information \"   Command: $fullCommand\" -InformationAction Continue\r\n        Write-Information \"   Context: $Context\" -InformationAction Continue\r\n        Write-Information \"   Working Dir: $($systemContext.WorkingDirectory)\" -InformationAction Continue\r\n        Write-Information \"   Error: $errorDetails\" -InformationAction Continue\r\n\r\n        # Capture additional diagnostics\r\n        $diagnostics = @{\r\n            LastExitCode = $LASTEXITCODE\r\n            ErrorRecord = $_\r\n            SystemContext = $systemContext\r\n            Duration = $duration\r\n            FullCommand = $fullCommand\r\n        }\r\n\r\n        # Check for common error patterns and provide suggestions\r\n    $suggestions = Get-BusBuddyErrorSuggestion -ErrorMessage $errorDetails -Command $Command\r\n        if ($suggestions) {\r\n            Write-Information \"?? Suggestions:\" -InformationAction Continue\r\n            $suggestions | ForEach-Object {\r\n                Write-Information \"    $_\" -InformationAction Continue\r\n            }\r\n        }\r\n\r\n        # Log to error capture file for analysis\r\n        $errorLogPath = Join-Path (Get-BusBuddyProjectRoot) \"logs\" \"command-errors.log\"\r\n        $errorEntry = @{\r\n            Timestamp = $startTime.ToString(\"yyyy-MM-dd HH:mm:ss.fff\")\r\n            SessionId = $sessionId\r\n            Command = $fullCommand\r\n            Context = $Context\r\n            Duration = $duration.TotalSeconds\r\n            Error = $errorDetails\r\n            ExitCode = $LASTEXITCODE\r\n            Diagnostics = $diagnostics\r\n        } | ConvertTo-Json -Depth 3 -Compress\r\n\r\n        try {\r\n            $errorEntry | Add-Content -Path $errorLogPath -Encoding UTF8\r\n        } catch {\r\n Write-Warning (\"Could not append to error log at {0}: {1}\" -f $errorLogPath, $_.Exception.Message)\r\n        }\r\n\r\n        if ($ThrowOnError) {\r\n            throw\r\n        }\r\n\r\n        return $null\r\n    }\r\n}\r\n\r\n# Helper function for error suggestion\r\nfunction Get-BusBuddyErrorSuggestion {\r\n    param(\r\n        [string]$ErrorMessage,\r\n        [string]$Command\r\n    )\r\n\r\n    $suggestions = @()\r\n\r\n    # Common dotnet errors\r\n    if ($Command -eq \"dotnet\") {\r\n        if ($ErrorMessage -match \"not found|could not be found\") {\r\n            $suggestions += \"Run 'dotnet restore' to restore NuGet packages\"\r\n            $suggestions += \"Check if the project file exists and is valid\"\r\n        }\r\n        if ($ErrorMessage -match \"build failed|compilation failed\") {\r\n            $suggestions += \"Run 'bb-health' to check project status\"\r\n            $suggestions += \"Check for missing dependencies or compile errors\"\r\n        }\r\n        if ($ErrorMessage -match \"unable to resolve|dependency\") {\r\n            $suggestions += \"Run 'bb-clean' then 'bb-restore' to refresh dependencies\"\r\n        }\r\n    }\r\n\r\n    # PowerShell errors\r\n    if ($ErrorMessage -match \"execution policy\") {\r\n        $suggestions += \"Run 'Set-ExecutionPolicy -Scope CurrentUser RemoteSigned'\"\r\n    }\r\n\r\n    # General timeout errors\r\n    if ($ErrorMessage -match \"timeout|timed out\") {\r\n        $suggestions += \"Increase timeout value or check for hanging processes\"\r\n        $suggestions += \"Verify network connectivity if downloading packages\"\r\n    }\r\n\r\n    return $suggestions\r\n}\r\n\r\n#endregion\r\n\r\n#region MVP Focus Functions\r\n\r\nfunction Start-BusBuddyMVP {\r\n    <#\r\n    .SYNOPSIS\r\n        Keep development focused on MVP essentials - pushes back on scope creep\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [Parameter()]\r\n        [string]$FeatureIdea,\r\n\r\n        [Parameter()]\r\n        [switch]$JustShow\r\n    )\r\n\r\n    $mvpFeatures = @{\r\n        \"? CORE MVP\" = @(\r\n            \"Basic WPF window that opens\",\r\n            \"Simple student list (Name, Address)\",\r\n            \"Simple route list (Route Number, Description)\",\r\n            \"Assign student to route (dropdown)\",\r\n            \"Save data (even just to file)\",\r\n            \"Basic CRUD operations\"\r\n        )\r\n        \"?? NICE TO HAVE (Phase 2)\" = @(\r\n            \"Advanced Syncfusion controls\",\r\n            \"Google Earth integration\",\r\n            \"Real-time tracking\",\r\n            \"Advanced analytics\",\r\n            \"Multi-theme support\",\r\n            \"Performance monitoring\"\r\n        )\r\n        \"?? ENTERPRISE OVERKILL\" = @(\r\n            \"Microservices architecture\",\r\n            \"Container deployment\",\r\n            \"Advanced security patterns\",\r\n            \"Multi-tenant support\",\r\n            \"Cloud integration\",\r\n            \"Machine learning features\"\r\n        )\r\n    }\r\n\r\n    if ($JustShow) {\r\n        Write-BusBuddyStatus \"?? MVP Feature Priority Guide\" -Type Info\r\n        Write-Information \"\" -InformationAction Continue\r\n\r\n        foreach ($category in $mvpFeatures.Keys) {\r\n            Write-Information $category -InformationAction Continue\r\n            foreach ($feature in $mvpFeatures[$category]) {\r\n                Write-Information \"   $feature\" -InformationAction Continue\r\n            }\r\n            Write-Information \"\" -InformationAction Continue\r\n        }\r\n\r\n        Write-BusBuddyStatus \"?? Rule: If it's not in CORE MVP, defer it!\" -Type Warning\r\n        return\r\n    }\r\n\r\n    if ($FeatureIdea) {\r\n        Write-BusBuddyStatus \"?? Evaluating: '$FeatureIdea'\" -Type Info\r\n\r\n        $inCore = $mvpFeatures[\"? CORE MVP\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inNice = $mvpFeatures[\"?? NICE TO HAVE (Phase 2)\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n        $inOverkill = $mvpFeatures[\"?? ENTERPRISE OVERKILL\"] | Where-Object { $_ -match $FeatureIdea -or $FeatureIdea -match $_ }\r\n\r\n        if ($inCore) {\r\n            Write-BusBuddyStatus \"? GO FOR IT! This is core MVP functionality.\" -Type Success\r\n        }\r\n        elseif ($inNice) {\r\n            Write-BusBuddyStatus \"?? HOLD UP! This is nice-to-have. Focus on core MVP first.\" -Type Warning\r\n            Write-BusBuddyStatus \"?? Ask: 'Can I assign a student to a route without this?'\" -Type Warning\r\n        }\r\n        elseif ($inOverkill) {\r\n            Write-BusBuddyStatus \"?? STOP! This is enterprise overkill for MVP.\" -Type Error\r\n            Write-BusBuddyStatus \"?? Remember: You need a working tool, not a demo for Microsoft.\" -Type Error\r\n        }\r\n        else {\r\n            Write-BusBuddyStatus \"?? Unknown feature. Let's evaluate against MVP goals:\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 1: Does this help assign students to routes?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 2: Can you use BusBuddy without it?\" -Type Info\r\n            Write-BusBuddyStatus \"? Question 3: Will this take more than 1 day to implement?\" -Type Info\r\n        }\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyMVPReadiness {\r\n    <#\r\n    .SYNOPSIS\r\n        Check if we're ready for MVP delivery\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-BusBuddyStatus \"?? MVP Readiness Check\" -Type Info\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $ready = $true\r\n\r\n    # MVP Milestone 1: Application starts\r\n    Write-BusBuddyStatus \"Checking: Application starts without crashing...\" -Type Info\r\n    try {\r\n        & dotnet build BusBuddy.sln --verbosity quiet 2>&1\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? App builds successfully\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? App doesn't build - FIX THIS FIRST\" -Type Error\r\n            $ready = $false\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ? Build check failed - FIX THIS FIRST\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 2: Basic UI exists\r\n    $mainWindow = Join-Path $projectRoot \"BusBuddy.WPF\\Views\\Main\\MainWindow.xaml\"\r\n    if (Test-Path $mainWindow) {\r\n        Write-BusBuddyStatus \"  ? Main window exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No main window found - NEED BASIC UI\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Milestone 3: Data models exist\r\n    $modelsPath = Join-Path $projectRoot \"BusBuddy.Core\\Models\"\r\n    $studentModel = Get-ChildItem -Path $modelsPath -Filter \"*Student*\" -ErrorAction SilentlyContinue\r\n    $routeModel = Get-ChildItem -Path $modelsPath -Filter \"*Route*\" -ErrorAction SilentlyContinue\r\n\r\n    if ($studentModel) {\r\n        Write-BusBuddyStatus \"  ? Student model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Student model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    if ($routeModel) {\r\n        Write-BusBuddyStatus \"  ? Route model exists\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"  ? No Route model - NEED BASIC DATA\" -Type Error\r\n        $ready = $false\r\n    }\r\n\r\n    # MVP Readiness Summary\r\n    Write-BusBuddyStatus \"\" -Type Info\r\n    if ($ready) {\r\n        Write-BusBuddyStatus \"?? MVP READY! You can ship this!\" -Type Success\r\n        Write-BusBuddyStatus \"Next: Test that you can actually assign a student to a route\" -Type Success\r\n    } else {\r\n        Write-BusBuddyStatus \"?? MVP NOT READY - Focus on the failures above\" -Type Warning\r\n        Write-BusBuddyStatus \"?? Don't add features until these basic things work\" -Type Warning\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Anti-Regression Functions\r\n\r\nfunction Invoke-BusBuddyAntiRegression {\r\n    <#\r\n    .SYNOPSIS\r\n        Run anti-regression checks to prevent legacy patterns\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$Detailed\r\n    )\r\n\r\n    Write-BusBuddyStatus \"??? Running Anti-Regression Checks...\" -Type Info\r\n    $issues = @()\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n\r\n    # Check 1: Microsoft.Extensions.Logging violations\r\n    Write-BusBuddyStatus \"Checking for Microsoft.Extensions.Logging violations...\" -Type Info\r\n    try {\r\n        $loggingFiles = Get-ChildItem -Path $projectRoot -Include \"*.cs\" -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -notmatch \"\\.xml$\" }\r\n        $loggingViolations = $loggingFiles | Select-String -Pattern \"Microsoft.Extensions.Logging\" -ErrorAction SilentlyContinue\r\n\r\n        if ($loggingViolations) {\r\n            $issues += \"? Microsoft.Extensions.Logging violations: $($loggingViolations.Count)\"\r\n            if ($Detailed) {\r\n                $loggingViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No Microsoft.Extensions.Logging violations\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check logging violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 2: Standard WPF controls in XAML\r\n    Write-BusBuddyStatus \"Checking for standard WPF controls...\" -Type Info\r\n    try {\r\n        $xamlFiles = Get-ChildItem -Path \"$projectRoot\\BusBuddy.WPF\" -Include \"*.xaml\" -Recurse -ErrorAction SilentlyContinue\r\n        $xamlViolations = $xamlFiles | Select-String -Pattern \"<DataGrid |<ComboBox \" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"syncfusion:\" }\r\n\r\n        if ($xamlViolations) {\r\n            $issues += \"? Standard WPF controls found: $($xamlViolations.Count)\"\r\n            if ($Detailed) {\r\n                $xamlViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? No standard WPF controls found\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check XAML violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 3: PowerShell Write-Host violations\r\n    Write-BusBuddyStatus \"Checking PowerShell compliance...\" -Type Info\r\n    try {\r\n        $psFiles = Get-ChildItem -Path \"$projectRoot\\PowerShell\" -Include \"*.ps1\", \"*.psm1\" -Recurse -ErrorAction SilentlyContinue\r\n        $psViolations = $psFiles | Select-String -Pattern \"Write-Host\" -ErrorAction SilentlyContinue |\r\n            Where-Object { $_.Line -notmatch \"Module loaded|ForegroundColor|BusBuddy PowerShell Module\" }\r\n\r\n        if ($psViolations) {\r\n            $issues += \"? PowerShell Write-Host violations: $($psViolations.Count)\"\r\n            if ($Detailed) {\r\n                $psViolations | ForEach-Object {\r\n                    Write-BusBuddyStatus \"  ?? $($_.Filename):$($_.LineNumber)\" -Type Warning\r\n                }\r\n            }\r\n        } else {\r\n            Write-BusBuddyStatus \"  ? PowerShell compliance maintained\" -Type Success\r\n        }\r\n    } catch {\r\n        Write-BusBuddyStatus \"  ?? Could not check PowerShell violations: $($_.Exception.Message)\" -Type Warning\r\n    }\r\n\r\n    # Check 4: Build validation\r\n    Write-BusBuddyStatus \"Validating build status...\" -Type Info\r\n    try {\r\n        Set-Location $projectRoot\r\n        $buildOutput = & dotnet build --verbosity quiet 2>&1\r\n\r\n        if ($LASTEXITCODE -eq 0) {\r\n            Write-BusBuddyStatus \"  ? Build successful\" -Type Success\r\n        } else {\r\n            $issues += \"? Build failed with exit code: $LASTEXITCODE\"\r\n            if ($Detailed) {\r\n                Write-BusBuddyStatus \"  Build output: $buildOutput\" -Type Warning\r\n            }\r\n        }\r\n    } catch {\r\n        $issues += \"? Build check failed: $($_.Exception.Message)\"\r\n    }\r\n\r\n    # Report results\r\n    Write-BusBuddyStatus \" \" -Type Info\r\n    if ($issues.Count -eq 0) {\r\n        Write-BusBuddyStatus \"?? All anti-regression checks passed!\" -Type Success\r\n        Write-BusBuddyStatus \"Repository is compliant with BusBuddy standards.\" -Type Success\r\n        return $true\r\n    } else {\r\n        Write-BusBuddyError \"?? Anti-regression violations found:\"\r\n        $issues | ForEach-Object { Write-BusBuddyError \"  $_\" }\r\n        Write-BusBuddyStatus \" \" -Type Info\r\n        Write-BusBuddyStatus \"Run 'bb-anti-regression -Detailed' for specific file locations\" -Type Warning\r\n        Write-BusBuddyStatus \"See 'Grok Resources/ANTI-REGRESSION-CHECKLIST.md' for remediation steps\" -Type Warning\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyEnvironment {\r\n    <#\r\n    .SYNOPSIS\r\n        Validates BusBuddy PowerShell environment for consistency and reliability\r\n    .DESCRIPTION\r\n        Comprehensive validation to ensure the development environment is properly\r\n        configured and ready for MVP development. Checks PowerShell version, workspace,\r\n        module availability, and essential tools.\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([bool])]\r\n    param()\r\n\r\n    Write-Information \"?? BusBuddy Environment Validation\" -InformationAction Continue\r\n    Write-Information \"=================================\" -InformationAction Continue\r\n    Write-Information \"\" -InformationAction Continue\r\n\r\n    $issues = @()\r\n    $warnings = @()\r\n\r\n    # 1. PowerShell Version Check\r\n    Write-Information \"1. PowerShell Version...\" -InformationAction Continue\r\n    if ($PSVersionTable.PSVersion -ge [version]'7.5.0') {\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) (Required: 7.5+)\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"PowerShell version $($PSVersionTable.PSVersion) is too old. Need 7.5+\"\r\n        Write-Information \"   ? PowerShell $($PSVersionTable.PSVersion) - UPGRADE REQUIRED\" -InformationAction Continue\r\n    }\r\n\r\n    # 2. BusBuddy Workspace Detection\r\n    Write-Information \"2. Workspace Detection...\" -InformationAction Continue\r\n    $workspaceFound = $false\r\n    $possiblePaths = @(\r\n        $PWD.Path,\r\n        \"$env:USERPROFILE\\Desktop\\BusBuddy\",\r\n        \"$env:USERPROFILE\\Documents\\BusBuddy\",\r\n        \"C:\\BusBuddy\"\r\n    )\r\n\r\n    foreach ($path in $possiblePaths) {\r\n        if (Test-Path \"$path\\BusBuddy.sln\" -ErrorAction SilentlyContinue) {\r\n            Write-Information \"   ? Workspace found: $path\" -InformationAction Continue\r\n            $workspaceFound = $true\r\n            break\r\n        }\r\n    }\r\n\r\n    if (-not $workspaceFound) {\r\n        $issues += \"BusBuddy workspace not found in standard locations\"\r\n        Write-Information \"   ? Workspace not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 3. Essential Commands Test\r\n    Write-Information \"3. Essential Commands...\" -InformationAction Continue\r\n    $essentialCommands = @('bb-build', 'bb-run', 'bb-health', 'bb-mvp', 'bb-mvp-check')\r\n    $commandsWorking = 0\r\n\r\n    foreach ($cmd in $essentialCommands) {\r\n        if (Get-Command $cmd -ErrorAction SilentlyContinue) {\r\n            $commandsWorking++\r\n        }\r\n    }\r\n\r\n    if ($commandsWorking -eq $essentialCommands.Count) {\r\n        Write-Information \"   ? All $($essentialCommands.Count) essential commands available\" -InformationAction Continue\r\n    } else {\r\n        $issues += \"Only $commandsWorking of $($essentialCommands.Count) commands available\"\r\n        Write-Information \"   ? Missing commands ($commandsWorking/$($essentialCommands.Count))\" -InformationAction Continue\r\n    }\r\n\r\n    # 4. .NET SDK Check\r\n    Write-Information \"4. .NET SDK...\" -InformationAction Continue\r\n    try {\r\n        $dotnetVersion = & dotnet --version 2>$null\r\n        if ($dotnetVersion -and $dotnetVersion -match '^9\\.') {\r\n            Write-Information \"   ? .NET $dotnetVersion\" -InformationAction Continue\r\n        } else {\r\n            $warnings += \".NET version $dotnetVersion - expected 9.x\"\r\n            Write-Information \"   ?? .NET $dotnetVersion (Expected: 9.x)\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $issues += \".NET SDK not found or not working\"\r\n        Write-Information \"   ? .NET SDK not found\" -InformationAction Continue\r\n    }\r\n\r\n    # 5. Git Status\r\n    Write-Information \"5. Git Repository...\" -InformationAction Continue\r\n    try {\r\n        $gitStatus = & git status --porcelain 2>$null\r\n        if ($LASTEXITCODE -eq 0) {\r\n            if ($gitStatus) {\r\n                $warnings += \"Git has uncommitted changes\"\r\n                Write-Information \"   ?? Uncommitted changes present\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"   ? Git repository clean\" -InformationAction Continue\r\n            }\r\n        } else {\r\n            $warnings += \"Not in a Git repository or Git not available\"\r\n            Write-Information \"   ?? Git issues detected\" -InformationAction Continue\r\n        }\r\n    } catch {\r\n        $warnings += \"Git not available: $($_.Exception.Message)\"\r\n        Write-Information \"   ?? Git not available\" -InformationAction Continue\r\n    }\r\n\r\n    # 6. Grok Resources Check\r\n    Write-Information \"6. AI Assistant Resources...\" -InformationAction Continue\r\n    if (Test-Path \"Grok Resources\\GROK-README.md\") {\r\n        Write-Information \"   ? Grok Resources folder ready\" -InformationAction Continue\r\n    } else {\r\n        # Respect suppression env var if present (used by VS Code tasks)\r\n        if ($env:BUSBUDDY_NO_XAI_WARN -ne '1') {\r\n            # Removed per MVP request: avoid Grok/xAI warning noise in health check\r\n            # $warnings += \"Grok Resources not found - AI assistance may be limited\"\r\n        }\r\n        Write-Information \"   ?? Grok Resources missing\" -InformationAction Continue\r\n    }\r\n\r\n    # Summary\r\n    Write-Information \"\" -InformationAction Continue\r\n    Write-Information \"?? VALIDATION SUMMARY\" -InformationAction Continue\r\n    Write-Information \"=====================\" -InformationAction Continue\r\n\r\n    if ($issues.Count -eq 0) {\r\n        Write-Information \"? ENVIRONMENT READY FOR MVP DEVELOPMENT!\" -InformationAction Continue\r\n        Write-Information \"   All critical systems are operational\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? Quick Start Commands:\" -InformationAction Continue\r\n        Write-Information \"   bb-health      - System health check\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp -JustShow - Show MVP priorities\" -InformationAction Continue\r\n        Write-Information \"   bb-build       - Build the solution\" -InformationAction Continue\r\n        Write-Information \"   bb-run         - Run the application\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"?? MVP Focus:\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp 'feature name' - Evaluate if feature is MVP-worthy\" -InformationAction Continue\r\n        Write-Information \"   bb-mvp-check          - Check MVP milestone readiness\" -InformationAction Continue\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? WARNINGS (non-critical):\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $true\r\n    } else {\r\n        Write-Information \"? ENVIRONMENT NOT READY\" -InformationAction Continue\r\n        Write-Information \"   Fix these issues before starting development:\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n        $issues | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n\r\n        if ($warnings.Count -gt 0) {\r\n            Write-Information \"\" -InformationAction Continue\r\n            Write-Information \"?? Additional warnings:\" -InformationAction Continue\r\n            $warnings | ForEach-Object { Write-Information \"    $_\" -InformationAction Continue }\r\n        }\r\n\r\n        return $false\r\n    }\r\n}\r\n\r\nfunction Start-BusBuddyRuntimeErrorCaptureBasic {\r\n    <#\r\n    .SYNOPSIS\r\n        Comprehensive runtime error capture for BusBuddy application\r\n    .DESCRIPTION\r\n        Executes BusBuddy with multiple error capture mechanisms to identify\r\n        and log runtime issues during application execution.\r\n    .PARAMETER Duration\r\n        How long to monitor the application (in seconds). Default: 60\r\n    .PARAMETER DetailedLogging\r\n        Enable detailed debug logging during capture\r\n    .PARAMETER OpenLogsAfter\r\n        Automatically open the log directory after capture completes\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors\r\n        Captures runtime errors for 60 seconds with standard logging\r\n    .EXAMPLE\r\n        bb-capture-runtime-errors -Duration 300 -DetailedLogging -OpenLogsAfter\r\n        Extended capture with detailed logs and auto-open results\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [ValidateRange(10, 3600)]\r\n        [int]$Duration = 60,\r\n\r\n        [Parameter()]\r\n        [switch]$DetailedLogging,\r\n\r\n        [Parameter()]\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    $projectRoot = Get-BusBuddyProjectRoot\r\n    $scriptPath = Join-Path $projectRoot \"PowerShell\\Scripts\\Capture-RuntimeErrors.ps1\"\r\n\r\n    if (-not (Test-Path $scriptPath)) {\r\n        Write-BusBuddyError \"Runtime error capture script not found: $scriptPath\"\r\n        Write-BusBuddyStatus \"Run the following to create required scripts\" -Type Warning\r\n        return\r\n    }\r\n\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy runtime error capture...\" -Type Info\r\n    Write-Information \"Duration: $Duration seconds\" -InformationAction Continue\r\n    Write-Information \"Detailed logging: $DetailedLogging\" -InformationAction Continue\r\n\r\n    try {\r\n        $params = @{\r\n            Duration = $Duration\r\n        }\r\n\r\n        if ($DetailedLogging) {\r\n            $params.Add(\"DetailedLogging\", $true)\r\n        }\r\n\r\n        if ($OpenLogsAfter) {\r\n            $params.Add(\"OpenLogsAfter\", $true)\r\n        }\r\n\r\n        # Execute the capture script\r\n        $result = & $scriptPath @params\r\n\r\n        if ($result.Success) {\r\n            Write-BusBuddyStatus \"Runtime capture completed successfully! No errors detected.\" -Type Success\r\n        } else {\r\n            Write-BusBuddyStatus \"Runtime capture detected $($result.ErrorCount) errors - review logs\" -Type Warning\r\n        }\r\n\r\n        return $result\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Runtime error capture failed: $($_.Exception.Message)\"\r\n        Write-Information \"Stack trace: $($_.ScriptStackTrace)\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Lightweight wrapper to run the app and capture runtime errors using the basic capture script\r\nfunction Invoke-BusBuddyRunCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Run BusBuddy and capture runtime errors with logs and a summary report\r\n\r\n    .DESCRIPTION\r\n        Wraps the Capture-RuntimeErrors.ps1 script to launch the WPF app with stdio capture,\r\n        time-bound monitoring, and writes logs to logs\\runtime-capture.\r\n\r\n    .PARAMETER Duration\r\n        Monitoring duration in seconds (default 60)\r\n\r\n    .PARAMETER DetailedLogging\r\n        Enables extra CLI arguments and verbose capture\r\n\r\n    .PARAMETER OpenLogsAfter\r\n        Opens the log directory in Explorer after capture completes\r\n\r\n    .EXAMPLE\r\n        bb-run-capture -Duration 90 -DetailedLogging -OpenLogsAfter\r\n    #>\r\n    [CmdletBinding()]\r\n    param(\r\n        [ValidateRange(10,3600)]\r\n        [int]$Duration = 60,\r\n        [switch]$DetailedLogging,\r\n        [switch]$OpenLogsAfter\r\n    )\r\n\r\n    # Delegate to the existing basic runtime capture implementation\r\n    Start-BusBuddyRuntimeErrorCaptureBasic -Duration $Duration -DetailedLogging:$DetailedLogging -OpenLogsAfter:$OpenLogsAfter | Out-Null\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Validation aliases (explicit): ensure hyphenated commands exist for CI/docs\r\ntry { Set-Alias -Name 'bb-anti-regression' -Value 'Invoke-BusBuddyAntiRegression' -Force } catch { Write-Warning (\"Failed to set alias bb-anti-regression: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bb-mvp-check'      -Value 'Test-BusBuddyMVPReadiness' -Force } catch { Write-Warning (\"Failed to set alias bb-mvp-check: {0}\" -f $_.Exception.Message) }\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n\r\nfunction Start-BusBuddyRuntimeErrorCapture {\r\n    <#\r\n    .SYNOPSIS\r\n        Advanced runtime error capture using WintellectPowerShell tools\r\n\r\n    .DESCRIPTION\r\n        Enhanced error monitoring and capture system that integrates WintellectPowerShell\r\n        tools for comprehensive diagnostics, crash dump analysis, and system monitoring.\r\n\r\n    .PARAMETER MonitorCrashes\r\n        Enable crash dump monitoring and automatic analysis\r\n\r\n    .PARAMETER SystemDiagnostics\r\n        Include system diagnostics (uptime, environment, etc.)\r\n\r\n    .PARAMETER ContinuousMonitoring\r\n        Run in continuous monitoring mode\r\n\r\n    .PARAMETER OutputPath\r\n        Path to save error reports and analysis (default: logs/error-capture)\r\n\r\n    .EXAMPLE\r\n        Start-BusBuddyRuntimeErrorCapture -MonitorCrashes -SystemDiagnostics\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess = $true, ConfirmImpact = 'Low')]\r\n    [OutputType([hashtable])]\r\n    param(\r\n        [Parameter()]\r\n        [switch]$MonitorCrashes,\r\n\r\n        [Parameter()]\r\n        [switch]$SystemDiagnostics,\r\n\r\n        [Parameter()]\r\n    [switch]$ContinuousMonitoring,\r\n\r\n        [Parameter()]\r\n        [string]$OutputPath = \"logs/error-capture\"\r\n    )\r\n\r\n    $sessionId = [System.Guid]::NewGuid().ToString(\"N\")[0..7] -join \"\"\r\n    $startTime = Get-Date\r\n\r\n    Write-BusBuddyStatus \"?? Starting Enhanced Error Capture Session [$sessionId]\" -Type Info\r\n    if ($ContinuousMonitoring) { Write-Information \"Continuous Monitoring: Enabled\" -InformationAction Continue }\r\n    Write-Information \"? Session Start: $($startTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -InformationAction Continue\r\n\r\n    # Ensure WintellectPowerShell is available\r\n    try {\r\n        Import-Module WintellectPowerShell -Force -ErrorAction Stop\r\n        Write-BusBuddyStatus \"? WintellectPowerShell module loaded\" -Type Success\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Failed to load WintellectPowerShell module\" -Exception $_ -Suggestions @(\r\n            \"Install WintellectPowerShell: Install-Module WintellectPowerShell -Scope CurrentUser\",\r\n            \"Check module availability: Get-Module -ListAvailable WintellectPowerShell\"\r\n        )\r\n        return\r\n    }\r\n\r\n    # Create output directory\r\n    $fullOutputPath = Join-Path (Get-BusBuddyProjectRoot) $OutputPath\r\n    if (-not (Test-Path $fullOutputPath)) {\r\n        if ($PSCmdlet.ShouldProcess($fullOutputPath,'Create error-capture directory')) {\r\n            New-Item -ItemType Directory -Path $fullOutputPath -Force | Out-Null\r\n            Write-BusBuddyStatus \"?? Created output directory: $fullOutputPath\" -Type Info\r\n        }\r\n    }\r\n\r\n    # System Diagnostics Collection\r\n    if ($SystemDiagnostics) {\r\n        Write-BusBuddyStatus \"?? Collecting System Diagnostics...\" -Type Info\r\n\r\n        try {\r\n            # Get system uptime using WintellectPowerShell\r\n            $uptime = Get-Uptime\r\n            $uptimeInfo = @{\r\n                Days = $uptime.Days\r\n                Hours = $uptime.Hours\r\n                Minutes = $uptime.Minutes\r\n                TotalHours = [math]::Round($uptime.TotalHours, 2)\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Collect environment information\r\n            $envInfo = @{\r\n                PowerShellVersion = $PSVersionTable.PSVersion\r\n                DotNetVersion = & dotnet --version 2>$null\r\n                UserName = $env:USERNAME\r\n                MachineName = $env:COMPUTERNAME\r\n                WorkingDirectory = Get-Location\r\n                ProcessId = $PID\r\n                SessionId = $sessionId\r\n            }\r\n\r\n            # System resource information\r\n            $systemInfo = @{\r\n                Uptime = $uptimeInfo\r\n                Environment = $envInfo\r\n                Timestamp = Get-Date\r\n            }\r\n\r\n            # Save system diagnostics\r\n            $diagnosticsFile = Join-Path $fullOutputPath \"system-diagnostics-$sessionId.json\"\r\n            $systemInfo | ConvertTo-Json -Depth 3 | Out-File -FilePath $diagnosticsFile -Encoding UTF8\r\n\r\n            Write-BusBuddyStatus \"? System diagnostics saved to: $diagnosticsFile\" -Type Success\r\n            Write-Information \"?? System Uptime: $($uptime.Days) days, $($uptime.Hours) hours\" -InformationAction Continue\r\n            Write-Information \"?? PowerShell: $($PSVersionTable.PSVersion)\" -InformationAction Continue\r\n            Write-Information \"??  .NET Version: $(& dotnet --version 2>$null)\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-BusBuddyError \"Failed to collect system diagnostics\" -Exception $_\r\n        }\r\n    }\r\n\r\n    # Crash Dump Monitoring\r\n    if ($MonitorCrashes) {\r\n        Write-BusBuddyStatus \"?? Setting up crash dump monitoring...\" -Type Info\r\n\r\n        # Look for existing crash dumps\r\n        $projectRoot = Get-BusBuddyProjectRoot\r\n        $possibleDumpLocations = @(\r\n            Join-Path $projectRoot \"logs\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Debug\\net9.0-windows\"\r\n            Join-Path $projectRoot \"BusBuddy.WPF\\bin\\Release\\net9.0-windows\"\r\n            $env:TEMP,\r\n            $env:LOCALAPPDATA\r\n        )\r\n\r\n        $foundDumps = @()\r\n        foreach ($location in $possibleDumpLocations) {\r\n            if (Test-Path $location) {\r\n                $dumps = Get-ChildItem -Path $location -Filter \"*.dmp\" -ErrorAction SilentlyContinue\r\n                if ($dumps) {\r\n                    $foundDumps += $dumps\r\n                    Write-Information \"?? Found $($dumps.Count) dump file(s) in: $location\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        if ($foundDumps.Count -gt 0) {\r\n            Write-BusBuddyStatus \"?? Analyzing $($foundDumps.Count) existing crash dump(s)...\" -Type Warning\r\n\r\n            # Create basic analysis script for CDB\r\n            $analysisScript = Join-Path $fullOutputPath \"crash-analysis-commands.txt\"\r\n            $cdbCommands = @(\r\n                \"* Basic crash analysis commands\",\r\n                \".sympath srv*https://msdl.microsoft.com/download/symbols\",\r\n                \".reload\",\r\n                \"!analyze -v\",\r\n                \"k\",\r\n                \"!clrstack\",\r\n                \".ecxr\",\r\n                \"!pe\",\r\n                \"q\"\r\n            )\r\n            $cdbCommands | Out-File -FilePath $analysisScript -Encoding UTF8\r\n\r\n            foreach ($dump in $foundDumps) {\r\n                try {\r\n                    Write-Information \"?? Analyzing: $($dump.Name)\" -InformationAction Continue\r\n\r\n                    # Use WintellectPowerShell to analyze the dump\r\n                    Get-DumpAnalysis -Files $dump.FullName -DebuggingScript $analysisScript\r\n\r\n                    Write-BusBuddyStatus \"? Analysis completed for: $($dump.Name)\" -Type Success\r\n                }\r\n                catch {\r\n                    Write-BusBuddyError \"Failed to analyze dump: $($dump.Name)\" -Exception $_\r\n                }\r\n            }\r\n        } else {\r\n            Write-Information \"??  No existing crash dumps found\" -InformationAction Continue\r\n        }\r\n    }\r\n\r\n    # Enhanced BusBuddy Application Execution with Error Capture\r\n    Write-BusBuddyStatus \"?? Starting BusBuddy with enhanced error monitoring...\" -Type Info\r\n\r\n    try {\r\n        # Enhanced execution using existing exception capture\r\n        $result = Invoke-BusBuddyWithExceptionCapture -Command \"dotnet\" -Arguments @(\"run\", \"--project\", \"BusBuddy.WPF/BusBuddy.WPF.csproj\") -Context \"Enhanced BusBuddy Execution\" -Timeout 300\r\n\r\n        # Final report\r\n        $endTime = Get-Date\r\n        $duration = $endTime - $startTime\r\n\r\n        $sessionReport = @{\r\n            SessionId = $sessionId\r\n            StartTime = $startTime\r\n            EndTime = $endTime\r\n            Duration = $duration.TotalMinutes\r\n            OutputPath = $fullOutputPath\r\n            MonitorCrashes = $MonitorCrashes.IsPresent\r\n            SystemDiagnostics = $SystemDiagnostics.IsPresent\r\n            Result = if ($result) { \"Success\" } else { \"Failed\" }\r\n            WintellectTools = \"Available\"\r\n        }\r\n\r\n        $reportFile = Join-Path $fullOutputPath \"session-report-$sessionId.json\"\r\n        $sessionReport | ConvertTo-Json -Depth 2 | Out-File -FilePath $reportFile -Encoding UTF8\r\n\r\n        Write-BusBuddyStatus \"?? Session report saved: $reportFile\" -Type Success\r\n        Write-Information \"??  Total session duration: $([math]::Round($duration.TotalMinutes, 2)) minutes\" -InformationAction Continue\r\n\r\n        return $sessionReport\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Enhanced error capture failed\" -Exception $_ -Context \"Runtime Error Monitoring\"\r\n        return $null\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Azure Firewall Management Functions\r\n\r\nfunction Update-BusBuddyAzureFirewall {\r\n    <#\r\n    .SYNOPSIS\r\n        Automatically updates Azure SQL firewall rules for BusBuddy dynamic IP addresses\r\n    .DESCRIPTION\r\n        Fetches current public IP and adds it to Azure SQL firewall rules.\r\n        Handles Starlink and work ISP dynamic IP changes automatically.\r\n        Based on Microsoft Azure SQL firewall configuration best practices.\r\n    .PARAMETER ResourceGroupName\r\n        Azure resource group containing the SQL server (auto-detected from config if not specified)\r\n    .PARAMETER ServerName\r\n        Azure SQL server name (default: busbuddy-server-sm2 from appsettings.azure.json)\r\n    .PARAMETER CleanupOldRules\r\n        Remove old dynamic IP rules to keep firewall clean\r\n    .PARAMETER Force\r\n        Skip confirmation prompts\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall\r\n    .EXAMPLE\r\n        Update-BusBuddyAzureFirewall -CleanupOldRules -Force\r\n    .NOTES\r\n        Reference: https://learn.microsoft.com/en-us/azure/azure-sql/database/firewall-configure\r\n        Requires Az PowerShell module: Install-Module -Name Az.Sql -Scope CurrentUser\r\n        Auto-integrates with BusBuddy appsettings.azure.json configuration\r\n    #>\r\n    [CmdletBinding(SupportsShouldProcess)]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ResourceGroupName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [string]$ServerName,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$CleanupOldRules,\r\n\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$Force\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? BusBuddy Azure SQL Firewall Updater\" -InformationAction Continue\r\n        Write-Information \"=\" * 50 -InformationAction Continue\r\n\r\n        # Get BusBuddy Azure configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load BusBuddy Azure configuration from appsettings.azure.json\"\r\n        }\r\n\r\n        # Use configuration values if not provided\r\n        if (-not $ServerName) {\r\n            $ServerName = $config.ServerName\r\n            if (-not $ServerName) {\r\n                throw \"Server name not found in configuration and not provided\"\r\n            }\r\n        }\r\n\r\n        if (-not $ResourceGroupName) {\r\n            $ResourceGroupName = $config.ResourceGroup\r\n            if (-not $ResourceGroupName) {\r\n                Write-Warning \"Resource group not specified in config. Please provide it manually.\"\r\n                $ResourceGroupName = Read-Host \"Enter Azure Resource Group name\"\r\n                if (-not $ResourceGroupName) {\r\n                    throw \"Resource group is required\"\r\n                }\r\n            }\r\n        }\r\n\r\n        # Call the main update script\r\n        $scriptPath = Join-Path $PSScriptRoot \"..\\..\\Scripts\\Update-AzureFirewall.ps1\"\r\n        if (-not (Test-Path $scriptPath)) {\r\n            throw \"Update-AzureFirewall.ps1 script not found at: $scriptPath\"\r\n        }\r\n\r\n        $params = @{\r\n            ResourceGroupName = $ResourceGroupName\r\n            ServerName = $ServerName\r\n            CleanupOldRules = $CleanupOldRules\r\n        }\r\n\r\n        Write-Information \"?? Target: $ServerName in $ResourceGroupName\" -InformationAction Continue\r\n\r\n        if ($Force -or $PSCmdlet.ShouldProcess(\"Azure SQL Server $ServerName\", \"Update firewall rules\")) {\r\n            $result = & $scriptPath @params\r\n\r\n            if ($result.Success) {\r\n                Write-BusBuddyStatus \"? Azure firewall updated successfully\" -Type Success\r\n                Write-Information \"   IP Address: $($result.IPAddress)\" -InformationAction Continue\r\n                Write-Information \"   Rule Name: $($result.RuleName)\" -InformationAction Continue\r\n                Write-Information \"?? Allow up to 5 minutes for rule propagation\" -InformationAction Continue\r\n            } else {\r\n                Write-BusBuddyError \"Failed to update Azure firewall\" -Exception ([System.Exception]::new($result.Error)) -Context \"Azure Firewall\"\r\n            }\r\n\r\n            return $result\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure firewall update failed\" -Exception $_ -Context \"Azure Firewall Management\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\nfunction Get-BusBuddyAzureConfig {\r\n    <#\r\n    .SYNOPSIS\r\n        Extracts Azure configuration from BusBuddy appsettings files\r\n    .DESCRIPTION\r\n        Parses appsettings.azure.json to extract server name, resource group, and other Azure settings\r\n    .EXAMPLE\r\n        Get-BusBuddyAzureConfig\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param()\r\n\r\n    try {\r\n        $configFile = \"appsettings.azure.json\"\r\n        if (-not (Test-Path $configFile)) {\r\n            Write-Warning \"appsettings.azure.json not found in current directory\"\r\n            return $null\r\n        }\r\n\r\n        $config = Get-Content $configFile -Raw | ConvertFrom-Json\r\n\r\n        # Extract server name from connection string\r\n        $connectionString = $config.ConnectionStrings.DefaultConnection\r\n        if ($connectionString -match 'Server=tcp:([^.,]+)') {\r\n            $serverName = $matches[1]\r\n        } else {\r\n            Write-Warning \"Could not extract server name from connection string\"\r\n            $serverName = $null\r\n        }\r\n\r\n        # Try to find resource group in various config locations\r\n        $resourceGroup = $null\r\n        if ($config.Azure.ResourceGroup) {\r\n            $resourceGroup = $config.Azure.ResourceGroup\r\n        } elseif ($config.ResourceGroup) {\r\n            $resourceGroup = $config.ResourceGroup\r\n        }\r\n\r\n        return @{\r\n            ServerName = $serverName\r\n            ResourceGroup = $resourceGroup\r\n            DatabaseName = \"BusBuddyDB\"\r\n            ConnectionString = $connectionString\r\n            Config = $config\r\n        }\r\n    }\r\n    catch {\r\n        Write-Warning \"Failed to parse Azure configuration: $($_.Exception.Message)\"\r\n        return $null\r\n    }\r\n}\r\n\r\nfunction Test-BusBuddyAzureConnection {\r\n    <#\r\n    .SYNOPSIS\r\n        Tests Azure SQL connection for BusBuddy database\r\n    .DESCRIPTION\r\n        Validates network connectivity and firewall rules for Azure SQL Database\r\n        Provides detailed diagnostics for connection issues\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection\r\n    .EXAMPLE\r\n        Test-BusBuddyAzureConnection -UpdateFirewall\r\n    #>\r\n    [CmdletBinding()]\r\n    [OutputType([hashtable])]\r\n    param (\r\n        [Parameter(Mandatory = $false)]\r\n        [switch]$UpdateFirewall\r\n    )\r\n\r\n    try {\r\n        Write-Information \"?? Testing BusBuddy Azure SQL Connection\" -InformationAction Continue\r\n        Write-Information \"=\" * 45 -InformationAction Continue\r\n\r\n        # Get configuration\r\n        $config = Get-BusBuddyAzureConfig\r\n        if (-not $config) {\r\n            throw \"Could not load Azure configuration\"\r\n        }\r\n\r\n        # Test network connectivity\r\n        Write-Information \"?? Testing network connectivity...\" -InformationAction Continue\r\n        $serverFqdn = \"$($config.ServerName).database.windows.net\"\r\n\r\n        try {\r\n            $tcpTest = Test-NetConnection -ComputerName $serverFqdn -Port 1433 -WarningAction SilentlyContinue\r\n            if ($tcpTest.TcpTestSucceeded) {\r\n                Write-Information \"? Network connectivity: SUCCESS\" -InformationAction Continue\r\n            } else {\r\n                Write-Information \"? Network connectivity: FAILED\" -InformationAction Continue\r\n                Write-Information \"   This may indicate firewall or network issues\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            Write-Information \"? Network test failed: $($_.Exception.Message)\" -InformationAction Continue\r\n        }\r\n\r\n        # Get current IP\r\n        try {\r\n            $currentIP = (Invoke-RestMethod -Uri \"https://api.ipify.org\" -TimeoutSec 10).Trim()\r\n            Write-Information \"?? Current public IP: $currentIP\" -InformationAction Continue\r\n        }\r\n        catch {\r\n            Write-Warning \"Could not determine current IP address\"\r\n            $currentIP = \"Unknown\"\r\n        }\r\n\r\n        # Test SQL connection\r\n        Write-Information \"?? Testing SQL authentication...\" -InformationAction Continue\r\n\r\n        $connectionSuccess = $false\r\n        $connectionError = $null\r\n\r\n        try {\r\n            # Use .NET SqlConnection for direct testing\r\n            $connectionString = $config.ConnectionString\r\n            # Replace environment variables for testing\r\n            $testConnectionString = $connectionString -replace '\\$\\{AZURE_SQL_USER\\}', $env:AZURE_SQL_USER -replace '\\$\\{AZURE_SQL_PASSWORD\\}', $env:AZURE_SQL_PASSWORD\r\n\r\n            if ($testConnectionString -match '\\$\\{') {\r\n                Write-Warning \"Environment variables not set: AZURE_SQL_USER, AZURE_SQL_PASSWORD\"\r\n                Write-Information \"?? Set environment variables or use manual portal test\" -InformationAction Continue\r\n            } else {\r\n                Add-Type -AssemblyName System.Data\r\n                $sqlConnection = New-Object System.Data.SqlClient.SqlConnection($testConnectionString)\r\n                $sqlConnection.Open()\r\n                $sqlConnection.Close()\r\n                $connectionSuccess = $true\r\n                Write-Information \"? SQL connection: SUCCESS\" -InformationAction Continue\r\n            }\r\n        }\r\n        catch {\r\n            $connectionError = $_.Exception.Message\r\n            Write-Information \"? SQL connection: FAILED\" -InformationAction Continue\r\n            Write-Information \"   Error: $connectionError\" -InformationAction Continue\r\n\r\n            # Check for firewall-related errors\r\n            if ($connectionError -like \"*Client with IP address*not allowed*\") {\r\n                Write-Information \"??? Firewall issue detected!\" -InformationAction Continue\r\n                if ($UpdateFirewall) {\r\n                    Write-Information \"?? Attempting to update firewall rules...\" -InformationAction Continue\r\n                    $firewallResult = Update-BusBuddyAzureFirewall -Force\r\n                    if ($firewallResult.Success) {\r\n                        Write-Information \"? Firewall updated. Retry connection in 5 minutes.\" -InformationAction Continue\r\n                    }\r\n                } else {\r\n                    Write-Information \"?? Run with -UpdateFirewall to automatically fix\" -InformationAction Continue\r\n                }\r\n            }\r\n        }\r\n\r\n        # Summary\r\n        Write-Information \"`n?? Connection Test Summary:\" -InformationAction Continue\r\n        Write-Information \"   Server: $serverFqdn\" -InformationAction Continue\r\n        Write-Information \"   Database: $($config.DatabaseName)\" -InformationAction Continue\r\n        Write-Information \"   Current IP: $currentIP\" -InformationAction Continue\r\n        Write-Information \"   Network: $(if ($tcpTest.TcpTestSucceeded) { '?' } else { '?' })\" -InformationAction Continue\r\n        Write-Information \"   SQL Auth: $(if ($connectionSuccess) { '?' } else { '?' })\" -InformationAction Continue\r\n\r\n        if (-not $connectionSuccess) {\r\n            Write-Information \"`n?? Troubleshooting options:\" -InformationAction Continue\r\n            Write-Information \"1. Update firewall: bb-azure-firewall\" -InformationAction Continue\r\n            Write-Information \"2. Use local database: Set DatabaseProvider=Local\" -InformationAction Continue\r\n            Write-Information \"3. Check Azure portal: https://portal.azure.com\" -InformationAction Continue\r\n            Write-Information \"4. Verify credentials: echo `$env:AZURE_SQL_USER\" -InformationAction Continue\r\n        }\r\n\r\n        return @{\r\n            Success = $connectionSuccess\r\n            NetworkConnectivity = $tcpTest.TcpTestSucceeded\r\n            CurrentIP = $currentIP\r\n            Server = $serverFqdn\r\n            Database = $config.DatabaseName\r\n            Error = $connectionError\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n    catch {\r\n        Write-BusBuddyError \"Azure connection test failed\" -Exception $_ -Context \"Azure Connection Test\"\r\n        return @{\r\n            Success = $false\r\n            Error = $_.Exception.Message\r\n            Timestamp = Get-Date\r\n        }\r\n    }\r\n}\r\n\r\n#endregion\r\n\r\n#region Aliases - Safe Alias Creation with Conflict Resolution\r\n# Core aliases with safe creation\r\ntry { Set-Alias -Name 'bbBuild'      -Value 'Invoke-BusBuddyBuild'   -Force } catch { Write-Warning (\"Failed to set alias bbBuild: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRun'        -Value 'Invoke-BusBuddyRun'     -Force } catch { Write-Warning (\"Failed to set alias bbRun: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRunSta'     -Value 'Invoke-BusBuddyRunSta'  -Force } catch { Write-Warning (\"Failed to set alias bbRunSta: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbClean'      -Value 'Invoke-BusBuddyClean'   -Force } catch { Write-Warning (\"Failed to set alias bbClean: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbRestore'    -Value 'Invoke-BusBuddyRestore' -Force } catch { Write-Warning (\"Failed to set alias bbRestore: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbTest'       -Value 'Invoke-BusBuddyTest'    -Force } catch { Write-Warning (\"Failed to set alias bbTest: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbHealth'     -Value 'Invoke-BusBuddyHealthCheck' -Force } catch { Write-Warning (\"Failed to set alias bbHealth: {0}\" -f $_.Exception.Message) }\r\n\r\n# Developer discovery\r\ntry { Set-Alias -Name 'bbDevSession' -Value 'Start-BusBuddyDevSession' -Force } catch { Write-Warning (\"Failed to set alias bbDevSession: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbInfo'       -Value 'Get-BusBuddyInfo' -Force } catch { Write-Warning (\"Failed to set alias bbInfo: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbCommands'   -Value 'Get-BusBuddyCommand' -Force } catch { Write-Warning (\"Failed to set alias bbCommands: {0}\" -f $_.Exception.Message) }\r\n\r\n# Removed alias for bbXamlValidate (function not present)\r\n\r\n# Session correlation\r\ntry { Set-Alias -Name 'bbMantra'       -Value 'Get-BusBuddyMantraId'    -Force } catch { Write-Warning (\"Failed to set alias bbMantra: {0}\" -f $_.Exception.Message) }\r\ntry { Set-Alias -Name 'bbMantraReset'  -Value 'Reset-BusBuddyMantraId'  -Force } catch { Write-Warning (\"Failed to set alias bbMantraReset: {0}\" -f $_.Exception.Message) }\r\n\r\n# Environment\r\ntry { Set-Alias -Name 'bbEnv'          -Value 'Initialize-BusBuddyEnvironment' -Force } catch { Write-Warning (\"Failed to set alias bbEnv: {0}\" -f $_.Exception.Message) }\r\n# Hyphenated variants\r\nforeach ($pair in @(\r\n    @{A='bb-build';V='Invoke-BusBuddyBuild'},\r\n    @{A='bb-run';V='Invoke-BusBuddyRun'},\r\n    @{A='bb-run-sta';V='Invoke-BusBuddyRunSta'},\r\n    @{A='bb-clean';V='Invoke-BusBuddyClean'},\r\n    @{A='bb-restore';V='Invoke-BusBuddyRestore'},\r\n    @{A='bb-test';V='Invoke-BusBuddyTest'},\r\n    @{A='bb-health';V='Invoke-BusBuddyHealthCheck'},\r\n    @{A='bb-env';V='Initialize-BusBuddyEnvironment'\r\n})) { try { Set-Alias -Name $pair.A -Value $pair.V -Force } catch { Write-Warning (\"Failed to set alias {0}: {1}\" -f $pair.A, $_.Exception.Message) } }\r\n#endregion\r\n\r\n#region Exports\r\nExport-ModuleMember -Function @(\r\n    'Invoke-BusBuddyBuild',\r\n    'Invoke-BusBuddyRun',\r\n    'Invoke-BusBuddyRunSta',\r\n    'Invoke-BusBuddyClean',\r\n    'Invoke-BusBuddyRestore',\r\n    'Invoke-BusBuddyTest',\r\n    'Invoke-BusBuddyHealthCheck',\r\n    # Ensure MVP and Anti-Regression functions are exported\r\n    'Test-BusBuddyMVPReadiness',\r\n    'Invoke-BusBuddyAntiRegression',\r\n    'Get-BusBuddyApartmentState',\r\n    'Get-BusBuddyMantraId',\r\n    'Reset-BusBuddyMantraId',\r\n    'Start-BusBuddyDevSession',\r\n    'Get-BusBuddyInfo',\r\n    'Get-BusBuddyCommand',\r\n    'Get-BusBuddyTestOutput',\r\n    'Invoke-BusBuddyTestFull',\r\n    'Get-BusBuddyTestError',\r\n    'Get-BusBuddyTestLog',\r\n    'Start-BusBuddyTestWatch',\r\n    'Invoke-BusBuddyPester',\r\n    'Get-BusBuddyTelemetrySummary',\r\n    'Invoke-BusBuddyTelemetryPurge',\r\n    'Get-BusBuddyPS75Compliance',\r\n    'Initialize-BusBuddyEnvironment',\r\n    # Script Lint exports\r\n    'Test-BusBuddyErrorActionPipeline',\r\n    'Invoke-BusBuddyErrorActionAudit',\r\n    # Logging exports\r\n    'Get-BusBuddyLogSummary'\r\n) -Alias @(\r\n    'bbBuild','bbRun','bbRunSta','bbClean','bbRestore','bbTest','bbHealth',\r\n    'bbDevSession','bbInfo','bbCommands',\r\n    'bb-build','bb-run','bb-run-sta','bb-clean','bb-restore','bb-test','bb-health',\r\n    'bbMantra','bbMantraReset','bbTestFull',\r\n    'bb-ps-review',\r\n    'bbEnv','bb-env',\r\n    # Script Lint aliases\r\n    'bb-ps-validate-ea','bb-ps-validate-ea-run',\r\n    # Logging alias\r\n    'bb-logs-summary',\r\n    # Validation aliases (export explicitly for reliability)\r\n    'bb-anti-regression','bb-mvp-check'\r\n)\r\n#endregion\r\n\r\n#region Welcome Screen\r\nfunction Show-BusBuddyWelcome {\r\n    <#\r\n    .SYNOPSIS\r\n        Display a categorized welcome screen when the module loads.\r\n    #>\r\n    [CmdletBinding()]\r\n    param([switch]$Quiet)\r\n\r\n    $ps = $PSVersionTable.PSVersion\r\n    $dotnet = try { & dotnet --version 2>$null } catch { \"unknown\" }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-BusBuddyStatus \"?? BusBuddy Dev Shell - Ready\" -Type Info\r\n        Write-Information \"PowerShell: $ps | .NET: $dotnet\" -InformationAction Continue\r\n        Write-Information \"Project: $(Get-BusBuddyProjectRoot)\" -InformationAction Continue\r\n        Write-Information \"\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Core\" -Type Info\r\n        Write-Information \"  bbBuild, bbRun, bbTest, bbClean, bbRestore, bbHealth\" -InformationAction Continue\r\n    }\r\n\r\n    if ($env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-BusBuddyStatus \"Development\" -Type Info\r\n        Write-Information \"  bbDevSession, bbInfo, bbCommands, bbMantra, bbMantraReset\" -InformationAction Continue\r\n    }\r\n\r\n    # Removed 'Validation & Safety' section (no bbXamlValidate)\r\n\r\n    # Docs & Reference remains gated if bbCopilotRef exists\r\n    if ($env:BUSBUDDY_SILENT -ne '1' -and (Get-Command bbCopilotRef -ErrorAction SilentlyContinue)) {\r\n        Write-BusBuddyStatus \"Docs & Reference\" -Type Info\r\n        Write-Information \"  bbCopilotRef [Topic] (-ShowTopics)\" -InformationAction Continue\r\n    }\r\n\r\n    if (-not $Quiet -and $env:BUSBUDDY_SILENT -ne '1') {\r\n        Write-Information \"\" -InformationAction Continue\r\n        Write-Information \"Tips:\" -InformationAction Continue\r\n        Write-Information \"   bbCommands - full list with functions\" -InformationAction Continue\r\n        Write-Information \"   bbHealth - verify env quickly\" -InformationAction Continue\r\n        Write-Information \"   Set 'BUSBUDDY_NO_WELCOME=1' to suppress on import\" -InformationAction Continue\r\n    }\r\n}\r\n\r\n# Auto-run welcome unless suppressed\r\nif (-not $env:BUSBUDDY_NO_WELCOME -and $env:BUSBUDDY_SILENT -ne '1') {\r\n    Show-BusBuddyWelcome -Quiet\r\n}\r\n#endregion\r\n\r\n# Removed duplicated trailing welcome/region markers at EOF to avoid double execution.\r\n\r\n",
            "Description": "Microsoft PowerShell 7.5.2 compliant modular development module for BusBuddy. Provides category-based function loading following Microsoft standards.",
            "Guid": "21ff42ae-cd8d-4bb8-8f99-b31f63be42b5",
            "HelpInfoUri": null,
            "ModuleBase": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy",
            "PrivateData": "System.Collections.Hashtable",
            "ExperimentalFeatures": "",
            "Tags": "BusBuddy Development WPF DotNet BusBuddy Development WPF DotNet",
            "ProjectUri": "https://github.com/Bigessfour/BusBuddy-2",
            "IconUri": null,
            "LicenseUri": "https://github.com/Bigessfour/BusBuddy-2/blob/main/LICENSE",
            "ReleaseNotes": "Streamlined core module for reliable development workflow",
            "RepositorySourceLocation": null,
            "Version": "2.0.0",
            "ModuleType": 0,
            "Author": "Bus Buddy Development Team",
            "AccessMode": 0,
            "ClrVersion": null,
            "CompanyName": "BusBuddy Team",
            "Copyright": "(c) 2025 BusBuddy. All rights reserved.",
            "DotNetFrameworkVersion": null,
            "ExportedFunctions": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.FunctionInfo]",
            "Prefix": "",
            "ExportedCmdlets": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CmdletInfo]",
            "ExportedCommands": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.CommandInfo]",
            "FileList": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psm1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-validate-database.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-anti-regression.ps1 C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\bb-health.ps1",
            "CompatiblePSEditions": "Core",
            "ModuleList": "",
            "NestedModules": "BusBuddy.BuildOutput BusBuddy.TestOutput BusBuddy.ThemeValidation BusBuddy.AzureSqlHealth BusBuddy.TestWatcher BusBuddy.Cleanup",
            "PowerShellHostName": null,
            "PowerShellHostVersion": null,
            "PowerShellVersion": "7.5",
            "ProcessorArchitecture": 0,
            "Scripts": "",
            "RequiredAssemblies": "",
            "RequiredModules": "",
            "RootModule": "BusBuddy.psm1",
            "ExportedVariables": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.PSVariable]",
            "ExportedAliases": "System.Collections.Generic.Dictionary`2[System.String,System.Management.Automation.AliasInfo]",
            "ExportedDscResources": "",
            "SessionState": "System.Management.Automation.SessionState",
            "OnRemove": null,
            "ExportedFormatFiles": "",
            "ExportedTypeFiles": ""
          },
          "InvokeProvider": {
            "Item": "System.Management.Automation.ItemCmdletProviderIntrinsics",
            "ChildItem": "System.Management.Automation.ChildItemCmdletProviderIntrinsics",
            "Content": "System.Management.Automation.ContentCmdletProviderIntrinsics",
            "Property": "System.Management.Automation.PropertyCmdletProviderIntrinsics",
            "SecurityDescriptor": "System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics"
          },
          "InvokeCommand": {
            "HasErrors": null,
            "CommandNotFoundAction": null,
            "PreCommandLookupAction": null,
            "PostCommandLookupAction": null,
            "LocationChangedAction": null
          }
        },
        "OnRemove": null,
        "ExportedFormatFiles": [],
        "ExportedTypeFiles": []
      }
    }
  ],
  "Manifests": [
    {
      "ManifestPath": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy\\BusBuddy.psd1",
      "RootModule": "BusBuddy.psm1",
      "ModuleVersion": "2.0.0",
      "AliasesToExport": [
        "bbHealth",
        "bbBuild",
        "bbRun",
        "bbTest",
        "bbMvpCheck",
        "bbAntiRegression",
        "bbXamlValidate",
        "bbDevSession",
        "bbRefresh",
        "bbCommands",
        "bbTestWatch",
        "bbTestReport"
      ],
      "FunctionsToExport": [
        "Import-BusBuddyFunction",
        "Import-BusBuddyFunctionCategory",
        "Get-BusBuddyProjectRoot",
        "Write-BusBuddyStatus",
        "Write-BusBuddyError",
        "Invoke-BusBuddyDotNetCommand",
        "Invoke-BusBuddyBuild",
        "Invoke-BusBuddyRun",
        "Invoke-BusBuddyTest",
        "Invoke-BusBuddyClean",
        "Invoke-BusBuddyRestore",
        "Invoke-BusBuddyHealthCheck",
        "Test-BusBuddyHealth",
        "Start-BusBuddyDevSession",
        "Get-BusBuddyCommand",
        "Get-BusBuddyInfo",
        "Show-BusBuddyWelcome",
        "Test-BusBuddyThemeConsistency",
        "Invoke-BusBuddyThemeRemediation",
        "Test-BusBuddyAzureSql",
        "Get-BusBuddySqlStatus",
        "Start-BusBuddyTestWatchAdvanced",
        "Stop-BusBuddyTestWatchAdvanced",
        "Invoke-BusBuddyCleanup",
        "Get-BusBuddyUnusedFiles",
        "Remove-BusBuddyUnusedFiles",
        "Test-BusBuddyMVPReadiness",
        "Invoke-BusBuddyAntiRegression"
      ],
      "MissingAliasesInPsd1": null,
      "AliasesWildcardExport": false,
      "FunctionsWildcard": false
    },
    {
      "ManifestPath": "C:\\Users\\biges\\Desktop\\BusBuddy\\PowerShell\\Modules\\BusBuddy.Testing\\BusBuddy.Testing.psd1",
      "RootModule": "BusBuddy.Testing.psm1",
      "ModuleVersion": "1.0.0",
      "AliasesToExport": [
        "bb-test-watch",
        "bb-test-report",
        "bb-test-status",
        "bb-test-init",
        "bb-test-compliance",
        "bbHealth",
        "bbBuild",
        "bbRun",
        "bbTest",
        "bbMvpCheck",
        "bbAntiRegression",
        "bbXamlValidate",
        "bbDevSession",
        "bbRefresh",
        "bbCommands",
        "bbTestWatch",
        "bbTestReport"
      ],
      "FunctionsToExport": [
        "Start-BusBuddyTest",
        "Start-BusBuddyTestWatch",
        "New-BusBuddyTestReport",
        "Get-BusBuddyTestStatus",
        "Initialize-BusBuddyTestEnvironment",
        "Test-BusBuddyCompliance"
      ],
      "MissingAliasesInPsd1": null,
      "AliasesWildcardExport": false,
      "FunctionsWildcard": false
    }
  ],
  "MissingAliases": [
    "bbMvpCheck",
    "bbAntiRegression",
    "bbXamlValidate",
    "bbRefresh",
    "bbTestWatch",
    "bbTestReport"
  ]
}
