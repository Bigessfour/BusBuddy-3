name: ğŸš€ CI/CD - Build, Test & Standards Validation

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    name: ğŸ—ï¸ Build & Test
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: ğŸ“¦ Restore Dependencies
      run: dotnet restore BusBuddy.sln

    - name: ğŸ—ï¸ Build Solution
      run: dotnet build BusBuddy.sln --configuration Release --no-restore --verbosity minimal

    - name: ğŸ§ª Run Tests
      run: |
        # Create TestResults directory if it doesn't exist
        New-Item -ItemType Directory -Path "./TestResults" -Force | Out-Null

        # Check if test projects exist
        $testProjects = Get-ChildItem -Path . -Recurse -Include "*.Tests.csproj", "*Test*.csproj" -ErrorAction SilentlyContinue

        if ($testProjects.Count -gt 0) {
          Write-Host "ğŸ§ª Found $($testProjects.Count) test projects - running tests with coverage"
          dotnet test BusBuddy.sln --configuration Release --no-build --verbosity minimal --logger trx --results-directory ./TestResults
        } else {
          Write-Host "ğŸ“ No test projects found - creating placeholder results for workflow compatibility"
          $trxContent = '<?xml version="1.0" encoding="UTF-8"?><TestRun xmlns="http://microsoft.com/schemas/VisualStudio/TeamTest/2010"><ResultSummary outcome="Completed"><Counters total="0" executed="0" passed="0" failed="0" /></ResultSummary></TestRun>'
          $trxContent | Out-File -FilePath "./TestResults/placeholder-results.trx" -Encoding UTF8
          Write-Host "âœ… Placeholder test results created"
        }
      shell: pwsh
      continue-on-error: true

    - name: ğŸ“Š Test Results
      uses: dorny/test-reporter@v1
      if: always()
      with:
        name: ğŸ“‹ .NET Test Results
        path: './TestResults/**/*.trx'
        reporter: dotnet-trx
        fail-on-error: false

  standards-validation:
    name: ğŸ“š Standards Validation
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup PowerShell
      shell: pwsh
      run: |
        Write-Host "âœ… PowerShell Core Version: $($PSVersionTable.PSVersion)" -ForegroundColor Green

    - name: ğŸ“‹ Validate Standards Directory
      shell: pwsh
      run: |
        Write-Host "ğŸ” Validating Standards Directory Structure..." -ForegroundColor Cyan

        $requiredFiles = @(
          "Standards/MASTER-STANDARDS.md",
          "Standards/IMPLEMENTATION-REPORT.md",
          "Standards/LANGUAGE-INVENTORY.md",
          "Standards/Languages/JSON-STANDARDS.md",
          "Standards/Languages/XML-STANDARDS.md",
          "Standards/Languages/YAML-STANDARDS.md"
        )

        $missing = @()
        foreach ($file in $requiredFiles) {
          if (-not (Test-Path $file)) {
            $missing += $file
          } else {
            Write-Host "âœ… Found: $file" -ForegroundColor Green
          }
        }

        if ($missing.Count -gt 0) {
          Write-Host "âŒ Missing required standards files:" -ForegroundColor Red
          $missing | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
          exit 1
        }

        Write-Host "ğŸ‰ All required standards files present!" -ForegroundColor Green

    - name: ğŸ”¬ JSON Standards Validation
      shell: pwsh
      run: |
        Write-Host "ğŸ” Validating JSON files against standards..." -ForegroundColor Cyan

        $jsonFiles = Get-ChildItem -Recurse -Filter "*.json" | Where-Object {
          $_.FullName -notlike "*node_modules*" -and
          $_.FullName -notlike "*bin*" -and
          $_.FullName -notlike "*obj*"
        }

        $errors = @()
        foreach ($file in $jsonFiles) {
          try {
            $content = Get-Content $file.FullName -Raw
            $parsed = $content | ConvertFrom-Json
            Write-Host "âœ… Valid JSON: $($file.Name)" -ForegroundColor Green
          } catch {
            $errors += "âŒ Invalid JSON: $($file.FullName) - $($_.Exception.Message)"
          }
        }

        if ($errors.Count -gt 0) {
          Write-Host "âŒ JSON Validation Errors:" -ForegroundColor Red
          $errors | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
          exit 1
        }

        Write-Host "ğŸ‰ All JSON files are valid!" -ForegroundColor Green

    - name: ğŸ”¬ XML Standards Validation
      shell: pwsh
      run: |
        Write-Host "ğŸ” Validating XML files against standards..." -ForegroundColor Cyan

        $xmlFiles = Get-ChildItem -Recurse -Filter "*.xml" | Where-Object {
          $_.FullName -notlike "*bin*" -and
          $_.FullName -notlike "*obj*" -and
          $_.FullName -notlike "*packages*"
        }

        $errors = @()
        foreach ($file in $xmlFiles) {
          try {
            $xml = [xml](Get-Content $file.FullName)
            Write-Host "âœ… Valid XML: $($file.Name)" -ForegroundColor Green
          } catch {
            $errors += "âŒ Invalid XML: $($file.FullName) - $($_.Exception.Message)"
          }
        }

        if ($errors.Count -gt 0) {
          Write-Host "âŒ XML Validation Errors:" -ForegroundColor Red
          $errors | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
          exit 1
        }

        Write-Host "ğŸ‰ All XML files are valid!" -ForegroundColor Green

    - name: ğŸ”¬ C# Code Standards Check
      shell: pwsh
      run: |
        Write-Host "ğŸ” Checking C# code standards..." -ForegroundColor Cyan

        # Check for basic C# standards compliance
        $csFiles = Get-ChildItem -Recurse -Filter "*.cs" | Where-Object {
          $_.FullName -notlike "*bin*" -and
          $_.FullName -notlike "*obj*"
        }

        $issues = @()
        foreach ($file in $csFiles) {
          $content = Get-Content $file.FullName -Raw

          # Check for basic standards
          if ($content -match "Console\.WriteLine" -and $file.Name -notlike "*Program.cs") {
            $issues += "âš ï¸ Found Console.WriteLine in $($file.Name) - Should use ILogger"
          }

          if ($content -match "using System\.Threading\.Tasks;" -and $content -notmatch "async|await") {
            # This is just a warning, not an error
          }
        }

        if ($issues.Count -gt 0) {
          Write-Host "âš ï¸ C# Standards Recommendations:" -ForegroundColor Yellow
          $issues | ForEach-Object { Write-Host "  $_" -ForegroundColor Yellow }
        }

        Write-Host "âœ… C# standards check completed" -ForegroundColor Green

  repository-health:
    name: ğŸ¥ Repository Health Check
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ“Š Repository Size Analysis
      shell: pwsh
      run: |
        Write-Host "ğŸ” Analyzing repository size..." -ForegroundColor Cyan

        $totalSize = (Get-ChildItem -Recurse | Measure-Object -Property Length -Sum).Sum
        $sizeMB = [math]::Round($totalSize / 1MB, 2)

        Write-Host "ğŸ“Š Repository Size: $sizeMB MB" -ForegroundColor Cyan

        # Check for large files
        $largeFiles = Get-ChildItem -Recurse | Where-Object {
          $_.Length -gt 10MB -and -not $_.PSIsContainer
        } | Sort-Object Length -Descending | Select-Object -First 10

        if ($largeFiles) {
          Write-Host "âš ï¸ Large files found (>10MB):" -ForegroundColor Yellow
          $largeFiles | ForEach-Object {
            $fileSizeMB = [math]::Round($_.Length / 1MB, 2)
            Write-Host "  ğŸ“ $($_.FullName.Replace($PWD, '.')) - $fileSizeMB MB" -ForegroundColor Yellow
          }
        }

        # Check logs directory
        if (Test-Path "logs") {
          $logsSize = (Get-ChildItem -Path "logs" -Recurse | Measure-Object -Property Length -Sum).Sum
          $logsSizeMB = [math]::Round($logsSize / 1MB, 2)
          Write-Host "ğŸ“ Logs directory size: $logsSizeMB MB" -ForegroundColor Cyan

          if ($logsSizeMB -gt 50) {
            Write-Host "âš ï¸ Logs directory is large (>50MB) - consider cleanup" -ForegroundColor Yellow
          }
        }

        # Size warnings
        if ($sizeMB -gt 500) {
          Write-Host "âš ï¸ Repository size exceeds 500MB - optimization recommended" -ForegroundColor Yellow
          exit 1
        } elseif ($sizeMB -gt 300) {
          Write-Host "âš ï¸ Repository size exceeds 300MB - monitoring recommended" -ForegroundColor Yellow
        } else {
          Write-Host "âœ… Repository size is within acceptable limits" -ForegroundColor Green
        }

  security-scan:
    name: ğŸ”’ Security Scan
    runs-on: windows-latest
    timeout-minutes: 30

    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ”§ Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: ğŸ”’ Security Vulnerability Scan
      run: dotnet list package --vulnerable --include-transitive
      continue-on-error: true

    - name: ğŸ” Secrets Detection
      shell: pwsh
      run: |
        Write-Host "ğŸ” Scanning for potential secrets..." -ForegroundColor Cyan

        $patterns = @(
          'password\s*=\s*"[^"]*"',
          'api[_-]?key\s*=\s*"[^"]*"',
          'secret\s*=\s*"[^"]*"',
          'token\s*=\s*"[^"]*"',
          'connection[_-]?string\s*=\s*"[^"]*"'
        )

        $issues = @()
        $files = Get-ChildItem -Recurse -Include "*.cs","*.json","*.xml","*.config" | Where-Object {
          $_.FullName -notlike "*bin*" -and
          $_.FullName -notlike "*obj*"
        }

        foreach ($file in $files) {
          $content = Get-Content $file.FullName -Raw
          foreach ($pattern in $patterns) {
            if ($content -match $pattern) {
              $issues += "âš ï¸ Potential secret in $($file.Name)"
            }
          }
        }

        if ($issues.Count -gt 0) {
          Write-Host "âš ï¸ Potential security issues found:" -ForegroundColor Yellow
          $issues | ForEach-Object { Write-Host "  $_" -ForegroundColor Yellow }
        } else {
          Write-Host "âœ… No obvious secrets detected" -ForegroundColor Green
        }

  notify-completion:
    name: ğŸ“¢ Workflow Completion
    runs-on: windows-latest
    timeout-minutes: 30
    needs: [build-and-test, standards-validation, repository-health, security-scan]
    if: always()

    steps:
    - name: ğŸ“Š Workflow Summary
      shell: pwsh
      run: |
        Write-Host "ğŸ‰ CI/CD Workflow Completed!" -ForegroundColor Green
        Write-Host "ğŸ“Š Job Status Summary:" -ForegroundColor Cyan
        Write-Host "  ğŸ—ï¸ Build & Test: ${{ needs.build-and-test.result }}" -ForegroundColor $(if ('${{ needs.build-and-test.result }}' -eq 'success') { 'Green' } else { 'Red' })
        Write-Host "  ğŸ“š Standards: ${{ needs.standards-validation.result }}" -ForegroundColor $(if ('${{ needs.standards-validation.result }}' -eq 'success') { 'Green' } else { 'Red' })
        Write-Host "  ğŸ¥ Repository: ${{ needs.repository-health.result }}" -ForegroundColor $(if ('${{ needs.repository-health.result }}' -eq 'success') { 'Green' } else { 'Red' })
        Write-Host "  ğŸ”’ Security: ${{ needs.security-scan.result }}" -ForegroundColor $(if ('${{ needs.security-scan.result }}' -eq 'success') { 'Green' } else { 'Red' })







