# Simplified CI pipeline (restore â†’ build â†’ test â†’ optional EF migration â†’ publish)
# Reference: https://docs.github.com/actions/using-workflows/workflow-syntax-for-github-actions
name: ðŸšŒ BusBuddy CI

env:
  DOTNET_VERSION: 9.0.303
  BUILD_CONFIGURATION: Release
  SOLUTION_FILE: BusBuddy.sln

on:
  push:
    branches:
      - master
      - main
  pull_request:
    branches:
      - master
      - main
  workflow_dispatch:

jobs:
  build-and-test:
    name: ðŸ—ï¸ Build & Test (Sf ${{ matrix.syncfusion }})
    runs-on: windows-latest
    timeout-minutes: 20
    strategy:
      fail-fast: false
      matrix:
        syncfusion: ["30.2.4", "30.2.5"]
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: âš™ï¸ Set CI defaults
        shell: pwsh
        run: |
          if (-not $env:SOLUTION_FILE) {
            $sln = Get-ChildItem -Path . -Filter *.sln -Recurse | Select-Object -First 1
            if ($sln) { "SOLUTION_FILE=$($sln.FullName)" >> $env:GITHUB_ENV }
          }
      - name: ðŸ“Œ Set and validate Syncfusion version pin
        shell: pwsh
        run: |
          $desired = "${{ matrix.syncfusion }}"
          $propsPath = "Directory.Build.props"
          [xml]$xml = Get-Content -Raw -Path $propsPath
          # PropertyGroup may appear multiple times; pick the first group that contains the element
          $node = ($xml.Project.PropertyGroup | ForEach-Object { $_.SyncfusionVersion } | Where-Object { $_ } | Select-Object -First 1)
          if (-not $node) { throw "Could not find <SyncfusionVersion> in $propsPath" }
          $current = try { $node.InnerText } catch { [string]$node }
          if ($current -ne $desired) {
            Write-Host "Updating SyncfusionVersion: $current -> $desired"
            $updated = $false
            try {
              $node.InnerText = $desired
              $xml.Save((Resolve-Path $propsPath))
              $updated = $true
            } catch {
              Write-Host "XML DOM update failed â€” falling back to regex replace: $($_.Exception.Message)"
            }
            if (-not $updated) {
              $raw = Get-Content -Raw -Path $propsPath
              $new = [regex]::Replace($raw, '<SyncfusionVersion>.*?</SyncfusionVersion>', "<SyncfusionVersion>$desired</SyncfusionVersion>")
              if ($new -ne $raw) { [IO.File]::WriteAllText((Resolve-Path $propsPath), $new, [Text.Encoding]::UTF8) }
            }
          } else {
            Write-Host "SyncfusionVersion already set to $current"
          }
          # Validate update
          $props = Get-Content -Raw -Path $propsPath
          if ($props -notmatch "<SyncfusionVersion>$desired</SyncfusionVersion>") { throw "Failed to set SyncfusionVersion to $desired" }

      - name: ðŸ—ï¸ Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: ðŸ” Export secrets to env
        shell: pwsh
        run: |
          $secrets = @{
            SYNCFUSION_LICENSE_KEY = '${{ secrets.SYNCFUSION_LICENSE_KEY }}'
            BUSBUDDY_CONNECTION    = '${{ secrets.BUSBUDDY_CONNECTION }}'
            AZURE_SQL_SERVER       = '${{ secrets.AZURE_SQL_SERVER }}'
            AZURE_SQL_USER         = '${{ secrets.AZURE_SQL_USER }}'
            AZURE_SQL_PASSWORD     = '${{ secrets.AZURE_SQL_PASSWORD }}'
          }
          foreach ($k in $secrets.Keys) {
            $v = $secrets[$k]
            if ($null -ne $v -and $v -ne '') {
              Write-Output "::add-mask::$v"
              Add-Content -Path $env:GITHUB_ENV -Value "$k=$v"
            }
          }

      - name: Configure Syncfusion license
        run: |
          if (-not $env:SYNCFUSION_LICENSE_KEY) {
            echo "::notice::SYNCFUSION_LICENSE_KEY not set; build may show license warnings."
          } else {
            Write-Information "Syncfusion license key present." -InformationAction Continue
          }

      - name: ðŸ”§ Restore dependencies
        run: dotnet restore ${{ env.SOLUTION_FILE }} --verbosity minimal

      - name: ðŸ—ï¸ Build solution
        run: dotnet build ${{ env.SOLUTION_FILE }} --no-restore --configuration ${{ env.BUILD_CONFIGURATION }} --verbosity minimal

      - name: ðŸ§ª Run tests
        run: dotnet test ${{ env.SOLUTION_FILE }} --no-build --configuration ${{ env.BUILD_CONFIGURATION }} --verbosity normal --logger "trx;LogFileName=Tests.trx"

      - name: ðŸ“Š Publish test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ github.run_number }}
          path: "**/Tests.trx"
          retention-days: 7

      - name: ðŸ› ï¸ Ensure sqlcmd is available
        id: ensure-sqlcmd
        if: ${{ env.BUSBUDDY_CONNECTION != '' && env.AZURE_SQL_SERVER != '' && env.AZURE_SQL_USER != '' && env.AZURE_SQL_PASSWORD != '' }}
        shell: pwsh
        run: |
          $found = $false
          if (-not (Get-Command sqlcmd -ErrorAction SilentlyContinue)) {
            echo "sqlcmd not found â€” attempting install via Chocolatey..."
            try {
              choco install sqlserver-cmdline-utils -y --no-progress | Out-Null
            } catch {
              echo "::warning::Failed to install sqlcmd via Chocolatey"
            }
          }
          if (Get-Command sqlcmd -ErrorAction SilentlyContinue) {
            $found = $true
            echo "sqlcmd available."
          } else {
            echo "::notice::sqlcmd not available; migration application will be skipped"
          }
          echo "found=$found" >> $env:GITHUB_OUTPUT

      - name: ðŸ“œ Generate EF migration script
        if: ${{ env.BUSBUDDY_CONNECTION != '' }}
        shell: pwsh
        run: |
          echo "Generating idempotent EF migration script..."
          dotnet tool install --global dotnet-ef --version 9.* 2>$null | Out-Null
          $env:PATH += ";$env:USERPROFILE\.dotnet\tools"
          dotnet ef migrations script --idempotent --output migration-script.sql --project BusBuddy.Core/BusBuddy.Core.csproj --startup-project BusBuddy.WPF/BusBuddy.WPF.csproj

      - name: ðŸ§© Apply EF migrations to Azure SQL
        if: ${{ env.BUSBUDDY_CONNECTION != '' && env.AZURE_SQL_SERVER != '' && env.AZURE_SQL_USER != '' && env.AZURE_SQL_PASSWORD != '' && steps.ensure-sqlcmd.outputs.found == 'True' }}
        shell: pwsh
        run: |
          echo "Applying migrations to database..."
          sqlcmd -S "${{ env.AZURE_SQL_SERVER }}" -d "BusBuddyDb" -U "${{ env.AZURE_SQL_USER }}" -P "${{ env.AZURE_SQL_PASSWORD }}" -i migration-script.sql

      - name: ðŸ“¤ Upload migration script
        if: ${{ env.BUSBUDDY_CONNECTION != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: migration-script-${{ github.run_number }}
          path: migration-script.sql
          retention-days: 7

      - name: ðŸ“¦ Publish WPF application
        if: success() && github.event_name == 'push'
        run: |
          echo "Publishing WPF application..."
          dotnet publish BusBuddy.WPF/BusBuddy.WPF.csproj --configuration ${{ env.BUILD_CONFIGURATION }} --no-build --output ./publish --runtime win-x64

      - name: ðŸ“¦ Archive build artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: build-artifacts-${{ github.run_number }}
          path: |
            **/bin/Release/
            publish/
          retention-days: 7

      - name: ðŸ“Š Generate workflow summary
        if: always()
        shell: pwsh
        run: |
          echo "## ðŸšŒ BusBuddy CI Summary" >> $env:GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $env:GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $env:GITHUB_STEP_SUMMARY
          echo "| Build & Test | ${{ job.status }} |" >> $env:GITHUB_STEP_SUMMARY
          echo "" >> $env:GITHUB_STEP_SUMMARY
          echo "${{ job.status == 'success' && 'âœ… Workflow PASSED' || 'âŒ Workflow FAILED - Check logs for details' }}" >> $env:GITHUB_STEP_SUMMARY
