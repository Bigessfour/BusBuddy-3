name: ðŸŽ¯ Code Quality Gate

on:
  pull_request:
    branches: [main, master]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  DOTNET_VERSION: "9.0.x"
  SOLUTION_FILE: "BusBuddy.sln"

jobs:
  quality-gate:
    runs-on: windows-latest
    timeout-minutes: 20

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Enable GitVersion

      - name: ðŸ—ï¸ Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: ðŸ”§ Restore dependencies
        run: dotnet restore ${{ env.SOLUTION_FILE }}

      - name: ðŸ—ï¸ Build solution
        run: dotnet build ${{ env.SOLUTION_FILE }} --no-restore --configuration Release

      - name: ðŸ§ª Run tests with coverage
        run: |
          dotnet test ${{ env.SOLUTION_FILE }} --no-build --configuration Release --collect:"XPlat Code Coverage" --results-directory ./TestResults --logger trx || echo "Tests completed with issues"

      - name: ðŸ“ Enforce coverage threshold (Cobertura)
        id: coverage
        shell: pwsh
        run: |
          $threshold = 70.0
          $resultsDir = Join-Path (Get-Location) 'TestResults'
          $files = @()
          if (Test-Path $resultsDir) {
            $files = Get-ChildItem -Path $resultsDir -Recurse -Filter 'coverage.cobertura.xml' -ErrorAction SilentlyContinue
          }
          if (-not $files -or $files.Count -eq 0) {
            Write-Warning 'No Cobertura coverage files found under ./TestResults â€” setting coverage to 0.'
            $covered = 0.0; $valid = 0.0
          } else {
            $covered = 0.0; $valid = 0.0
            foreach ($f in $files) {
              try {
                [xml]$xml = Get-Content -Raw -Path $f.FullName
                $node = $xml.SelectSingleNode('/coverage')
                if ($null -ne $node) {
                  $lv = [double]($node.Attributes['lines-valid'].Value)
                  $lc = [double]($node.Attributes['lines-covered'].Value)
                  $valid += $lv
                  $covered += $lc
                }
              } catch {
                Write-Warning ("Failed to parse coverage file {0}: {1}" -f $f.FullName, $_.Exception.Message)
              }
            }
          }

          $pct = if ($valid -gt 0) { [math]::Round(($covered / $valid) * 100, 2) } else { 0.0 }
          Write-Host ("Aggregated coverage: {0}% (covered={1} / valid={2})" -f $pct, $covered, $valid)

          # Export outputs for later steps
          echo "coverage=$pct" >> $env:GITHUB_OUTPUT
          echo "coverage-threshold=$threshold" >> $env:GITHUB_OUTPUT
          if ($pct -ge $threshold) { echo "coverage-pass=true" >> $env:GITHUB_OUTPUT } else { echo "coverage-pass=false" >> $env:GITHUB_OUTPUT }

          if ($pct -lt $threshold) {
            Write-Error ("Test coverage {0}% is below threshold {1}%" -f $pct, $threshold)
            exit 1
          }

      - name: ï¿½ Scan vulnerable dependencies
        shell: pwsh
        run: |
          echo "ðŸ”’ Scanning for vulnerable NuGet packages..."
          dotnet list ${{ env.SOLUTION_FILE }} package --vulnerable --include-transitive | Tee-Object -FilePath vulnerability-report.txt

      - name: ï¿½ðŸ“Š Quality metrics analysis
        id: quality-metrics
        run: |
          echo "ðŸ“Š Analyzing code quality metrics..."

          # Count files and lines
          $csFiles = (Get-ChildItem -Path . -Recurse -Include "*.cs" -Exclude "bin","obj","Migrations","*.g.cs","*.designer.cs" | Measure-Object).Count
          $xamlFiles = (Get-ChildItem -Path . -Recurse -Include "*.xaml" -Exclude "bin","obj" | Measure-Object).Count

          # Analyze test coverage potential
          $testFiles = (Get-ChildItem -Path . -Recurse -Include "*Test*.cs","*Tests.cs" -Exclude "bin","obj" | Measure-Object).Count
          $testCoverage = if ($csFiles -gt 0) { [math]::Round(($testFiles / $csFiles) * 100, 1) } else { 0 }

          # Check for common code quality indicators
          $viewModelFiles = (Get-ChildItem -Path . -Recurse -Include "*ViewModel.cs" -Exclude "bin","obj" | Measure-Object).Count
          $serviceFiles = (Get-ChildItem -Path . -Recurse -Include "*Service.cs" -Exclude "bin","obj" | Measure-Object).Count

          echo "cs-files=$csFiles" >> $env:GITHUB_OUTPUT
          echo "xaml-files=$xamlFiles" >> $env:GITHUB_OUTPUT
          echo "test-files=$testFiles" >> $env:GITHUB_OUTPUT
          echo "test-coverage=$testCoverage" >> $env:GITHUB_OUTPUT
          echo "viewmodel-files=$viewModelFiles" >> $env:GITHUB_OUTPUT
          echo "service-files=$serviceFiles" >> $env:GITHUB_OUTPUT

          echo "ðŸ“‹ Quality Metrics:"
          echo "   ðŸ“„ C# files: $csFiles"
          echo "   ðŸ“„ XAML files: $xamlFiles"
          echo "   ðŸ§ª Test files: $testFiles"
          echo "   ðŸ“Š Test ratio: $testCoverage%"
          echo "   ðŸ—ï¸ ViewModels: $viewModelFiles"
          echo "   âš™ï¸ Services: $serviceFiles"

      - name: âœ… Quality gate evaluation
        id: quality-gate
        run: |
          echo "âœ… Evaluating quality gate criteria..."

          $csFiles = [int]"${{ steps.quality-metrics.outputs.cs-files }}"
          $testFiles = [int]"${{ steps.quality-metrics.outputs.test-files }}"
          $testCoverage = [float]"${{ steps.quality-metrics.outputs.test-coverage }}"

          $passed = $true
          $issues = @()

          # Quality gate rules (industry standards)
          if ($csFiles -gt 50 -and $testCoverage -lt 20) {
            $issues += "âš ï¸ Test coverage ratio below 20% for mature codebase"
            $passed = $false
          }

          if ($csFiles -gt 100 -and $testFiles -eq 0) {
            $issues += "âŒ No test files found for large codebase"
            $passed = $false
          }

          echo "quality-gate-passed=$passed" >> $env:GITHUB_OUTPUT

          if ($passed) {
            echo "âœ… Quality gate PASSED"
          } else {
            echo "âš ï¸ Quality gate has recommendations:"
            foreach ($issue in $issues) {
              echo "   $issue"
            }
          }

      - name: ðŸ“‹ Generate quality report
        if: always()
        run: |
          echo "## ðŸŽ¯ Code Quality Gate Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| C# Files | ${{ steps.quality-metrics.outputs.cs-files }} | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| XAML Files | ${{ steps.quality-metrics.outputs.xaml-files }} | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| Test Files | ${{ steps.quality-metrics.outputs.test-files }} | ðŸ“Š |" >> $GITHUB_STEP_SUMMARY
          echo "| Test Ratio | ${{ steps.quality-metrics.outputs.test-coverage }}% | ðŸ“ˆ |" >> $GITHUB_STEP_SUMMARY
          echo "| Coverage (Cobertura) | ${{ steps.coverage.outputs.coverage }}% (min ${{ steps.coverage.outputs.coverage-threshold }}%) | ${{ steps.coverage.outputs.coverage-pass == 'true' && 'âœ…' || 'âŒ' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ViewModels | ${{ steps.quality-metrics.outputs.viewmodel-files }} | ðŸ—ï¸ |" >> $GITHUB_STEP_SUMMARY
          echo "| Services | ${{ steps.quality-metrics.outputs.service-files }} | âš™ï¸ |" >> $GITHUB_STEP_SUMMARY
          echo "| Quality Gate | ${{ steps.quality-gate.outputs.quality-gate-passed == 'true' && 'âœ… PASSED' || 'âš ï¸ RECOMMENDATIONS' }} | ðŸŽ¯ |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ðŸ’¡ Recommendation:** Focus on test coverage for critical business logic and ViewModels" >> $GITHUB_STEP_SUMMARY







